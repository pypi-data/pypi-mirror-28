#!/usr/bin/python
#-*- coding: UTF-8 -*-

""" This program loads a underworlds world, and display its
3D scene.

Based on:
- pygame code from http://3dengine.org/Spectator_%28PyOpenGL%29
- http://www.lighthouse3d.com/tutorials
- http://www.songho.ca/opengl/gl_transform.html
- http://code.activestate.com/recipes/325391/
- ASSIMP's C++ SimpleOpenGL viewer
"""
import sys

import logging
logger = logging.getLogger("underworlds.3d_viewer")
gllogger = logging.getLogger("OpenGL")
gllogger.setLevel(logging.WARNING)
logging.basicConfig(level=logging.INFO)

import OpenGL
#OpenGL.ERROR_CHECKING=False
#OpenGL.ERROR_LOGGING = False
#OpenGL.ERROR_ON_COPY = True
#OpenGL.FULL_LOGGING = True
from OpenGL.GL import *
from OpenGL.error import GLError
from OpenGL.GLU import *
from OpenGL.GLUT import *
from OpenGL.arrays import vbo
from OpenGL.GL import shaders

import pygame
import pygame.font
import pygame.image

import math, random
import numpy
from numpy import linalg

import underworlds
from underworlds import situations
from underworlds.types import *
from underworlds.helpers.geometry import transform, get_scene_bounding_box, get_world_transform
from underworlds.helpers import transformations


#rendering mode
BASE = "BASE"
COLORS = "COLORS"
SILHOUETTE = "SILHOUETTE"
AXIS = "AXIS"

FLAT_VERTEX_SHADER="""
#version 130

uniform mat4 u_viewProjectionMatrix;
uniform mat4 u_modelMatrix;

uniform vec4 u_materialDiffuse;

in vec3 a_vertex;

out vec4 v_color;

void main(void)
{
    v_color = u_materialDiffuse;
    gl_Position = u_viewProjectionMatrix * u_modelMatrix * vec4(a_vertex, 1.0);
}
"""


BASIC_VERTEX_SHADER="""
#version 130

uniform mat4 u_viewProjectionMatrix;
uniform mat4 u_modelMatrix;
uniform mat3 u_normalMatrix;
uniform vec3 u_lightPos;

uniform vec4 u_materialDiffuse;

in vec3 a_vertex;
in vec3 a_normal;

out vec4 v_color;

void main(void)
{
    // Now the normal is in world space, as we pass the light in world space.
    vec3 normal = u_normalMatrix * a_normal;

    float dist = distance(a_vertex, u_lightPos);

    // go to https://www.desmos.com/calculator/nmnaud1hrw to play with the parameters
    // att is not used for now
    float att=1.0/(1.0+0.8*dist*dist);

    vec3 surf2light = normalize(u_lightPos - a_vertex);
    vec3 norm = normalize(normal);
    float dcont=max(0.0,dot(norm,surf2light));

    float ambient = 0.3;
    float intensity = dcont + 0.3 + ambient;

    v_color = u_materialDiffuse  * intensity;

    gl_Position = u_viewProjectionMatrix * u_modelMatrix * vec4(a_vertex, 1.0);
}
"""

BASIC_FRAGMENT_SHADER="""
#version 130

in vec4 v_color;

void main() {
    gl_FragColor = v_color;
}
"""

GOOCH_VERTEX_SHADER="""
#version 130

// attributes
in vec3 a_vertex; // xyz - position
in vec3 a_normal; // xyz - normal

// uniforms
uniform mat4 u_modelMatrix;
uniform mat4 u_viewProjectionMatrix;
uniform mat3 u_normalMatrix;
uniform vec3 u_lightPos;
uniform vec3 u_camPos;

// output data from vertex to fragment shader
out vec3 o_normal;
out vec3 o_lightVector;

///////////////////////////////////////////////////////////////////

void main(void)
{
   // transform position and normal to world space
   vec4 positionWorld = u_modelMatrix * vec4(a_vertex, 1.0);
   vec3 normalWorld = u_normalMatrix * a_normal;

   // calculate and pass vectors required for lighting
   o_lightVector = u_lightPos - positionWorld.xyz;
   o_normal = normalWorld;

   // project world space position to the screen and output it
   gl_Position = u_viewProjectionMatrix * positionWorld;
}
"""

GOOCH_FRAGMENT_SHADER="""
#version 130

// data from vertex shader
in vec3 o_normal;
in vec3 o_lightVector;

// diffuse color of the object
uniform vec4 u_materialDiffuse;
// cool color of gooch shading
uniform vec3 u_coolColor;
// warm color of gooch shading
uniform vec3 u_warmColor;
// how much to take from object color in final cool color
uniform float u_alpha;
// how much to take from object color in final warm color
uniform float u_beta;

// output to framebuffer
out vec4 resultingColor;

///////////////////////////////////////////////////////////

void main(void)
{
   // normlize vectors for lighting
   vec3 normalVector = normalize(o_normal);
   vec3 lightVector = normalize(o_lightVector);
   // intensity of diffuse lighting [-1, 1]
   float diffuseLighting = dot(lightVector, normalVector);
   // map intensity of lighting from range [-1; 1] to [0, 1]
   float interpolationValue = (1.0 + diffuseLighting)/2;

   //////////////////////////////////////////////////////////////////

   // cool color mixed with color of the object
   vec3 coolColorMod = u_coolColor + vec3(u_materialDiffuse) * u_alpha;
   // warm color mixed with color of the object
   vec3 warmColorMod = u_warmColor + vec3(u_materialDiffuse) * u_beta;
   // interpolation of cool and warm colors according
   // to lighting intensity. The lower the light intensity,
   // the larger part of the cool color is used
   vec3 colorOut = mix(coolColorMod, warmColorMod, interpolationValue);

   //////////////////////////////////////////////////////////////////

   // save color
   resultingColor.rgb = colorOut;
   resultingColor.a = 1;
} 
"""

SILHOUETTE_VERTEX_SHADER="""
#version 130

in vec3 a_vertex; // xyz - position
in vec3 a_normal; // xyz - normal

uniform mat4 u_modelMatrix;
uniform mat4 u_viewProjectionMatrix;
uniform vec4 u_materialDiffuse;
uniform float u_offset; // offset along normal

out vec4 v_color;

void main(void){
   v_color = u_materialDiffuse;
   vec4 tPos   = vec4(a_vertex + a_normal * u_offset, 1.0);
   gl_Position = u_viewProjectionMatrix * u_modelMatrix * tPos;
}
"""


class DefaultCamera(Node):
    def __init__(self, w, h, fov):
        super(DefaultCamera, self).__init__(name="default camera", type=CAMERA)
        self.clipplanenear = 0.001
        self.clipplanefar = 100000.0
        self.aspect = w/h
        self.horizontalfov = fov * math.pi/180
        self.transformation = [[ 0.68, -0.32, 0.65, 7.48],
                               [ 0.73,  0.31, -0.61, -6.51],
                               [-0.01,  0.89,  0.44,  5.34],
                               [ 0.,    0.,    0.,    1.  ]]
        self.lookat = [0.0,0.0,-1.0]

class Underworlds3DViewer:

    base_name = "Underworlds 3D viewer"

    def __init__(self, ctx, world, w=1024, h=768, fov=75):

        self.w = w
        self.h = h

        pygame.init()
        self.base_name = self.base_name + " <%s>" % world
        pygame.display.set_caption(self.base_name)
        pygame.display.set_mode((w,h), pygame.OPENGL | pygame.DOUBLEBUF)

        glClearColor(0.7,0.7,0.6,1.0)

        self.prepare_shaders()

        self.fontmanager = FontManager(None, w, h, 18)

        self.ctx = ctx
        self.world = ctx.worlds[world]

        self.scene = None
        self.meshes = {} # stores the OpenGL vertex/faces/normals buffers pointers

        self.node2colorid = {} # stores a color ID for each node. Useful for mouse picking and visibility checking
        self.colorid2node = {} # reverse dict of node2colorid

        self.currently_selected = None
        self.moving = False
        self.moving_situation = None

        self.cameras = []
        self.current_cam_index = 0

        self.load_world()

        # for FPS computation
        self.frames = 0
        self.last_fps_time = glutGet(GLUT_ELAPSED_TIME)


        self.cycle_cameras()
        self.update_view_camera()

    def prepare_shaders(self):

        ### Base shader
        vertex = shaders.compileShader(BASIC_VERTEX_SHADER, GL_VERTEX_SHADER)
        fragment = shaders.compileShader(BASIC_FRAGMENT_SHADER, GL_FRAGMENT_SHADER)

        self.shader = shaders.compileProgram(vertex,fragment)

        self.set_shader_accessors( ('u_modelMatrix',
                                    'u_viewProjectionMatrix',
                                    'u_normalMatrix',
                                    'u_lightPos',
                                    'u_materialDiffuse'), 
                                    ('a_vertex',
                                      'a_normal'), self.shader)

        ### Flat shader
        flatvertex = shaders.compileShader(FLAT_VERTEX_SHADER, GL_VERTEX_SHADER)
        self.flatshader = shaders.compileProgram(flatvertex,fragment)

        self.set_shader_accessors( ('u_modelMatrix',
                                    'u_viewProjectionMatrix',
                                    'u_materialDiffuse',), 
                                    ('a_vertex',), self.flatshader)


        ### Silhouette shader
        silh_vertex = shaders.compileShader(SILHOUETTE_VERTEX_SHADER, GL_VERTEX_SHADER)
        self.silhouette_shader = shaders.compileProgram(silh_vertex,fragment)

        self.set_shader_accessors( ('u_modelMatrix',
                                    'u_viewProjectionMatrix',
                                    'u_materialDiffuse',
                                    'u_offset'  # width of the silhouette
                                    ), 
                                    ('a_vertex',
                                      'a_normal'), self.silhouette_shader)


        ### Gooch shader
        gooch_vertex = shaders.compileShader(GOOCH_VERTEX_SHADER, GL_VERTEX_SHADER)
        gooch_fragment = shaders.compileShader(GOOCH_FRAGMENT_SHADER, GL_FRAGMENT_SHADER)
        self.gooch_shader = shaders.compileProgram(gooch_vertex, gooch_fragment)

        self.set_shader_accessors( ('u_modelMatrix',
                                    'u_viewProjectionMatrix',
                                    'u_normalMatrix',
                                    'u_lightPos',
                                    'u_materialDiffuse',
                                    'u_coolColor',
                                    'u_warmColor',
                                    'u_alpha',
                                    'u_beta'
                                    ), 
                                    ('a_vertex',
                                      'a_normal'), self.gooch_shader)

    def set_shader_accessors(self, uniforms, attributes, shader):
        # add accessors to the shaders uniforms and attributes
        for uniform in uniforms:
            location = glGetUniformLocation( shader,  uniform )
            if location in (None,-1):
                raise RuntimeError('No uniform: %s (maybe it is not used '
                                   'anymore and has been optimized out by'
                                   ' the shader compiler)'%( uniform ))
            setattr( shader, uniform, location )

        for attribute in attributes:
            location = glGetAttribLocation( shader, attribute )
            if location in (None,-1):
                raise RuntimeError('No attribute: %s'%( attribute ))
            setattr( shader, attribute, location )

    def prepare_gl_buffers(self, id):

        meshes = self.meshes

        if id in meshes:
            # mesh already loaded. Fine
            return

        meshes[id] = {}

        # leave some time for new nodes to push their meshes
        while not self.ctx.has_mesh(id):
            time.sleep(0.01)

        mesh = self.ctx.mesh(id) # retrieve the mesh from the server

        # Fill the buffer for vertex and normals positions
        v = numpy.array(mesh["vertices"], 'f')
        n = numpy.array(mesh["normals"], 'f')

        #meshes[id]["vbo"] = glGenBuffers(1)
        #glBindBuffer(GL_ARRAY_BUFFER, meshes[id]["vbo"])
        #glBufferData(GL_ARRAY_BUFFER, 
        #            numpy.hstack((v,n)), # concatenate vertices and normals in one array
        #            GL_STATIC_DRAW)

        meshes[id]["vbo"] = vbo.VBO(numpy.hstack((v,n)))

        # Fill the buffer for vertex positions
        meshes[id]["faces"] = glGenBuffers(1)
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, meshes[id]["faces"])
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, 
                    numpy.array(mesh["faces"], dtype=numpy.int32),
                    GL_STATIC_DRAW)

        meshes[id]["nbfaces"] = len(mesh["faces"])
        meshes[id]["material"] = mesh["material"]

        # Unbind buffers
        glBindBuffer(GL_ARRAY_BUFFER,0)
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0)

    def get_rgb_from_colorid(self, colorid):
        r = (colorid >> 0) & 0xff
        g = (colorid >> 8) & 0xff
        b = (colorid >> 16) & 0xff

        return (r,g,b)

    def get_color_id(self):
        id = random.randint(0, 256*256*256)
        if id not in self.colorid2node:
            return id
        else:
            return self.get_color_id()

    def glize(self, node):

        node.selected = False

        if node.type == MESH:
            colorid = self.get_color_id()
            self.colorid2node[colorid] = node
            self.node2colorid[node] = colorid

            if hasattr(node, "cad"):
                node.glmeshes = node.cad
            elif hasattr(node, "lowres"):
                node.glmeshes = node.lowres
            elif hasattr(node, "hires"):
                node.glmeshes = node.hires
            else:
                raise StandardError("The node %s has no mesh available!" % node.name)
            for mesh in node.glmeshes:
                self.prepare_gl_buffers(mesh)

        elif node.type == CAMERA:
            if node not in self.cameras:
                logger.info("Added camera <%s>" % node.name)
                logger.info("Camera position: %.3f, %.3f, %.3f" % tuple(node.transformation[:,3][:3].tolist()))
            else:
                self.cameras.remove(node)
            self.cameras.append(node)
            self.current_cam = self.cameras[self.current_cam_index]



    def load_world(self):
        logger.info("Preparing world <%s> for 3D rendering..." % self.world)

        scene = self.scene = self.world.scene
        nodes = scene.nodes
        for node in nodes:
            logger.info("Loading node <%s>" % node)
            self.glize(node)

        #log some statistics
        logger.info("  -> %d nodes" % len(nodes))

        scene_aabb = get_scene_bounding_box(scene)

        if not scene_aabb:
            logger.warning("Nothing to display. Leaving now.")
            sys.exit(0)

        self.bb_min, self.bb_max = scene_aabb
        logger.info("  -> scene bounding box:" + str(self.bb_min) + " - " + str(self.bb_max))

        self.scene_center = [(a + b) / 2. for a, b in zip(self.bb_min, self.bb_max)]

        logger.info("World <%s> ready for 3D rendering." % self.world)

    def cycle_cameras(self):
        if not self.cameras:
            logger.info("No camera in the scene. Adding a default one")
            self.cameras = [DefaultCamera(w,h,fov)]
            return None
        self.current_cam_index = (self.current_cam_index + 1) % len(self.cameras)
        self.current_cam = self.cameras[self.current_cam_index]
        self.set_camera_projection(self.current_cam)
        logger.info("Switched to camera <%s>" % self.current_cam)

    def set_overlay_projection(self):
        glViewport(0,0,self.w,self.h)
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        glOrtho(0.0, self.w - 1.0, 0.0, self.h - 1.0, -1.0, 1.0)
        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()

    def set_camera_projection(self, camera = None):

        if not camera:
            camera = self.cameras[self.current_cam_index]

        znear = camera.clipplanenear
        zfar = camera.clipplanefar
        aspect = camera.aspect
        fov = camera.horizontalfov

        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()

        # Compute gl frustrum
        tangent = math.tan(fov/2.)
        h = znear * tangent
        w = h * aspect

        # params: left, right, bottom, top, near, far
        glFrustum(-w, w, -h, h, znear, zfar)
        # equivalent to:
        #gluPerspective(fov * 180/math.pi, aspect, znear, zfar)

        self.projection_matrix = glGetFloatv( GL_PROJECTION_MATRIX).transpose()

        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()


    def render_colors(self):

        glEnable(GL_DEPTH_TEST)
        glDepthFunc(GL_LEQUAL)


        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
        glEnable(GL_CULL_FACE)

        glUseProgram(self.flatshader)

        glUniformMatrix4fv( self.flatshader.u_viewProjectionMatrix, 1, GL_TRUE,
                            numpy.dot(self.projection_matrix,self.view_matrix))


        self.recursive_render(self.scene.rootnode, self.flatshader, mode=COLORS)

        glUseProgram( 0 )

    def get_hovered_node(self, mousex, mousey):
        """
        Attention: The performances of this method relies heavily on the size of the display!
        """

        self.render_colors()
        # Capture image from the OpenGL buffer
        buf = ( GLubyte * (3 * self.w * self.h) )(0)
        glReadPixels(0, 0, self.w, self.h, GL_RGB, GL_UNSIGNED_BYTE, buf)

        #Reinterpret the RGB pixel buffer as a 1-D array of 24bits colors
        a = numpy.ndarray(len(buf), numpy.dtype('>u1'), buf)
        colors = numpy.zeros(len(buf) / 3, numpy.dtype('<u4'))
        for i in range(3):
            colors.view(dtype='>u1')[i::4] = a.view(dtype='>u1')[i::3]

        colorid = colors[mousex + mousey * self.w]

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

        if colorid in self.colorid2node:
            return self.colorid2node[colorid]


    def check_visibility(self):
        """
        Attention: The performances of this method relies heavily on the size of the display!
        """
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        self.render_colors()
        # Capture image from the OpenGL buffer
        buf = ( GLubyte * (3 * self.w * self.h) )(0)
        glReadPixels(0, 0, self.w, self.h, GL_RGB, GL_UNSIGNED_BYTE, buf)

        #Reinterpret the RGB pixel buffer as a 1-D array of 24bits colors
        a = numpy.ndarray(len(buf), numpy.dtype('>u1'), buf)
        colors = numpy.zeros(len(buf) / 3, numpy.dtype('<u4'))
        for i in range(3):
            colors.view(dtype='>u1')[i::4] = a.view(dtype='>u1')[i::3]

        colors = colors[numpy.nonzero(colors)] #discard black background
        
        if colors.any():
            bins = numpy.bincount(colors)
            ii = numpy.nonzero(bins)[0]

            for i in ii:
                print ("Node %s is visible (%d pix)" % (self.colorid2node[i], bins[i]))
        else:
            print("Nothing visible!")

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    def screenshot(self, filename = "screenshot.png"):

        logger.info("Taking a screenshot...")
        import Image
        # Capture image from the OpenGL buffer
        buffer = ( GLubyte * (3 * self.w * self.h) )(0)
        glReadPixels(0, 0, self.w, self.h, GL_RGB, GL_UNSIGNED_BYTE, buffer)

        # Use PIL to convert raw RGB buffer and flip the right way up
        image = Image.frombytes(mode="RGB", size=(self.w, self.h), data=buffer)
        image = image.transpose(Image.FLIP_TOP_BOTTOM)

        # Save image to disk
        image.save(filename)
        logger.info("...done. Image saved as <%s>." % filename)


    def render(self, wireframe = False, twosided = False):

        glEnable(GL_DEPTH_TEST)
        glDepthFunc(GL_LEQUAL)


        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE if wireframe else GL_FILL)
        glDisable(GL_CULL_FACE) if twosided else glEnable(GL_CULL_FACE)

        self.render_axis_and_grid()

        ### First, the silhouette

        shader = self.silhouette_shader

        #glDepthMask(GL_FALSE)
        glCullFace (GL_FRONT) # cull front faces

        glUseProgram(shader)
        glUniform1f( shader.u_offset, 0.1)

        glUniformMatrix4fv( shader.u_viewProjectionMatrix, 1, GL_TRUE,
                            numpy.dot(self.projection_matrix,self.view_matrix))


        self.recursive_render(self.scene.rootnode, shader, mode=SILHOUETTE)

        glUseProgram( 0 )

        ### Then, inner shading
        #glDepthMask(GL_TRUE)
        glCullFace (GL_BACK)
        #shader = self.shader
        shader = self.gooch_shader

        glUseProgram(shader)
        glUniform3f( shader.u_lightPos, -.5,-.5,.5 )

        ##### GOOCH specific
        glUniform3f( shader.u_coolColor, 159.0/255, 148.0/255, 255.0/255)
        glUniform3f( shader.u_warmColor, 255.0/255, 75.0/255, 75.0/255)
        glUniform1f( shader.u_alpha, .25)
        glUniform1f( shader.u_beta, .25)
        #########

        glUniformMatrix4fv( shader.u_viewProjectionMatrix, 1, GL_TRUE,
                            numpy.dot(self.projection_matrix,self.view_matrix))


        self.recursive_render(self.scene.rootnode, shader)

        glUseProgram( 0 )

<<<<<<< 02b495f0f96cfaf1b3bb49d0ebfafa56c8ae9eef
    def render_axis(self, transformation = numpy.identity(4, dtype=numpy.float32)):
=======
        self.recursive_render(self.scene.rootnode, None, mode=AXIS)

    def render_axis(self, transformation = numpy.identity(4)):
>>>>>>> [3d view] Added a 'axis' rendering pass to show meshless entities
        m = transformation.transpose() # OpenGL row major

        glPushMatrix()
        glMultMatrixf(m)

        glLineWidth(3)
        glBegin(GL_LINES)

        # draw line for x axis
        glColor3f(1.0, 0.0, 0.0)
        glVertex3f(0.0, 0.0, 0.0)
        glVertex3f(1.0, 0.0, 0.0)

        # draw line for y axis
        glColor3f(0.0, 1.0, 0.0)
        glVertex3f(0.0, 0.0, 0.0)
        glVertex3f(0.0, 1.0, 0.0)

        # draw line for Z axis
        glColor3f(0.0, 0.0, 1.0)
        glVertex3f(0.0, 0.0, 0.0)
        glVertex3f(0.0, 0.0, 1.0)

        glEnd()

        glPopMatrix();

    def render_axis_and_grid(self):

        glLineWidth(1)
        glColor3f(0.5, 0.5, 0.5)
        glBegin(GL_LINES)
        for i in range(-10,11):
            glVertex3f(i, -10.0, 0.0)
            glVertex3f(i, 10.0, 0.0)

        for i in range(-10, 11):
            glVertex3f(-10.0, i, 0.0)
            glVertex3f(10.0, i, 0.0)
        glEnd()

        #self.render_axis()


    def recursive_render(self, node, shader, mode = BASE, with_normals=True):
        """ Main recursive rendering method.
        """

        normals = with_normals
        ambient = True
        if mode == COLORS:
            normals = False
            ambient = False

        try:
            m = get_world_transform(self.scene, node)
        except AttributeError:
            #probably a new incoming node, that has not yet been converted to numpy
            self.glize(node)
            m = get_world_transform(self.scene, node)

        # AXIS mode
        ###
        if mode == AXIS:
            if node.type == ENTITY:
                self.render_axis(m)

            for child in node.children:
                self.recursive_render(self.scene.nodes[child], shader, mode)
            return

        # Mesh rendering modes
        ###
        if node.type == MESH:

            for id in node.glmeshes:

                stride = 24 # 6 * 4 bytes

                if node.selected and mode == SILHOUETTE:
                    glUniform4f( shader.u_materialDiffuse, 1.0, 0.0, 0.0, 1.0 )
                else:
                    if mode == COLORS:
                            colorid = self.node2colorid[node]
                            r,g,b= self.get_rgb_from_colorid(colorid)
                            glUniform4f( shader.u_materialDiffuse, r/255.0,g/255.0,b/255.0,1.0 )
                    elif mode == SILHOUETTE:
                        glUniform4f( shader.u_materialDiffuse, .0, .0, .0, 1.0 )
                    else:
                        diffuse = self.meshes[id]["material"]["diffuse"]
                        if len(diffuse) == 3: # RGB instead of expected RGBA
                            diffuse.append(1.0)
                        glUniform4f( shader.u_materialDiffuse, *diffuse )
                        #if ambient:
                        #    glUniform4f( shader.Material_ambient, *mat["ambient"] )


                if mode == BASE: # not in COLORS or SILHOUETTE
                    normal_matrix = linalg.inv(numpy.dot(self.view_matrix, m)[0:3,0:3]).transpose()
                    glUniformMatrix3fv( shader.u_normalMatrix, 1, GL_TRUE, normal_matrix )

                glUniformMatrix4fv( shader.u_modelMatrix, 1, GL_TRUE, m )

                vbo = self.meshes[id]["vbo"]
                vbo.bind()

                glEnableVertexAttribArray( shader.a_vertex )
                if normals:
                    glEnableVertexAttribArray( shader.a_normal )

                glVertexAttribPointer(
                    shader.a_vertex,
                    3, GL_FLOAT,False, stride, vbo
                )

                if normals:
                    glVertexAttribPointer(
                        shader.a_normal,
                        3, GL_FLOAT,False, stride, vbo+12
                    )

                glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.meshes[id]["faces"])
                glDrawElements(GL_TRIANGLES, self.meshes[id]["nbfaces"] * 3, GL_UNSIGNED_INT, None)


                vbo.unbind()
                glDisableVertexAttribArray( shader.a_vertex )

                if normals:
                    glDisableVertexAttribArray( shader.a_normal )


                glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)

        for child in node.children:
            self.recursive_render(self.scene.nodes[child], shader, mode)


    def switch_to_overlay(self):
        glPushMatrix()
        self.set_overlay_projection()

    def switch_from_overlay(self):
        self.set_camera_projection()
        glPopMatrix()


    def display(self, text, x, y):
        self.fontmanager.display(text,x,y)

    def select_node(self, node):
        self.currently_selected = node
        for n in self.scene.nodes:
            if n is node:
                n.selected = True
            else:
                n.selected = False

    def loop(self):

        pygame.display.flip()
        event = pygame.event.poll()
        self.keys = [k for k, pressed in enumerate(pygame.key.get_pressed()) if pressed]

        if event.type == pygame.KEYDOWN:
            if pygame.K_f in self.keys: pygame.display.toggle_fullscreen()
            if pygame.K_s in self.keys: self.screenshot()
            if pygame.K_v in self.keys: self.check_visibility()
            if pygame.K_TAB in self.keys: self.cycle_cameras()
            if pygame.K_ESCAPE in self.keys:
                return False

        if event.type == pygame.MOUSEBUTTONDOWN:

            if pygame.mouse.get_pressed()[0]: # left button pressed
                mousex, mousey = pygame.mouse.get_pos()
                hovered = self.get_hovered_node(mousex, self.h - mousey)
                if hovered:
                    logger.debug("Node %s selected" % hovered)
                    self.select_node(hovered)
                else:
                    self.select_node(None)
            if pygame.mouse.get_pressed()[2]: # right button pressed
                self.select_node(None)

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

        # Compute FPS
        gl_time = glutGet(GLUT_ELAPSED_TIME)
        self.frames += 1
        if gl_time - self.last_fps_time >= 1000:
            current_fps = self.frames * 1000 / (gl_time - self.last_fps_time)
            pygame.display.set_caption(self.base_name + " - %.0f fps" % current_fps)
            self.frames = 0
            self.last_fps_time = gl_time


        return True

    def controls_3d(self,
                    mouse_button=1, \
                    up_key=pygame.K_UP, \
                    down_key=pygame.K_DOWN, \
                    left_key=pygame.K_LEFT, \
                    right_key=pygame.K_RIGHT):

        mouse_dx,mouse_dy = pygame.mouse.get_rel()
        pressed_buttons = pygame.mouse.get_pressed()

        update_camera = False


        if pressed_buttons[mouse_button]:

            rotate_x = -mouse_dx * 0.1
            rotate_y = mouse_dy * 0.1
            update_camera = True
        else:
            rotate_x = rotate_y = 0

        if up_key in self.keys:
            up = .1
        elif down_key in self.keys:
            up = -.1
        else:
            up = 0

        if left_key in self.keys:
            strafe = .1
        elif right_key in self.keys:
            strafe = -.1
        else:
            strafe = 0

        if up or strafe:
            if not self.currently_selected:
                update_camera = True
            else:
                if not self.moving:
                    self.moving_situation = Situation("motion of %s" % self.currently_selected.name, type = situations.MOTION)
                    self.world.timeline.start(self.moving_situation)
                self.moving = True
                self.move_selected_node(up, strafe)
        else:
            if self.moving:
                self.world.timeline.end(self.moving_situation)
                self.moving = False

        if update_camera:

            cam_transform = transformations.euler_matrix(rotate_y * math.pi/180.0,
                                                         -rotate_x * math.pi/180.0,
                                                         0).astype(numpy.float32)
            cam_transform[0,3] = -strafe
            cam_transform[1,3] = up
            #cam_transform[2,3] = fwd

            self.current_cam.transformation = numpy.dot(self.current_cam.transformation, cam_transform)

            self.broadcast_node_transform(self.current_cam)

            update_camera = False

        self.update_view_camera()


    def update_view_camera(self):

        self.view_matrix = linalg.inv(self.current_cam.transformation)

        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()
        glMultMatrixf(self.view_matrix.transpose())

    def move_selected_node(self, up, strafe):
        self.currently_selected.transformation[0][3] += strafe
        self.currently_selected.transformation[2][3] += up

        self.broadcast_node_transform(self.currently_selected)


    def broadcast_node_transform(self, node):
        self.scene.nodes.update(node)

def main():
    with underworlds.Context("3D viewer") as ctx:
        app = Underworlds3DViewer(ctx, world = sys.argv[1])

        while app.loop():
            app.render()
            app.switch_to_overlay()
            app.display("world <%s>"% app.world, 10, app.h - 30)
            if app.currently_selected:
                app.display("node <%s>"% app.currently_selected, 10, app.h - 50)
                pos = app.h - 70
                for key, value in app.currently_selected.properties.items():

                    app.display("%s: %s" % (key, value), 30, pos)
                    pos -= 20

            app.switch_from_overlay()
            app.controls_3d(0)

            pygame.time.wait(10)


#########################################################################
#                               FONT MANAGEMENT                         #
#########################################################################
"""
    Copyright (c) 2002. Nelson Rush. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
"""

class FontManager:
    def __init__(self, fontname, width, height, fontsize = 18):

        self.w = width
        self.h = height
        pygame.font.init()
        if not pygame.font.get_init():
            print 'Could not render font.'
            raise Exception("Error while initializing the font rendering engine")

        self.font = pygame.font.Font(fontname, fontsize)
        self.char = []
        for c in range(256):
            self.char.append(self.CreateCharacter(chr(c)))
        self.char = tuple(self.char)
        self.lw = self.char[ord('0')][1]
        self.lh = self.char[ord('0')][2]

    def CreateCharacter(self, s):
        try:
            letter_render = self.font.render(s, 1, (10,10,10), (255*0.7,255*0.7,255*0.6))
            letter = pygame.image.tostring(letter_render, 'RGBA', 1)
            letter_w, letter_h = letter_render.get_size()
        except:
            letter = None
            letter_w = 0
            letter_h = 0
        return (letter, letter_w, letter_h)

    def display(self, text, x, y):
        s = str(text)
        i = 0
        lx = 0
        length = len(s)
        glPushMatrix()
        while i < length:
            glRasterPos2i(x + lx, y)
            ch = self.char[ ord( s[i] ) ]
            glDrawPixels(ch[1], ch[2], GL_RGBA, GL_UNSIGNED_BYTE, ch[0])
            lx += ch[1]
            i += 1
        glPopMatrix()

    def __del__(self):
        pygame.font.quit()

#########################################################################
#########################################################################

if __name__ == '__main__':
    if not len(sys.argv) > 1:
        print("Usage: " + __file__ + " <world name>")
        sys.exit(2)

    main()


