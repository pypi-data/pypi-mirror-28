from __future__ import print_function

from distutils import ccompiler, sysconfig
from setuptools import setup
from setuptools import Extension
import glob
import sys
import os
import numpy as np
import ctypes



"""
Setup script for the hds python extension
"""

# The hds library requires: starmem, ems, hds and sae to build.
#  These must all be built before hds is.

hds_path = 'hds-v4-5.2-1/'
ems_path = 'ems-2.4-0/'
starmem_path = 'starmem-0.2-1/'
sae_path = 'sae-1.1/'
cnf_path = 'cnf-5.1-0/'
mers_path = 'mers-2.2-0/'
starutil_path = 'starutil-0.1-1/'

# starmem: these sources are taking from the Makefile.am after doing a
# make dist in starmem.

starmem_PUBLIC_C_FILES = [
    'starMalloc.c',
    'starMallocAtomic.c',
    'starMemInitPrivate.c',
    'starFree.c',
    'starFreeForce.c',
    'starRealloc.c',
    'starCalloc.c',
    'starMemIsInitialised.c'
]

starmem_PRIVATE_C_FILES = ['mem1_globals.c', 'dlmalloc.c']
starmem_PUBLIC_CINCLUDES = ['mem.h']
starmem_PRIVATE_INCLUDES = ['mem1.h', 'dlmalloc.h']
starmem_sources = [os.path.join(starmem_path, i)
                  for i in
                  starmem_PRIVATE_C_FILES + starmem_PUBLIC_C_FILES]

# ems
ems_C_ROUTINES=[
    'emsAnnul.c', 'emsBegin.c', 'emsEload.c', 'emsEnd.c', 'emsErrno.c',
    'emsExpnd.c', 'emsFacer.c', 'emsLevel.c', 'emsMark.c', 'emsMload.c',
    'emsRenew.c', 'emsRep.c', 'emsRlse.c', 'emsSetc.c', 'emsSetd.c',
    'emsSeti.c', 'emsSetk.c', 'emsSetl.c', 'emsSetnc.c', 'emsSetp.c',
    'emsSetr.c', 'emsSetu.c', 'emsStat.c', 'emsSyser.c', 'emsTune.c',
    'emsGtune.c', 'emsStune.c',
    'emsSet.c', 'emsSetv.c',
    'ems1Eblk.c', 'ems1Emark.c', 'ems1Erlse.c', 'ems1Estor.c', 'ems1Estor1.c',
    'ems1Fcerr.c', 'ems1Flush.c', 'ems1Form.c', 'ems1Fthreaddata.c', 'ems1Gesc.c',
    'ems1Gmsgtab.c', 'ems1Gmsgtab2.c', 'ems1Gnam.c', 'ems1Gtok.c', 'ems1Gtoktab.c',
    'ems1Gthreadbuf.c', 'ems1Iepnd.c', 'ems1Imsgtab.c', 'ems1Ithreaddata.c',
    'ems1Itoktab.c', 'ems1Kerr.c', 'ems1Ktok.c', 'ems1Mpop.c', 'ems1Mpush.c',
    'ems1Prerr.c', 'ems1Putc.c', 'ems1Rform.c', 'ems1Serr.c', 'ems1Starf.c',
    'ems1Stok.c', 'ems1Tblk.c', 'ems1Rep.c', 'emsRepv.c', 'emsRepf.c']

ems_PUBLIC_INCLUDES = ['ems.h', 'ems_par.h']
ems_PRIVATE_INCLUDES = ['ems_sys.h', 'ems1.h', 'ems_defs.h']
ems_sources = [os.path.join(ems_path, i)
                  for i in
                  ems_C_ROUTINES]

#starutil
starutil_PUBLIC_C_FILES=['star_strlcat.c', 'star_strlcpy.c', 'star_strappend.c',
	'star_strellcpy.c']
starutil_sources = [os.path.join(starutil_path, i) for i in starutil_PUBLIC_C_FILES]


#sae: This only generates sai_err.h (generated by messgen, but included here), and the file sae_par.h
sae_INCLUDES = ['sai_err.h' 'sae_par.h']

#cnf
cnf_C_ROUTINES = ['cnfCopyf.c', 'cnfCreat.c', 'cnfCref.c', 'cnfCrefa.c', 'cnfCreib.c',
    'cnfCreim.c', 'cnfCrela.c',
    'cnfExpch.c', 'cnfExpla.c', 'cnfExpn.c', 'cnfExprt.c', 'cnfExprta.c', 'cnfExprtap.c',
    'cnfFreef.c',
    'cnfImpb.c', 'cnfImpbn.c', 'cnfImpch.c', 'cnfImpla.c', 'cnfImpn.c', 'cnfImprt.c',
    'cnfImprta.c', 'cnfImprtap.c', 'cnfLenc.c', 'cnfLenf.c',
    'cnfMem.c', 'cnfLock.c']
cnf_INCLUDES = ['f77.h']
cnf_sources = [os.path.join(cnf_path, i) for i in cnf_C_ROUTINES]

#mers
mers_C_INTERFACE_ROUTINES = [
'errAnnul.c',
'errBegin.c',
'errEnd.c',
'errFacer.c',
'errFlbel.c',
'errFlush.c',
'errLevel.c',
'errLoad.c',
'errMark.c',
'errOut.c',
'errRep.c',
'errRepf.c',
'errRlse.c',
'errStat.c',
'errSyser.c',
'errTune.c',
'msgBell.c',
'msgBlank.c',
'msgBlankif.c',
'msgFlevok.c',
'msgFlusherr.c',
'msgFmt.c',
'msgIfgetenv.c',
'msgIflev.c',
'msgIfset.c',
'msgLoad.c',
'msgOut.c',
'msgOutf.c',
'msgOutif.c',
'msgOutiff.c',
'msgOutifv.c',
'msgRenew.c',
'msgSetc.c',
'msgSetd.c',
'msgSeti.c',
'msgSetk.c',
'msgSetl.c',
'msgSetr.c',
'msgTune.c']

mers_C_ROUTINES_STAND = [
'err1Prerr_stand.c',
'msg1Form_stand.c',
'msg1Prtln_stand.c',
'msgSync_stand.c',
]
mers_C_ROUTINES = [
'err1Bell.c',
'err1Flush.c',
'err1Print.c',
'err1Rep.c',
'mers1Blk.c',
'mers1Getenv.c',
'msg1Ifget.c',
'msg1Ktok.c',
'msg1Levstr.c',
'msg1Outif.c',
'msg1Print.c']

mers_C_ROUTINES_ADAM = [
'err1Prerr_adam.c',
'msg1Form_adam.c',
'msg1Genv_adam.c',
'msg1Gkey_adam.c',
'msg1Gref_adam.c',
'msg1Prtln_adam.c']

mers_C_INTERFACE_ADAM = [
'errClear_adam.c',
'errStart_adam.c',
'errStop_adam.c',
'msgIfget_adam.c',
'msgSync_adam.c']

mers_sources = [os.path.join(mers_path, i) for i in
                mers_C_INTERFACE_ROUTINES + mers_C_ROUTINES_STAND + mers_C_ROUTINES]# + mers_C_ROUTINES_ADAM]# + mers_C_INTERFACE_ADAM]
#hds
hds_C_ROUTINES = [
    'dat1_alloc_lcp.c', 'dat1_annul_lcp.c', 'dat1_check_mode.c',
    'dat1_check_type.c', 'dat1_cvt_format.c', 'dat1_cvt_order.c',
    'dat1_decoy.c', 'dat1_get_ncomp.c', 'dat1_get_odl.c', 'dat1_getenv.c',
    'dat1_import_loc.c', 'dat1_init.c', 'dat1_init_ndr.c', 'dat1_intune.c',
    'dat1_locate_name.c', 'dat1_pack_crv.c', 'dat1_pack_odl.c',
    'dat1_pack_srv.c', 'dat1_put_ncomp.c', 'dat1_put_odl.c',
    'dat1_show_ndr.c', 'dat1_unpack_crv.c', 'dat1_unpack_odl.c',
    'dat1_unpack_srv.c', 'dat1_unpack_type.c', 'dat1_free_hdsloc.c',
    'datClen.c', 'datCopy.c', 'datMsg.c', 'datRef.c',
    'datDrep.c', 'datErmsg.c', 'datParen.c', 'datPrec.c', 'datPrmry.c', 'datRefct.c',
    'datWhere.c', 'datalter.c', 'datannul.c', 'datccopy.c', 'daterase.c', 'datfinind.c',
    'datget.c', 'datget0x.c', 'datinq.c', 'datlocops.c', 'datmap.c', 'datmove.c', 'datnew.c',
    'datnew0.c', 'datMapN.c', 'datPut1C.c', 'datPutVC.c', 'datGet1C.c', 'datGetVC.c',
    'datChscn.c',
    'datput.c', 'datput0x.c', 'dattemp.c', 'daucheck.c', 'daucnv.c', 'daucopy.c',
    'dauflush.c',
    'dauloc.c', 'daumove.c', 'dauscatgath.c', 'daushape.c', 'dautypes.c',
    'hds1_cleanup.c',
    'hds1_exit.c', 'hdsCopy.c', 'hdsEwild.c', 'hds_globals.c', 'hdsGtune.c',
    'hdsState.c', 'hdsStop.c', 'hdsTune.c',
    'hdsWild.c', 'hdserase.c', 'hdsgroup.c', 'hdslock.c', 'hdsnew.c', 'hdsnull.c',
    'hdsopclos.c', 'hdstools.c', 'hdsInfoI.c',
    'dat1emsSetBigi.c', 'dat1emsSetBigu.c', 'dat1emsSetHdsdim.c',
    'rec1_alloc_frame.c', 'rec1_clear_cbm.c', 'rec1_close_file.c',
    'rec1_close_slot.c', 'rec1_create_file.c', 'rec1_deall_frame.c',
    'rec1_extend_file.c', 'rec1_extend_frame.c', 'rec1_find_file.c',
    'rec1_flush_block.c', 'rec1_fmsg.c', 'rec1_get_fid.c', 'rec1_get_path.c',
    'rec1_getcwd.c', 'rec1_locate_hcb.c', 'rec1_lock_slot.c',
    'rec1_map_frame.c', 'rec1_open_file.c', 'rec1_pack_chain.c',
    'rec1_pack_hcb.c', 'rec1_pack_ncomp.c', 'rec1_pack_rcl.c',
    'rec1_read_file.c', 'rec1_save_addr.c', 'rec1_scan_cbm.c',
    'rec1_set_cbm.c', 'rec1_shell.c', 'rec1_test_cbm.c', 'rec1_unlock_slot.c',
    'rec1_unmap_frame.c', 'rec1_unpack_chain.c', 'rec1_unpack_hcb.c',
    'rec1_unpack_ncomp.c', 'rec1_unpack_rcl.c', 'rec1_update_free.c',
    'rec1_write_file.c',
    'rec_adopt_record.c', 'rec_alloc_mem.c', 'rec_alloc_xmem.c',
    'rec_attach_file.c', 'rec_close_file.c', 'rec_create_record.c',
    'rec_count_files.c',
    'rec_deall_mem.c', 'rec_deall_xmem.c', 'rec_delete_record.c',
    'rec_end_wild.c', 'rec_extend_record.c', 'rec_get_handle.c',
    'rec_get_rcl.c', 'rec_get_rid.c', 'rec_list_files.c',
    'rec_locate_block.c', 'rec_locate_data.c', 'rec_locate_fns.c',
    'rec_lock.c', 'rec_mark_delete.c', 'rec_reall_mem.c', 'rec_refcnt.c',
    'rec_release_block.c', 'rec_release_data.c', 'rec_reset_record.c',
    'rec_same_file.c', 'rec_shrink_record.c', 'rec_start.c', 'rec_stop.c',
    'rec_unlock.c', 'rec_where.c', 'rec_wild_file.c',
    'rtl_fixups.c',
    'win_fixups.c',
    'hds_start.c']
hds_PUBLIC_CINCLUDES = ['hds_v4.h', 'hds_types.h', 'hds_v4_map.h']
hds_PRIVATE_INCLUDES =[
	'dat_par.h hds.h',
        'dat1.h','hds1.h','hds2.h', 'hds1_types.h',
	'rec.h','rec1.h','str.h',
        'win_fixups.h']
hds_sources = [os.path.join(hds_path, i) for i in hds_C_ROUTINES]

# with sources, we now need to replicate the configure action. I'm
# doing this manually witht he compiler,but I'm very sure this is a
# better and more automated way to do this from the configure files..
# Go through all the config.in files and fix them up:

# Test the compiler: find all the #undef commands from the config.h.in files
define_macros = []
compiler = ccompiler.new_compiler()
# The various sizeOF definitions.

#undef SIZEOF_INT
define_macros.append(('SIZEOF_INT', ctypes.sizeof(ctypes.c_int)))

#undef SIZEOF_LONG
define_macros.append(('SIZEOF_LONG', ctypes.sizeof(ctypes.c_long)))

#undef SIZEOF_LONG_DOUBLE
define_macros.append(('SIZEOF_LONG_DOUBLE', ctypes.sizeof(ctypes.c_longdouble)))

#undef SIZEOF_LONG_LONG
define_macros.append(('SIZEOF_LONG_LONG', ctypes.sizeof(ctypes.c_longlong)))

#undef SIZEOF_OFF_T
# don't know how to do this one.


#undef SIZEOF_SIZE_T
define_macros.append(('SIZEOF_SIZE_T', ctypes.sizeof(ctypes.c_size_t)))

#undef SIZEOF_TRAILARG
#I THINK THIS is only needed in the fortran interfaces?


#undef SIZEOF_UINT32_T
define_macros.append(('SIZEOF_UINT32_T', ctypes.sizeof(ctypes.c_uint32)))
#undef SIZEOF_VOIDP
define_macros.append(('SIZEOF_VOIDP', ctypes.sizeof(ctypes.c_voidp)))



#undef AC_APPLE_UNIVERSAL_BUILD
#undef FC_MAIN
#only needed in fortran?


#undef HAVE_ATEXIT
if compiler.has_function('atexit'):
    define_macros.append(('HAVE_ATEXIT', '1'))

#undef HAVE_BCOPY
#bcopy is on both test OSX and Linux systems, but has_function on linux raises
# an 'error: too few arguments to function 'bcopy'',. Works fine on
# clang. However, bcopy only used if memmove doesn't exist, so maybe don't worry about it?
if compiler.has_function('bcopy'):
    define_macros.append(('HAVE_BCOPY', '1'))

#undef HAVE_CRT_EXTERNS_H
# Not clear how to do. It looks like OSX should ahve these, but I don't know if that is universal. Defaulting to not setting for now?

#undef HAVE_DECL_CONFSTR
if compiler.has_function('confstr'):
    define_macros.append(('HAVE_DECL_CONFSTR', '1'))


#These systems aren't quite right: not sure how to check for declaration?
#undef HAVE_DECL_FSYNC
if compiler.has_function('fsync'):
    define_macros.append(('HAVE_DECL_FSYNC', '1'))

#undef HAVE_DECL_GETWD
#This one I may not want to declare? Looks like most systems think it isn't...

#undef HAVE_DECL_STRERROR_R
# Don't know what to do with this.


#undef HAVE_DLFCN_H
#Only used in configuring scripts???

#undef HAVE_FCNTL
if compiler.has_function('fcntl'):
    define_macros.append(('HAVE_FCNTL', '1'))

#undef HAVE_FC_MAIN
# Only needed in fortran?

#undef HAVE_FORK
#Not used.

#undef HAVE_FSEEKO
if compiler.has_function('fseeko'):
    define_macros.append(('HAVE_FSEEKO', '1'))

#undef HAVE_FSYNC
if compiler.has_function('fsync'):
    define_macros.append(('HAVE_FSYNC', '1'))

#undef HAVE_GC_H
# Not clear how to do these ones, but currently looks like both our
# linux and our OSX build don't set them, so assume its okay to skip
# for now.


#undef HAVE_GETCWD
if compiler.has_function('getcwd'):
    define_macros.append(('HAVE_GETCWD', '1'))

#undef HAVE_GETPAGESIZE
if compiler.has_function('getpagesize'):
    define_macros.append(('HAVE_GETPAGESIZE', '1'))

#undef HAVE_GETWD
if compiler.has_function('getwd'):
    define_macros.append(('HAVE_GETWD', '1'))

#undef HAVE_INT
#Not used, but in configure.

#undef HAVE_INT32_T
#Not used, but in configure.

#undef HAVE_INT64_T
#Only used to make-hds-types.c, which we don't do here (done in make dist of hds)

#undef HAVE_INTTYPES_H
if sysconfig.get_config_var('HAVE_INTTYPES_H')==1:
    define_macros.append(('HAVE_INTTYPES_H', '1'))

#undef HAVE_LIBGC
# Not clear how to do these ones, but currently looks like both our
# linux and our OSX build don't set them, so assume its okay to skip
# for now.

#undef HAVE_LIBPTHREAD
#Set in configure scripts but not used?

#undef HAVE_LONG
#Set in configure scripts but not used?

#undef HAVE_LONG_DOUBLE
if sysconfig.get_config_var('HAVE_LONG_DOUBLE')==1:
    define_macros.append(('HAVE_LONG_DOUBLE', '1'))

#undef HAVE_LONG_LONG
#Set in configure scripts but not used?

#undef HAVE_LONG_LONG_INT
#Set in configure scripts but not used?

#undef HAVE_LONG_LONG_INT
#Set in configure scripts but not used?

#undef HAVE_MEMMOVE
define_macros.append(('HAVE_MEMMOVE', '1'))
# Cannot get this to work test... fix would be to compile a short bit
# of code that uses it correctly?

#undef HAVE_MEMORY_H
#Set in configure scripts but not used?

#undef HAVE_MMAP
if compiler.has_function('mmap'):
    define_macros.append(('HAVE_MMAP', '1'))


#undef HAVE_OFF_T
#Set in configure scripts but not used?

#undef HAVE_ON_EXIT
if compiler.has_function('on_exit'):
    define_macros.append(('HAVE_ON_EXIT', '1'))

#undef HAVE_PERCENTLOC
#Only needed for fortran

#undef HAVE_SIGNED_CHAR
# Not sure how to test for this. Try assuming its true? (note that
# lots of the code uses unsignedchar without checking...)
define_macros.append(('HAVE_SIGNED_CHAR', '1'))


#undef HAVE_STDDEF_H

#Define to 1 if you have the <stddef.h> header file.
# Lots of things just include it without paying attention tot his
# variable, so just define it as true.
define_macros.append(('HAVE_STDDEF_H', '1'))


#undef HAVE_STDINT_H
#Only used in make-hds-types.c

#undef HAVE_STDLIB_H
#Set in configure scripts but not used?

#undef HAVE_STRERROR_R
if compiler.has_function('strerror_r'):
    define_macros.append(('HAVE_STRERROR_R', '1'))

#undef HAVE_STRINGS_H
#Set in configure scripts but not used?

#undef HAVE_STRING_H
#Set in configure scripts but not used?

#undef HAVE_STRTOK_R
if compiler.has_function('strtok_r'):
    define_macros.append(('HAVE_STRTOK_R', '1'))

#undef HAVE_SYS_PARAM_H
#Set in configure scripts but not used?

#undef HAVE_SYS_STAT_H
#Set in configure scripts but not used?

#undef HAVE_SYS_TYPES_H
#Set in configure scripts but not used?

#undef HAVE_SYS_WAIT_H
if sysconfig.get_config_var('HAVE_SYS_WAIT_H')==1:
    define_macros.append(('HAVE_SYS_WAIT_H', '1'))

#undef HAVE_TIME_H
#Only used in make-hds-types.c

#undef HAVE_UINT32_T
#Set in configure scripts but not used?

#undef HAVE_UINT64_T
#Only used in make-hds-types.c

#undef HAVE_UNISTD_H
if sysconfig.get_config_var('HAVE_UNISTD_H')==1:
    define_macros.append(('HAVE_UNISTD_H', '1'))

#undef HAVE_VFORK
#Set in configure scripts but not used?

#undef HAVE_VFORK_H
#Set in configure scripts but not used?

#undef HAVE_WORKING_FORK
#Set in configure scripts but not used?

#undef HAVE_WORKING_VFORK
#Not sure how to set this: only used in hds1.h

#undef HAVE__NSGETENVIRON
# Not clear how to do. It looks like OSX should ahve these, but I
# don't know if that is universal. Defaulting to not setting for now?
# Used in rec1_shell.c

#undef LT_OBJDIR
#Set in configure scripts but not used?

#undef STAR_INITIALISE_FORTRAN
#Only neededin fortran

#undef STDC_HEADERS
# Set in configure scripts but not used?

#undef STRERROR_R_CHAR_P
# Set in configure scripts but not used?

#undef TRAIL_TYPE
#Used in fortran, but probably needed to build -- set to int, which is what configure sets it to on linux.
define_macros.append(('TRAIL_TYPE', 'int'))

#undef USE_PTHREADS
#Build with POSIX threads support? Probably want this, but not sure best way to do check...

#undef _FILE_OFFSET_BITS
# Set in configure scripts but not used? Not set on linux anyway

#undef _LARGEFILE_SOURCE
# Set in configure scripts but not used? Not set on linux anyway

#undef _LARGE_FILES
# Set in configure scripts but not used? Not set on linux anyway

#undef _POSIX_C_SOURCE
#Doesn't look like it can change?
define_macros.append(('_POSIX_C_SOURCE', '200112L'))

#undef _REENTRANT
# should be defined probably if use_pthreads is defined?

#undef const
#Defined to empty if 'const' doesn't conform to ANSI C? Probably skip for now.

#undef pid_t
#Needs to be defined to int if it is not already defined -- leave for now?

#undef vfork
#I think this can be skipped? Nothing actually calls vfork without checking?




#Now set up the include directories?
include_dirs = []
include_dirs.append(np.get_include())
include_dirs.append(os.path.join('.', 'includefiles'))
include_dirs.append(os.path.join('.', 'starlink', 'hds'))
include_dirs += [os.path.join('.', i) for i in [starmem_path, ems_path, sae_path, cnf_path, hds_path]]

#Now set up all the source files, starting with the main modules and
#then all the .c files needed to build the libraries
sources = [os.path.join('starlink', 'hds', 'hds.c')]

sources += starmem_sources
sources += starutil_sources
sources += cnf_sources
sources += ems_sources
sources += mers_sources
sources += hds_sources

define_macros.append(('HDS_INTERNAL_INCLUDES', '1'))
define_macros.append(('SAI__OK', '0'))
define_macros.append(('ERR__SZMSG', '200'))
define_macros.append(('ERR__SZPAR', '15'))

# Now set up the Extension.


hds = Extension('starlink.hds',
                define_macros        = define_macros,
                include_dirs         = include_dirs,
                sources              = sources
                )


with open('README.rst') as file:
    long_description = file.read()

setup(name='starlink-pyhds',
      version='0.1',
      description='Python interface to the Starlink HDS library',
      long_description=long_description,
      packages=['starlink'],
      ext_modules=[hds],
      test_suite='test',

      # metadata
      author='SF Graves',
      author_email='s.graves@eaobservatory.org',
      url='https://github.com/sfgraves/starlink-pyhds',
      license="GNU GPL v3",
      classifiers=[
          'Development Status :: 4 - Beta',
          'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)',
          'Programming Language :: Python',
          'Programming Language :: C',
          'Topic :: Scientific/Engineering :: Astronomy',
          ],
      install_requires = [
          'numpy',
          ],
      )
