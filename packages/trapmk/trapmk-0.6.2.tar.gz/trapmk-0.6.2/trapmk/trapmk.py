import time
import sys
import os
import math
import glob
import collections

import dateutil.parser
from bs4 import BeautifulSoup
import jinja2
import markdown
from jinja2_markdown import MarkdownExtension

from . import __version__


MARKDOWN_EXTENSIONS = [
    'markdown.extensions.meta',
]
"""list: a list of extensions which will be used on
_TRAPMK.md files"""

PAGE_TEMPLATE_FILE_NAME = 'page.template'
"""str: ..."""

POST_TEMPLATE_FILE_NAME = 'post.template'

CATEGORY_TEMPLATE_FILE_NAME = 'category.template'

BLOG_INDEX_TEMPLATE_FILE_NAME = 'blog.template'

BLOG_POSTS_PER_INDEX = 10
"""int: affects the maximum number of posts which appear
in the category and front page indexes of the blog. This
is used for pagination.
"""

POST_FILE_NAME = '_post.md'

PAGE_FILE_NAME = '_page'
"""str: The file name used for regular jinja2 pages. Can end in
".md" to be interpreted as markdown instead of jinja2 template,
literally: _page.md."""

GENERATED_FILE_HEADER = """
<!-- FILE GENERATED BY TRAPMK -->
"""


markdown_parser = markdown.Markdown(extensions=MARKDOWN_EXTENSIONS)
jinja_env = jinja2.Environment(loader=jinja2.FileSystemLoader('.'))
jinja_env.add_extension(MarkdownExtension)
jinja_env.globals['markdowner'] = markdown_parser


class BaseTrapmkException(Exception):

    def __init__(self, format_data: dict = None):
        """Make sure to set the docstring of the exception class
        inheriting this class, for that docstring will be used
        as the exception message!

        Arguments:
            format_data: Poorly titled, this argument, if defined,
                will be passed to format the docstring (interpolate
                the values accordingly).

        """

        super().__init__(self.__doc__.format(**format_data))


class BlogPostNeedsTimestamp(BaseTrapmkException):
    """Missing `timestamp` Markdown meta!

    Offending file: {post_path}

    The Markdown blog post located above needs a `timestamp` meta
    field like this:

      title: The holidays I think are best
      timestamp: 2017-12-13

      # My favorite holidays
      I love all of the holidays!

    The timestamp is parsed by `python-dateutil`, so I think it can
    pretty much be in whatever format you want!

    """


class MissingMarkdownTitle(BaseTrapmkException):
    """Missing `title` in Markdown!

    Offending file: {offending_file_path}

    The Markdown file located above lacks `title` meta
    field like this:

      # My favorite holidays
      I love all of the holidays!

    Or an initial heading like this:

      title: The holidays I think are best

      # This title won't be used as {{ title }}
      I love all of the holidays!

    The meta field `title` is used for `{{ title }}`, otherwise
    the first heading is used as `{{ title }}`.

    """


def make_blog_indexes() -> None:
    """

    It's all done in one big loop for efficiency and because it
    seemed like a fun challenge.

    """

    category_buffer = []
    buffer_category = None
    buffer_category_path = None

    latest_post_by_category = {}
    post_pattern = os.path.join('blog', '*', '*', POST_FILE_NAME)
    for trapost_path in glob.iglob(post_pattern):
        # Extrapolate useful bits from path...
        directory_path, trapost_filename = os.path.split(trapost_path)
        category_path, post_directory = os.path.split(directory_path)
        blog_path, category_name = os.path.split(category_path)

        # Parse the _TRAPOST and writeout to index.html
        output_file_path, output, template_variables = make_page(
            trapost_path,
            md_template=POST_TEMPLATE_FILE_NAME,
            template_variables={'category': category_name},
        )
        del template_variables['content']

        if 'timestamp' not in template_variables:
            raise BlogPostNeedsTimestamp({'post_path': trapost_path})

        # NOTE: maybe just put this in make_page
        template_variables['summary'] = str(
            BeautifulSoup(output, 'html.parser').find('p'),
        )

        # If the epoch for this post is more recent than the
        # record so far for this category, set the record for
        # this category to this post! Phew! :p
        if (not category_name in latest_post_by_category
                or template_variables['epoch']
                >= latest_post_by_category[category_name]['epoch']):
            latest_post_by_category[category_name] = template_variables

        # Category index logic
        category_buffer.append(template_variables)

        # Should only occur on the first iteration...
        # if the buffer cateogry hasn't been set yet then set
        # the buffer category and path to this post's
        if not buffer_category:
            buffer_category = category_name
            buffer_category_path = category_path

        # write out the buffer of posts which belong to
        # a specific category (the `buffer_category`) if
        # this post's category is different from that of
        # the `buffer_category`.
        if buffer_category != category_name:
            last_buffer_item = category_buffer.pop()
            make_category_index(
                category_buffer,
                buffer_category,
                buffer_category_path,
            )

            # reset the buffer
            buffer_category = category_name
            buffer_category_path = category_path
            category_buffer = [last_buffer_item]

    # Remainders (since buffer is only written out when the category
    # changes in the `for` loop above).
    make_category_index(category_buffer, buffer_category, buffer_category_path)
    make_blog_index(latest_post_by_category)


def make_blog_index(latest_post_by_category: dict) -> None:
    """Show latest post from each category."""
    latest_post_by_category = sorted(
        latest_post_by_category.values(),
        key=lambda x: x['epoch'],
    )
    template_variables = {
        'posts': latest_post_by_category,
        'title': 'Latest Post in Each Category',
    }
    make_page(
        BLOG_INDEX_TEMPLATE_FILE_NAME,
        destination=os.path.join('blog', 'index.html'),
        template_variables=template_variables,
    )


def make_category_index(category_buffer: list, category_name: str,
        buffer_category_path: str) -> None:
    category_buffer = sorted(
        category_buffer,
        key=lambda x: x['epoch'],
        reverse=True,
    )
    number_of_posts = len(category_buffer)
    total_pages = math.ceil(number_of_posts / BLOG_POSTS_PER_INDEX)

    link = '<a href="/blog/{category}/{index}">Page {page_number}</a>'
    links = []
    for i in range(total_pages):
        links.append(
            link.format(
                category=category_name,
                index='index-%d.html' % (i + 1) if i else 'index.html',
                page_number=i,
            )
        )

    for i in range(total_pages):
        start_slice = i * BLOG_POSTS_PER_INDEX
        end_slice = start_slice + BLOG_POSTS_PER_INDEX

        template_variables = {
            'posts': category_buffer[start_slice:end_slice],
            'title': 'Posts in %s Category' % category_name,
        }
        if total_pages > 1:
            template_variables['pagination'] = links
        out_file_name = 'index-%d.html' % (i + 1) if i else 'index.html'
        category_index_file_path = os.path.join(
            buffer_category_path,
            out_file_name,
        )
        make_page(
            CATEGORY_TEMPLATE_FILE_NAME,
            destination=category_index_file_path,
            template_variables=template_variables,
        )


def make_page(source_file_path: str, destination: str = None,
        md_template: str = PAGE_TEMPLATE_FILE_NAME, template_variables: dict = {}) -> tuple:
    """Create an index.html based on source_file_path.

    Arguments:
        source_file_path: The source file to build.
        md_template: When source_file_path is a Markdown file,
            this path to a Jinja2 template will be used to render
            the page.
        template_variables: Will be sent to template.
        destination: where to write output

    Returns:
        ...

    """

    source_file_directory = os.path.dirname(source_file_path)
    if os.path.normpath(source_file_directory) == os.path.normpath('./_home'):
        output_file_path = 'index.html'
    else:
        output_file_path = destination or os.path.join(source_file_directory, 'index.html')
    template_variables['href'] = '/' + output_file_path

    if source_file_path.endswith('.md'):
        with open(source_file_path) as f:
            html = markdown_parser.reset().convert(f.read())
        template_variables = {
            'content': html,
            **markdown_parser.Meta,
            **template_variables,
        }
        if not 'title' in template_variables:
            # if the title wasn't defined in the markdown meta the title
            # will be the first heading/h1.
            try:
                template_variables['title'] = (
                    BeautifulSoup(html, 'html.parser').h1.string
                )
            except AttributeError:
                raise MarkdownMustHaveTitle(
                    {
                        'offending_file_path': source_file_path,
                    },
                )
        else:
            template_variables['title'] = template_variables['title'][0]

        if 'timestamp' in template_variables:
            timestamp = template_variables['timestamp'][0]
            template_variables['timestamp'] = timestamp  # flatten
            template_variables['epoch'] = int(
                dateutil.parser.parse(timestamp).strftime('%s'),
            )

        output = jinja_env.get_template(md_template).render(
            **template_variables,
        )
    else:
        output = jinja_env.get_template(source_file_path).render(**template_variables)

    # Put the generated file header at the start of the HTML & write out
    output = GENERATED_FILE_HEADER + output
    with open(output_file_path, 'w') as f:
        f.write(output)

    print(output_file_path)
    return output_file_path, output, template_variables


def build_adventure() -> None:
    make_blog_indexes()
    # This glob pattern matches any files starting with
    # "page.trapmk" so both regular "page.trapmk" files
    # and "page.trapmk.md" files are matched.
    glob_pattern = os.path.join('.', '*', PAGE_FILE_NAME + '*')
    if not list(map(make_page, glob.iglob(glob_pattern, recursive=True))):
        print("No source files matched pattern: %s" % glob_pattern)
        sys.exit(1)


def entrypoint():
    if '--version' in sys.argv:
        print("trapmk v" + __version__)
    else:
        build_adventure()
