{
	"version": 3,
	"file": "D:/activ_tosh/geatec/Numscrypt/numscrypt/development/manual_tests/numpy_eig/__javascript__/test.js",
	"sources": [
		"",
		"D:/python36_anaconda/lib/site-packages/transcrypt/modules/org/transcrypt/__javascript__/__core__.mod.js",
		"D:/python36_anaconda/lib/site-packages/transcrypt/modules/org/transcrypt/__base__.py",
		"D:/python36_anaconda/lib/site-packages/transcrypt/modules/org/transcrypt/__standard__.py",
		"D:/python36_anaconda/lib/site-packages/transcrypt/modules/org/transcrypt/__javascript__/__builtin__.mod.js",
		"D:/python36_anaconda/lib/site-packages/transcrypt/modules/cmath/__init__.py",
		"D:/python36_anaconda/lib/site-packages/transcrypt/modules/itertools/__javascript__/__init__.mod.js",
		"D:/python36_anaconda/lib/site-packages/transcrypt/modules/math/__init__.py",
		"D:/python36_anaconda/lib/site-packages/numscrypt/__init__.py",
		"D:/python36_anaconda/lib/site-packages/numscrypt/linalg/__init__.py",
		"D:/python36_anaconda/lib/site-packages/numscrypt/linalg/eigen_mpmath.py",
		"D:/activ_tosh/geatec/Numscrypt/numscrypt/development/manual_tests/numpy_eig/test.py"
	],
	"sourcesContent": [
		"__pragma__ ('padding')",
		"    var __all__ = {};\n    var __world__ = __all__;\n    \n    /* Nested module-object creator, part of the nesting may already exist and have attributes\n    \n    A Transcrypt applicaton consists of a main module and additional modules.\n    Transcrypt modules constitute a unique, unambigous tree by their dotted names, no matter which of the alternative module root paths they come from.\n    The main module is represented by a main function by the name of the application.\n    The locals of this function constitute the outer namespace of the Transcrypt application.\n    References to all local variables of this function are also assigned to attributes of local variable __all__, using the variable names as an attribute names.\n    The main function returns this local variable __all__ (that inside the function is also known by the name __world__)\n    Normally this function result is assigned to window.<application name>.\n    The function may than be exited (unless its main line starts an ongoing activity), but the application namespace stays alive tby the reference that window has to it.\n    In case of the ongoing activity including the script is enough to start it, in other cases it has to be started explicitly by calling window.<application name>.<a function>.\n    There may be multiple such entrypoint functions.\n    \n    Additional modules are represented by objects rather than functions, nested into __world__ (so into __all__ of the main function).\n    This nesting can be directly or indirectly, according to the dotted paths of the additional modules.\n    One of the methods of the module object is the __init__ function, that's executed once at module initialisation time.\n    \n    The additional modues also have an __all__ variable, an attribute rather than a local variable.\n    However this __all__ object is passed to the __init__ function, so becomes a local variable there.\n    Variables in additional modules first become locals to the __init__ function but references to all of them are assigend to __all__ under their same names.\n    This resembles the cause of affairs in the main function.\n    However __world__ only referes to the __all__ of the main module, not of any additional modules.\n    Importing a module boils down to adding all members of its __all__ to the local namespace, directly or via dotted access, depending on the way of import.\n    \n    In each local namespace of the module function (main function for main module, __init__ for additional modules) there's a variable __name__ holding the name of the module.\n    Classes are created inside the static scope of a particular module, and at that (class creation) time their variable __module__ gets assigned a reference to __name__.\n    This assignement is generated explicitly by the compiler, as the class creation function __new__ of the metaclass isn't in the static scope containing __name__.\n    \n    In case of\n        import a\n        import a.b\n    a will have been created at the moment that a.b is imported,\n    so all a.b. is allowed to do is an extra attribute in a, namely a reference to b,\n    not recreate a, since that would destroy attributes previously present in a\n    \n    In case of\n        import a.b\n        import a\n    a will have to be created at the moment that a.b is imported\n    \n    In general in a chain\n        import a.b.c.d.e\n    a, a.b, a.b.c and a.b.c.d have to exist before e is created, since a.b.c.d should hold a reference to e.\n    Since this applies recursively, if e.g. c is already created, we can be sure a and a.b. will also be already created.\n    \n    So to be able to create e, we'll have to walk the chain a.b.c.d, starting with a.\n    As soon as we encounter a module in the chain that isn't already there, we'll have to create the remainder (tail) of the chain.\n    \n    e.g.\n        import a.b.c.d.e\n        import a.b.c\n    \n    will generate\n        var modules = {};\n        __nest__ (a, 'b.c.d.e', __init__ (__world__.a.b.c.d.e));\n        __nest__ (a, 'b.c', __init__ (__world__.a.b.c));\n        \n    The task of the __nest__ function is to start at the head object and then walk to the chain of objects behind it (tail),\n    creating the ones that do not exist already, and insert the necessary module reference attributes into them.   \n    */\n    \n    var __nest__ = function (headObject, tailNames, value) {    \n        var current = headObject;\n        // In some cases this will be <main function>.__all__,\n        // which is the main module and is also known under the synonym <main function.__world__.\n        // N.B. <main function> is the entry point of a Transcrypt application,\n        // Carrying the same name as the application except the file name extension.\n        \n        if (tailNames != '') {  // Split on empty string doesn't give empty list\n            // Find the last already created object in tailNames\n            var tailChain = tailNames.split ('.');\n            var firstNewIndex = tailChain.length;\n            for (var index = 0; index < tailChain.length; index++) {\n                if (!current.hasOwnProperty (tailChain [index])) {\n                    firstNewIndex = index;\n                    break;\n                }\n                current = current [tailChain [index]];\n            }\n            \n            // Create the rest of the objects, if any\n            for (var index = firstNewIndex; index < tailChain.length; index++) {\n                current [tailChain [index]] = {};\n                current = current [tailChain [index]];\n            }\n        }\n        \n        // Insert it new attributes, it may have been created earlier and have other attributes\n        for (var attrib in value) {\n            current [attrib] = value [attrib];          \n        }       \n    };\n    __all__.__nest__ = __nest__;\n    \n    // Initialize module if not yet done and return its globals\n    var __init__ = function (module) {\n        if (!module.__inited__) {\n            module.__all__.__init__ (module.__all__);\n            module.__inited__ = true;\n        }\n        return module.__all__;\n    };\n    __all__.__init__ = __init__;\n    \n    \n__pragma__ ('ifdef', '__esv6__')\n    // Proxy switch, controlled by __pragma__ ('proxy') and __pragma ('noproxy')\n    var __proxy__ = false;  // No use assigning it to __all__, only its transient state is important\n__pragma__ ('endif')\n    \n    \n    // Since we want to assign functions, a = b.f should make b.f produce a bound function\n    // So __get__ should be called by a property rather then a function\n    // Factory __get__ creates one of three curried functions for func\n    // Which one is produced depends on what's to the left of the dot of the corresponding JavaScript property\n    var __get__ = function (self, func, quotedFuncName) {\n        if (self) {\n            if (self.hasOwnProperty ('__class__') || typeof self == 'string' || self instanceof String) {           // Object before the dot\n                if (quotedFuncName) {                                   // Memoize call since fcall is on, by installing bound function in instance\n                    Object.defineProperty (self, quotedFuncName, {      // Will override the non-own property, next time it will be called directly\n                        value: function () {                            // So next time just call curry function that calls function\n                            var args = [] .slice.apply (arguments);\n                            return func.apply (null, [self] .concat (args));\n                        },              \n                        writable: true,\n                        enumerable: true,\n                        configurable: true\n                    });\n                }\n                return function () {                                    // Return bound function, code dupplication for efficiency if no memoizing\n                    var args = [] .slice.apply (arguments);             // So multilayer search prototype, apply __get__, call curry func that calls func\n                    return func.apply (null, [self] .concat (args));\n                };\n            }\n            else {                                                      // Class before the dot\n                return func;                                            // Return static method\n            }\n        }\n        else {                                                          // Nothing before the dot\n            return func;                                                // Return free function\n        }\n    }\n    __all__.__get__ = __get__;\n\n    var __getcm__ = function (self, func, quotedFuncName) {\n        if (self.hasOwnProperty ('__class__')) {\n            return function () {\n                var args = [] .slice.apply (arguments);\n                return func.apply (null, [self.__class__] .concat (args));\n            };\n        }\n        else {\n            return function () {\n                var args = [] .slice.apply (arguments);\n                return func.apply (null, [self] .concat (args));\n            };\n        }\n    }\n    __all__.__getcm__ = __getcm__;\n    \n    var __getsm__ = function (self, func, quotedFuncName) {\n        return func;\n    }\n    __all__.__getsm__ = __getsm__;\n        \n    // Mother of all metaclasses        \n    var py_metatype = {\n        __name__: 'type',\n        __bases__: [],\n        \n        // Overridable class creation worker\n        __new__: function (meta, name, bases, attribs) {\n            // Create the class cls, a functor, which the class creator function will return\n            var cls = function () {                     // If cls is called with arg0, arg1, etc, it calls its __new__ method with [arg0, arg1, etc]\n                var args = [] .slice.apply (arguments); // It has a __new__ method, not yet but at call time, since it is copied from the parent in the loop below\n                return cls.__new__ (args);              // Each Python class directly or indirectly derives from object, which has the __new__ method\n            };                                          // If there are no bases in the Python source, the compiler generates [object] for this parameter\n            \n            // Copy all methods, including __new__, properties and static attributes from base classes to new cls object\n            // The new class object will simply be the prototype of its instances\n            // JavaScript prototypical single inheritance will do here, since any object has only one class\n            // This has nothing to do with Python multiple inheritance, that is implemented explictly in the copy loop below\n            for (var index = bases.length - 1; index >= 0; index--) {   // Reversed order, since class vars of first base should win\n                var base = bases [index];\n                for (var attrib in base) {\n                    var descrip = Object.getOwnPropertyDescriptor (base, attrib);\n                    Object.defineProperty (cls, attrib, descrip);\n                }           \n__pragma__ ('ifdef', '__esv6__')\n\n                for (var symbol of Object.getOwnPropertySymbols (base)) {\n                    var descrip = Object.getOwnPropertyDescriptor (base, symbol);\n                    Object.defineProperty (cls, symbol, descrip);\n                }\n                \n__pragma__ ('endif')\n            }\n            \n            // Add class specific attributes to the created cls object\n            cls.__metaclass__ = meta;\n            cls.__name__ = name.startsWith ('py_') ? name.slice (3) : name;\n            cls.__bases__ = bases;\n            \n            // Add own methods, properties and own static attributes to the created cls object\n            for (var attrib in attribs) {\n                var descrip = Object.getOwnPropertyDescriptor (attribs, attrib);\n                Object.defineProperty (cls, attrib, descrip);\n            }\n__pragma__ ('ifdef', '__esv6__')\n\n            for (var symbol of Object.getOwnPropertySymbols (attribs)) {\n                var descrip = Object.getOwnPropertyDescriptor (attribs, symbol);\n                Object.defineProperty (cls, symbol, descrip);\n            }\n            \n__pragma__ ('endif')\n            // Return created cls object\n            return cls;\n        }\n    };\n    py_metatype.__metaclass__ = py_metatype;\n    __all__.py_metatype = py_metatype;\n    \n    // Mother of all classes\n    var object = {\n        __init__: function (self) {},\n        \n        __metaclass__: py_metatype, // By default, all classes have metaclass type, since they derive from object\n        __name__: 'object',\n        __bases__: [],\n            \n        // Object creator function, is inherited by all classes (so could be global)\n        __new__: function (args) {  // Args are just the constructor args       \n            // In JavaScript the Python class is the prototype of the Python object\n            // In this way methods and static attributes will be available both with a class and an object before the dot\n            // The descriptor produced by __get__ will return the right method flavor\n            var instance = Object.create (this, {__class__: {value: this, enumerable: true}});\n            \n__pragma__ ('ifdef', '__esv6__')\n            if ('__getattr__' in this || '__setattr__' in this) {\n                instance = new Proxy (instance, {\n                    get: function (target, name) {\n                        var result = target [name];\n                        if (result == undefined) {  // Target doesn't have attribute named name\n                            return target.__getattr__ (name);\n                        }\n                        else {\n                            return result;\n                        }\n                    },\n                    set: function (target, name, value) {\n                        try {\n                            target.__setattr__ (name, value);\n                        }\n                        catch (exception) {         // Target doesn't have a __setattr__ method\n                            target [name] = value;\n                        }\n                        return true;\n                    }\n                })\n            }\n__pragma__ ('endif')\n\n            // Call constructor\n            this.__init__.apply (null, [instance] .concat (args));\n\n            // Return constructed instance\n            return instance;\n        }   \n    };\n    __all__.object = object;\n    \n    // Class creator facade function, calls class creation worker\n    var __class__ = function (name, bases, attribs, meta) {         // Parameter meta is optional\n        if (meta == undefined) {\n            meta = bases [0] .__metaclass__;\n        }\n                \n        return meta.__new__ (meta, name, bases, attribs);\n    }\n    __all__.__class__ = __class__;\n    \n    // Define __pragma__ to preserve '<all>' and '</all>', since it's never generated as a function, must be done early, so here\n    var __pragma__ = function () {};\n    __all__.__pragma__ = __pragma__;\n    \n    ",
		"# This module is avaible both in the Python and Transcrypt environments\n# It is included in-between the __core__ and the __builtin__ module, so the latter can adapt __envir__\n# In Transcrypt, __base__ is available inline, it isn't nested and cannot be imported in the normal way\n\nclass __Envir__:\n    def __init__ (self):\n        self.interpreter_name = 'python'\n        self.transpiler_name = 'transcrypt'\n        self.transpiler_version = '3.6.82'\n        self.target_subdir = '__javascript__'\n        \n__envir__ = __Envir__ ()",
		"# This module is avaible solely in the Transcrypt environment\n# It is included after the __builtin__ module, since it uses its facilities\n# In Transcrypt, __standard__ is available inline, it isn't nested and cannot be imported in the normal way\n\n__pragma__ ('skip')\ncopy = Math = __typeof__ = __repr__ = document = console = window = 0\n__pragma__ ('noskip')\n\n__pragma__ ('notconv')  # !!! tconv gives a problem with __terminal__, needs investigation\n__pragma__ ('nokwargs')\n__pragma__ ('noalias', 'sort')\n\nclass Exception:\n    __pragma__ ('kwargs')\n    def __init__ (self, *args, **kwargs):\n        self.__args__ = args\n        try:\n            self.stack = kwargs.error.stack # Integrate with JavaScript Error object\n        except:\n            self.stack = 'No stack trace available'\n    __pragma__ ('nokwargs')\n        \n    def __repr__ (self):\n        if len (self.__args__):\n            return '{}{}'.format (self.__class__.__name__, repr (tuple (self.__args__)))\n        else:\n            return '{}()'.format (self.__class__.__name__)\n            \n    def __str__ (self):\n        if len (self.__args__) > 1:\n            return str (tuple (self.__args__))\n        elif len (self.__args__):\n            return str (self.__args__ [0])\n        else:\n            return ''\n        \nclass IterableError (Exception):\n    def __init__ (self, error):\n        Exception.__init__ (self, 'Can\\'t iterate over non-iterable', error = error)\n            \nclass StopIteration (Exception):\n    def __init__ (self, error):\n        Exception.__init__ (self, 'Iterator exhausted', error = error)\n        \nclass ValueError (Exception):\n    def __init__ (self, message, error):\n        Exception.__init__ (self, message, error = error)\n    \nclass KeyError (Exception):\n    def __init__ (self, message, error):\n        Exception.__init__ (self, message, error = error)\n    \nclass AssertionError (Exception):\n    def __init__ (self, message, error):\n        if message:\n            Exception.__init__ (self, message, error = error)\n        else:\n            Exception.__init__ (self, error = error)\n\nclass NotImplementedError (Exception):\n    def __init__(self, message, error):\n        Exception.__init__(self, message, error = error)\n\nclass IndexError (Exception):\n    def __init__(self, message, error):\n        Exception.__init__(self, message, error = error)\n\nclass AttributeError (Exception):\n    def __init__(self, message, error):\n        Exception.__init__(self, message, error = error)\n\nclass TypeError (Exception):\n    def __init__(self, message, error):\n        Exception.__init__(self, message, error = error)\n\n# Warnings Exceptions\n# N.B. This is a limited subset of the warnings defined in\n# the cpython implementation to keep things small for now.\n\nclass Warning (Exception):\n    ''' Warning Base Class\n    '''\n    pass\n\nclass UserWarning (Warning):\n    pass\n\nclass DeprecationWarning (Warning):\n    pass\n\nclass RuntimeWarning (Warning):\n    pass\n\n__pragma__ ('kwargs')\n\ndef __sort__ (iterable, key = None, reverse = False):               # Used by py_sort, can deal with kwargs\n    if key:\n        iterable.sort (lambda a, b: 1 if key (a) > key (b) else -1) # JavaScript sort, case '==' is irrelevant for sorting\n    else:\n        iterable.sort ()                                            # JavaScript sort\n        \n    if reverse:\n        iterable.reverse ()\n        \ndef sorted (iterable, key = None, reverse = False):\n    if type (iterable) == dict:\n        result = copy (iterable.keys ()) \n    else:       \n        result = copy (iterable)\n        \n    __sort__ (result, key, reverse)\n    return result\n\n__pragma__ ('nokwargs')\n\ndef map (func, iterable):\n    return [func (item) for item in iterable]\n\n\ndef filter (func, iterable):\n    if func == None:\n        func = bool\n    return [item for item in iterable if func (item)]\n    \n__pragma__ ('ifdef', '__complex__')\n\nclass complex:\n    def __init__ (self, real, imag = None):\n        if imag == None:\n            if type (real) == complex:\n                self.real = real.real\n                self.imag = real.imag\n            else:\n                self.real = real\n                self.imag = 0\n        else:\n            self.real = real\n            self.imag = imag\n            \n    def __neg__ (self):\n        return complex (-self.real, -self.imag)\n        \n    def __exp__ (self):\n        modulus = Math.exp (self.real)\n        return complex (modulus * Math.cos (self.imag), modulus * Math.sin (self.imag))\n    \n    def __log__ (self):\n        return complex (Math.log (Math.sqrt (self.real * self.real + self.imag * self.imag)), Math.atan2 (self.imag, self.real))\n        \n    def __pow__ (self, other):  # a ** b = exp (b log a)\n        return (self.__log__ () .__mul__ (other)) .__exp__ ()\n        \n    def __rpow__ (self, real):  # real ** comp -> comp.__rpow__ (real)\n        return self.__mul__ (Math.log (real)) .__exp__ ()\n        \n    def __mul__ (self, other):\n        if __typeof__ (other) is 'number':\n            return complex (self.real * other, self.imag * other)\n        else:\n            return complex (self.real * other.real - self.imag * other.imag, self.real * other.imag + self.imag * other.real)\n        \n    def __rmul__ (self, real):  # real + comp -> comp.__rmul__ (real)\n        return complex (self.real * real, self.imag * real)\n        \n    def __div__ (self, other):\n        if __typeof__ (other) is 'number':\n            return complex (self.real / other, self.imag / other)\n        else:\n            denom = other.real * other.real + other.imag * other.imag\n            return complex (\n                (self.real * other.real + self.imag * other.imag) / denom,\n                (self.imag * other.real - self.real * other.imag) / denom\n            )\n        \n    def __rdiv__ (self, real):  # real / comp -> comp.__rdiv__ (real)\n        denom = self.real * self.real\n        return complex (\n            (real * self.real) / denom,\n            (real * self.imag) / denom\n        )\n        \n    def __add__ (self, other):\n        if __typeof__ (other) is 'number':\n            return complex (self.real + other, self.imag)\n        else:   # Assume other is complex\n            return complex (self.real + other.real, self.imag + other.imag)\n        \n    def __radd__ (self, real):  # real + comp -> comp.__radd__ (real)\n        return complex (self.real + real, self.imag)\n        \n    def __sub__ (self, other):\n        if __typeof__ (other) is 'number':\n            return complex (self.real - other, self.imag)\n        else:\n            return complex (self.real - other.real, self.imag - other.imag)\n        \n    def __rsub__ (self, real):  # real - comp -> comp.__rsub__ (real)\n        return complex (real - self.real, -self.imag)\n        \n    def __repr__ (self):\n        return '({}{}{}j)'.format (self.real, '+' if self.imag >= 0 else '', self.imag)\n            \n    def __str__ (self):\n        return __repr__ (self) [1 : -1]\n        \n    def __eq__ (self, other):\n        if __typeof__ (other) is 'number':\n            return self.real == other\n        else:\n            return self.real == other.real and self.imag == other.imag\n        \n    def __ne__ (self, other):\n        if __typeof__ (other) is 'number':\n            return self.real != other\n        else:\n            return self.real != other.real or self.imag != other.imag\n        \n    def conjugate (self):\n        return complex (self.real, -self.imag)\n        \ndef __conj__ (aNumber):\n    if isinstance (aNumber, complex):\n        return complex (aNumber.real, -aNumber.imag)\n    else:\n        return complex (aNumber, 0)\n        \n__pragma__ ('endif')\n\nclass __Terminal__:\n    '''\n    Printing to either the console or to html happens async, but is blocked by calling window.prompt.\n    So while all input and print statements are encountered in normal order, the print's exit immediately without yet having actually printed\n    This means the next input takes control, blocking actual printing and so on indefinitely\n    The effect is that everything's only printed after all inputs are done\n    To prevent that, what's needed is to only execute the next window.prompt after actual printing has been done\n    Since we've no way to find out when that is, a timeout is used.\n    '''\n\n    def __init__ (self):\n        self.buffer = ''\n    \n        try:\n            self.element = document.getElementById ('__terminal__')\n        except:\n            self.element = None\n            \n        if self.element:\n            self.element.style.overflowX = 'auto'\n            self.element.style.boxSizing = 'border-box'\n            self.element.style.padding = '5px'\n            self.element.innerHTML = '_'\n        \n    __pragma__ ('kwargs')\n        \n    def print (self, *args, sep = ' ', end = '\\n'):\n        self.buffer = '{}{}{}'.format (self.buffer, sep.join ([str (arg) for arg in args]), end) [-4096 : ] \n        \n        if self.element:\n            self.element.innerHTML = self.buffer.replace ('\\n', '<br>') .replace (' ', '&nbsp')\n            self.element.scrollTop = self.element.scrollHeight\n        else:\n            console.log (sep.join ([str (arg) for arg in args]))\n        \n    def input (self, question):\n        self.print ('{}'.format (question), end = '')\n        answer = window.prompt ('\\n'.join (self.buffer.split ('\\n') [-16:]))\n        self.print (answer)\n        return answer\n        \n    __pragma__ ('nokwargs')\n    \n__terminal__ = __Terminal__ ()\n",
		"    var __call__ = function (/* <callee>, <this>, <params>* */) {   // Needed for __base__ and __standard__ if global 'opov' switch is on\n        var args = [] .slice.apply (arguments);\n        if (typeof args [0] == 'object' && '__call__' in args [0]) {        // Overloaded\n            return args [0] .__call__ .apply (args [1], args.slice (2));\n        }\n        else {                                                              // Native\n            return args [0] .apply (args [1], args.slice (2));\n        }\n    };\n    __all__.__call__ = __call__;\n\n    // Initialize non-nested modules __base__ and __standard__ and make its names available directly and via __all__\n    // They can't do that itself, because they're regular Python modules\n    // The compiler recognizes their names and generates them inline rather than nesting them\n    // In this way it isn't needed to import them everywhere\n\n    // __base__\n\n    __nest__ (__all__, '', __init__ (__all__.org.transcrypt.__base__));\n    var __envir__ = __all__.__envir__;\n\n    // __standard__\n\n    __nest__ (__all__, '', __init__ (__all__.org.transcrypt.__standard__));\n\n    var Exception = __all__.Exception;\n    var IterableError = __all__.IterableError;\n    var StopIteration = __all__.StopIteration;\n    var ValueError = __all__.ValueError;\n    var KeyError = __all__.KeyError;\n    var AssertionError = __all__.AssertionError;\n    var NotImplementedError = __all__.NotImplementedError;\n    var IndexError = __all__.IndexError;\n    var AttributeError = __all__.AttributeError;\n    var py_TypeError = __all__.py_TypeError;\n\n    // Warnings Exceptions\n    var Warning = __all__.Warning;\n    var UserWarning = __all__.UserWarning;\n    var DeprecationWarning = __all__.DeprecationWarning;\n    var RuntimeWarning = __all__.RuntimeWarning;\n\n    var __sort__ = __all__.__sort__;\n    var sorted = __all__.sorted;\n\n    var map = __all__.map;\n    var filter = __all__.filter;\n\n__pragma__ ('ifdef', '__complex__')\n    var complex = __all__.complex;\n    var __conj__ = __all__.__conj__;\n__pragma__ ('endif')\n\n    __all__.print = __all__.__terminal__.print;\n    __all__.input = __all__.__terminal__.input;\n\n    var __terminal__ = __all__.__terminal__;\n    var print = __all__.print;\n    var input = __all__.input;\n\n    // Complete __envir__, that was created in __base__, for non-stub mode\n    __envir__.executor_name = __envir__.transpiler_name;\n\n    // Make make __main__ available in browser\n    var __main__ = {__file__: ''};\n    __all__.main = __main__;\n\n    // Define current exception, there's at most one exception in the air at any time\n    var __except__ = null;\n    __all__.__except__ = __except__;\n    \n     // Creator of a marked dictionary, used to pass **kwargs parameter\n    var __kwargtrans__ = function (anObject) {\n        anObject.__kwargtrans__ = null; // Removable marker\n        anObject.constructor = Object;\n        return anObject;\n    }\n    __all__.__kwargtrans__ = __kwargtrans__;\n\n    // 'Oneshot' dict promotor, used to enrich __all__ and help globals () return a true dict\n    var __globals__ = function (anObject) {\n        if (isinstance (anObject, dict)) {  // Don't attempt to promote (enrich) again, since it will make a copy\n            return anObject;\n        }\n        else {\n            return dict (anObject)\n        }\n    }\n    __all__.__globals__ = __globals__\n    \n    // Partial implementation of super () .<methodName> (<params>)\n    var __super__ = function (aClass, methodName) {\n        // Lean and fast, no C3 linearization, only call first implementation encountered\n        // Will allow __super__ ('<methodName>') (self, <params>) rather than only <className>.<methodName> (self, <params>)\n        \n__pragma__ ('ifdef', '__esv6__')\n        for (let base of aClass.__bases__) {\n__pragma__ ('else')\n        for (var index = 0; index < aClass.__bases__.length; index++) {\n            var base = aClass.__bases__ [index];\n__pragma__ ('endif')\n            if (methodName in base) {\n               return base [methodName];\n            }\n        }\n\n        throw new Exception ('Superclass method not found');    // !!! Improve!\n    }\n    __all__.__super__ = __super__\n        \n    // Python property installer function, no member since that would bloat classes\n    var property = function (getter, setter) {  // Returns a property descriptor rather than a property\n        if (!setter) {  // ??? Make setter optional instead of dummy?\n            setter = function () {};\n        }\n        return {get: function () {return getter (this)}, set: function (value) {setter (this, value)}, enumerable: true};\n    }\n    __all__.property = property;\n    \n    // Conditional JavaScript property installer function, prevents redefinition of properties if multiple Transcrypt apps are on one page\n    var __setProperty__ = function (anObject, name, descriptor) {\n        if (!anObject.hasOwnProperty (name)) {\n            Object.defineProperty (anObject, name, descriptor);\n        }\n    }\n    __all__.__setProperty__ = __setProperty__\n    \n    // Assert function, call to it only generated when compiling with --dassert option\n    function assert (condition, message) {  // Message may be undefined\n        if (!condition) {\n            throw AssertionError (message, new Error ());\n        }\n    }\n\n    __all__.assert = assert;\n\n    var __merge__ = function (object0, object1) {\n        var result = {};\n        for (var attrib in object0) {\n            result [attrib] = object0 [attrib];\n        }\n        for (var attrib in object1) {\n            result [attrib] = object1 [attrib];\n        }\n        return result;\n    };\n    __all__.__merge__ = __merge__;\n\n    // Manipulating attributes by name\n    \n    var dir = function (obj) {\n        var aList = [];\n        for (var aKey in obj) {\n            aList.push (aKey.startsWith ('py_') ? aKey.slice (3) : aKey);\n        }\n        aList.sort ();\n        return aList;\n    };\n    __all__.dir = dir;\n\n    var setattr = function (obj, name, value) {\n        obj [name] = value; // Will not work in combination with static retrieval of aliased attributes, too expensive\n    };\n    __all__.setattr = setattr;\n\n    var getattr = function (obj, name) {\n        return name in obj ? obj [name] : obj ['py_' + name];\n    };\n    __all__.getattr= getattr;\n\n    var hasattr = function (obj, name) {\n        try {\n            return name in obj || 'py_' + name in obj;\n        }\n        catch (exception) {\n            return false;\n        }\n    };\n    __all__.hasattr = hasattr;\n\n    var delattr = function (obj, name) {\n        if (name in obj) {\n            delete obj [name];\n        }\n        else {\n            delete obj ['py_' + name];\n        }\n    };\n    __all__.delattr = (delattr);\n\n    // The __in__ function, used to mimic Python's 'in' operator\n    // In addition to CPython's semantics, the 'in' operator is also allowed to work on objects, avoiding a counterintuitive separation between Python dicts and JavaScript objects\n    // In general many Transcrypt compound types feature a deliberate blend of Python and JavaScript facilities, facilitating efficient integration with JavaScript libraries\n    // If only Python objects and Python dicts are dealt with in a certain context, the more pythonic 'hasattr' is preferred for the objects as opposed to 'in' for the dicts\n    var __in__ = function (element, container) {\n        if (py_typeof (container) == dict) {        // Currently only implemented as an augmented JavaScript object\n            return container.hasOwnProperty (element);\n        }\n        else {                                      // Parameter 'element' itself is an array, string or a plain, non-dict JavaScript object\n            return (\n                container.indexOf ?                 // If it has an indexOf\n                container.indexOf (element) > -1 :  // it's an array or a string,\n                container.hasOwnProperty (element)  // else it's a plain, non-dict JavaScript object\n            );\n        }\n    };\n    __all__.__in__ = __in__;\n\n    // Find out if an attribute is special\n    var __specialattrib__ = function (attrib) {\n        return (attrib.startswith ('__') && attrib.endswith ('__')) || attrib == 'constructor' || attrib.startswith ('py_');\n    };\n    __all__.__specialattrib__ = __specialattrib__;\n\n    // Compute length of any object\n    var len = function (anObject) {\n        if (anObject === undefined || anObject === null) {\n            return 0;\n        }\n\n        if (anObject.__len__ instanceof Function) {\n            return anObject.__len__ ();\n        }\n\n        if (anObject.length !== undefined) {\n            return anObject.length;\n        }\n\n        var length = 0;\n        for (var attr in anObject) {\n            if (!__specialattrib__ (attr)) {\n                length++;\n            }\n        }\n\n        return length;\n    };\n    __all__.len = len;\n\n    // General conversions and checks\n\n    function __i__ (any) {  //  Convert to iterable\n        return py_typeof (any) == dict ? any.py_keys () : any;\n    }\n\n    function __k__ (keyed, key) {  //  Check existence of dict key via retrieved element\n        var result = keyed [key];\n        if (typeof result == 'undefined') {\n             throw KeyError (key, new Error());\n        }\n        return result;\n    }\n\n    // If the target object is somewhat true, return it. Otherwise return false.\n    // Try to follow Python conventions of truthyness\n    function __t__ (target) { \n        return (\n            // Avoid invalid checks\n            target === undefined || target === null ? false :\n            \n            // Take a quick shortcut if target is a simple type\n            ['boolean', 'number'] .indexOf (typeof target) >= 0 ? target :\n            \n            // Use __bool__ (if present) to decide if target is true\n            target.__bool__ instanceof Function ? (target.__bool__ () ? target : false) :\n            \n            // There is no __bool__, use __len__ (if present) instead\n            target.__len__ instanceof Function ?  (target.__len__ () !== 0 ? target : false) :\n            \n            // There is no __bool__ and no __len__, declare Functions true.\n            // Python objects are transpiled into instances of Function and if\n            // there is no __bool__ or __len__, the object in Python is true.\n            target instanceof Function ? target :\n            \n            // Target is something else, compute its len to decide\n            len (target) !== 0 ? target :\n            \n            // When all else fails, declare target as false\n            false\n        );\n    }\n    __all__.__t__ = __t__;\n\n    var bool = function (any) {     // Always truly returns a bool, rather than something truthy or falsy\n        return !!__t__ (any);\n    };\n    bool.__name__ = 'bool';         // So it can be used as a type with a name\n    __all__.bool = bool;\n\n    var float = function (any) {\n        if (any == 'inf') {\n            return Infinity;\n        }\n        else if (any == '-inf') {\n            return -Infinity;\n        }\n        else if (isNaN (parseFloat (any))) {    // Call to parseFloat needed to exclude '', ' ' etc.\n            if (any === false) {\n                return 0;\n            }\n            else if (any === true) {\n                return 1;\n            }\n            else {  // Needed e.g. in autoTester.check, so \"return any ? true : false\" won't do\n                throw ValueError (\"could not convert string to float: '\" + str(any) + \"'\", new Error ());\n            }\n        }\n        else {\n            return +any;\n        }\n    };\n    float.__name__ = 'float';\n    __all__.float = float;\n\n    var int = function (any) {\n        return float (any) | 0\n    };\n    int.__name__ = 'int';\n    __all__.int = int;\n\n    var py_typeof = function (anObject) {\n        var aType = typeof anObject;\n        if (aType == 'object') {    // Directly trying '__class__ in anObject' turns out to wreck anObject in Chrome if its a primitive\n            try {\n                return anObject.__class__;\n            }\n            catch (exception) {\n                return aType;\n            }\n        }\n        else {\n            return (    // Odly, the braces are required here\n                aType == 'boolean' ? bool :\n                aType == 'string' ? str :\n                aType == 'number' ? (anObject % 1 == 0 ? int : float) :\n                null\n            );\n        }\n    };\n    __all__.py_typeof = py_typeof;\n\n    var isinstance = function (anObject, classinfo) {\n        function isA (queryClass) {\n            if (queryClass == classinfo) {\n                return true;\n            }\n            for (var index = 0; index < queryClass.__bases__.length; index++) {\n                if (isA (queryClass.__bases__ [index], classinfo)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        if (classinfo instanceof Array) {   // Assume in most cases it isn't, then making it recursive rather than two functions saves a call\n__pragma__ ('ifdef', '__esv6__')\n            for (let aClass of classinfo) {\n__pragma__ ('else')\n            for (var index = 0; index < classinfo.length; index++) {\n                var aClass = classinfo [index];\n__pragma__ ('endif')\n                if (isinstance (anObject, aClass)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        try {                   // Most frequent use case first\n            return '__class__' in anObject ? isA (anObject.__class__) : anObject instanceof classinfo;\n        }\n        catch (exception) {     // Using isinstance on primitives assumed rare\n            var aType = py_typeof (anObject);\n            return aType == classinfo || (aType == bool && classinfo == int);\n        }\n    };\n    __all__.isinstance = isinstance;\n\n    var callable = function (anObject) {\n        if ( typeof anObject == 'object' && '__call__' in anObject ) {\n            return true;\n        }\n        else {\n            return typeof anObject === 'function';\n        }\n    };\n    __all__.callable = callable;\n\n    // Repr function uses __repr__ method, then __str__, then toString\n    var repr = function (anObject) {\n        try {\n            return anObject.__repr__ ();\n        }\n        catch (exception) {\n            try {\n                return anObject.__str__ ();\n            }\n            catch (exception) { // anObject has no __repr__ and no __str__\n                try {\n                    if (anObject == null) {\n                        return 'None';\n                    }\n                    else if (anObject.constructor == Object) {\n                        var result = '{';\n                        var comma = false;\n                        for (var attrib in anObject) {\n                            if (!__specialattrib__ (attrib)) {\n                                if (attrib.isnumeric ()) {\n                                    var attribRepr = attrib;                // If key can be interpreted as numerical, we make it numerical\n                                }                                           // So we accept that '1' is misrepresented as 1\n                                else {\n                                    var attribRepr = '\\'' + attrib + '\\'';  // Alpha key in dict\n                                }\n\n                                if (comma) {\n                                    result += ', ';\n                                }\n                                else {\n                                    comma = true;\n                                }\n                                result += attribRepr + ': ' + repr (anObject [attrib]);\n                            }\n                        }\n                        result += '}';\n                        return result;\n                    }\n                    else {\n                        return typeof anObject == 'boolean' ? anObject.toString () .capitalize () : anObject.toString ();\n                    }\n                }\n                catch (exception) {\n                    return '<object of type: ' + typeof anObject + '>';\n                }\n            }\n        }\n    };\n    __all__.repr = repr;\n\n    // Char from Unicode or ASCII\n    var chr = function (charCode) {\n        return String.fromCharCode (charCode);\n    };\n    __all__.chr = chr;\n\n    // Unicode or ASCII from char\n    var ord = function (aChar) {\n        return aChar.charCodeAt (0);\n    };\n    __all__.ord = ord;\n\n    // Maximum of n numbers\n    var max = function (nrOrSeq) {\n__pragma__ ('ifdef', '__esv6__')\n        return arguments.length == 1 ? Math.max (...nrOrSeq) : Math.max (...arguments);       \n__pragma__ ('else')\n        return arguments.length == 1 ? Math.max.apply (null, nrOrSeq) : Math.max.apply (null, arguments);       \n__pragma__ ('endif')\n    };\n    __all__.max = max;\n\n    // Minimum of n numbers\n    var min = function (nrOrSeq) {\n__pragma__ ('ifdef', '__esv6__')\n        return arguments.length == 1 ? Math.min (...nrOrSeq) : Math.min (...arguments);       \n__pragma__ ('else')\n        return arguments.length == 1 ? Math.min.apply (null, nrOrSeq) : Math.min.apply (null, arguments);       \n__pragma__ ('endif')\n    };\n    __all__.min = min;\n\n    // Absolute value\n__pragma__ ('ifdef', '__complex__')\n    var abs = function (x) {\n        try {\n            return Math.abs (x);\n        }\n        catch (exception) {\n            return Math.sqrt (x.real * x.real + x.imag * x.imag);\n        }\n    };\n__pragma__ ('else')\n    var abs = Math.abs;\n    __all__.abs = abs;\n__pragma__ ('endif')\n\n    // Bankers rounding\n    var round = function (number, ndigits) {\n        if (ndigits) {\n            var scale = Math.pow (10, ndigits);\n            number *= scale;\n        }\n\n        var rounded = Math.round (number);\n        if (rounded - number == 0.5 && rounded % 2) {   // Has rounded up to odd, should have rounded down to even\n            rounded -= 1;\n        }\n\n        if (ndigits) {\n            rounded /= scale;\n        }\n\n        return rounded;\n    };\n    __all__.round = round;\n\n    // BEGIN unified iterator model\n\n    function __jsUsePyNext__ () {       // Add as 'next' method to make Python iterator JavaScript compatible\n        try {\n            var result = this.__next__ ();\n            return {value: result, done: false};\n        }\n        catch (exception) {\n            return {value: undefined, done: true};\n        }\n    }\n\n    function __pyUseJsNext__ () {       // Add as '__next__' method to make JavaScript iterator Python compatible\n        var result = this.next ();\n        if (result.done) {\n            throw StopIteration (new Error ());\n        }\n        else {\n            return result.value;\n        }\n    }\n\n    function py_iter (iterable) {                   // Alias for Python's iter function, produces a universal iterator / iterable, usable in Python and JavaScript\n        if (typeof iterable == 'string' || '__iter__' in iterable) {    // JavaScript Array or string or Python iterable (string has no 'in')\n            var result = iterable.__iter__ ();                          // Iterator has a __next__\n            result.next = __jsUsePyNext__;                              // Give it a next\n        }\n        else if ('selector' in iterable) {                              // Assume it's a JQuery iterator\n            var result = list (iterable) .__iter__ ();                  // Has a __next__\n            result.next = __jsUsePyNext__;                              // Give it a next\n        }\n        else if ('next' in iterable) {                                  // It's a JavaScript iterator already,  maybe a generator, has a next and may have a __next__\n            var result = iterable\n            if (! ('__next__' in result)) {                             // If there's no danger of recursion\n                result.__next__ = __pyUseJsNext__;                      // Give it a __next__\n            }\n        }\n        else if (Symbol.iterator in iterable) {                         // It's a JavaScript iterable such as a typed array, but not an iterator\n            var result = iterable [Symbol.iterator] ();                 // Has a next\n            result.__next__ = __pyUseJsNext__;                          // Give it a __next__\n        }\n        else {\n            throw IterableError (new Error ()); // No iterator at all\n        }\n        result [Symbol.iterator] = function () {return result;};\n        return result;\n    }\n\n    function py_next (iterator) {               // Called only in a Python context, could receive Python or JavaScript iterator\n        try {                                   // Primarily assume Python iterator, for max speed\n            var result = iterator.__next__ ();\n        }\n        catch (exception) {                     // JavaScript iterators are the exception here\n            var result = iterator.next ();\n            if (result.done) {\n                throw StopIteration (new Error ());\n            }\n            else {\n                return result.value;\n            }\n        }\n        if (result == undefined) {\n            throw StopIteration (new Error ());\n        }\n        else {\n            return result;\n        }\n    }\n\n    function __PyIterator__ (iterable) {\n        this.iterable = iterable;\n        this.index = 0;\n    }\n\n    __PyIterator__.prototype.__next__ = function () {\n        if (this.index < this.iterable.length) {\n            return this.iterable [this.index++];\n        }\n        else {\n            throw StopIteration (new Error ());\n        }\n    };\n\n    function __JsIterator__ (iterable) {\n        this.iterable = iterable;\n        this.index = 0;\n    }\n\n    __JsIterator__.prototype.next = function () {\n        if (this.index < this.iterable.py_keys.length) {\n            return {value: this.index++, done: false};\n        }\n        else {\n            return {value: undefined, done: true};\n        }\n    };\n\n    // END unified iterator model\n\n    // Reversed function for arrays\n    var py_reversed = function (iterable) {\n        iterable = iterable.slice ();\n        iterable.reverse ();\n        return iterable;\n    };\n    __all__.py_reversed = py_reversed;\n\n    // Zip method for arrays and strings\n    var zip = function () {\n        var args = [] .slice.call (arguments);\n        for (var i = 0; i < args.length; i++) {\n            if (typeof args [i] == 'string') {\n                args [i] = args [i] .split ('');\n            }\n            else if (!Array.isArray (args [i])) {\n                args [i] = Array.from (args [i]);\n            }\n        }\n        var shortest = args.length == 0 ? [] : args.reduce (    // Find shortest array in arguments\n            function (array0, array1) {\n                return array0.length < array1.length ? array0 : array1;\n            }\n        );\n        return shortest.map (                   // Map each element of shortest array\n            function (current, index) {         // To the result of this function\n                return args.map (               // Map each array in arguments\n                    function (current) {        // To the result of this function\n                        return current [index]; // Namely it's index't entry\n                    }\n                );\n            }\n        );\n    };\n    __all__.zip = zip;\n\n    // Range method, returning an array\n    function range (start, stop, step) {\n        if (stop == undefined) {\n            // one param defined\n            stop = start;\n            start = 0;\n        }\n        if (step == undefined) {\n            step = 1;\n        }\n        if ((step > 0 && start >= stop) || (step < 0 && start <= stop)) {\n            return [];\n        }\n        var result = [];\n        for (var i = start; step > 0 ? i < stop : i > stop; i += step) {\n            result.push(i);\n        }\n        return result;\n    };\n    __all__.range = range;\n\n    // Any, all and sum\n\n__pragma__ ('ifdef', '__esv6__')\n    function any (iterable) {\n        for (let item of iterable) {\n            if (bool (item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function all (iterable) {\n        for (let item of iterable) {\n            if (! bool (item)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function sum (iterable) {\n        let result = 0;\n        for (let item of iterable) {\n            result += item;\n        }\n        return result;\n    }\n__pragma__ ('else')\n    function any (iterable) {\n        for (var index = 0; index < iterable.length; index++) {\n            if (bool (iterable [index])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function all (iterable) {\n        for (var index = 0; index < iterable.length; index++) {\n            if (! bool (iterable [index])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function sum (iterable) {\n        var result = 0;\n        for (var index = 0; index < iterable.length; index++) {\n            result += iterable [index];\n        }\n        return result;\n    }\n__pragma__ ('endif')\n\n    __all__.any = any;\n    __all__.all = all;\n    __all__.sum = sum;\n\n    // Enumerate method, returning a zipped list\n    function enumerate (iterable) {\n        return zip (range (len (iterable)), iterable);\n    }\n    __all__.enumerate = enumerate;\n\n    // Shallow and deepcopy\n\n    function copy (anObject) {\n        if (anObject == null || typeof anObject == \"object\") {\n            return anObject;\n        }\n        else {\n            var result = {};\n            for (var attrib in obj) {\n                if (anObject.hasOwnProperty (attrib)) {\n                    result [attrib] = anObject [attrib];\n                }\n            }\n            return result;\n        }\n    }\n    __all__.copy = copy;\n\n    function deepcopy (anObject) {\n        if (anObject == null || typeof anObject == \"object\") {\n            return anObject;\n        }\n        else {\n            var result = {};\n            for (var attrib in obj) {\n                if (anObject.hasOwnProperty (attrib)) {\n                    result [attrib] = deepcopy (anObject [attrib]);\n                }\n            }\n            return result;\n        }\n    }\n    __all__.deepcopy = deepcopy;\n\n    // List extensions to Array\n\n    function list (iterable) {                                      // All such creators should be callable without new\n__pragma__ ('ifdef', '__esv6__')\n        var instance = iterable ? Array.from (iterable) : [];\n__pragma__ ('else')\n        var instance = iterable ? [] .slice.apply (iterable) : [];  // Spread iterable, n.b. array.slice (), so array before dot\n__pragma__ ('endif')\n        // Sort is the normal JavaScript sort, Python sort is a non-member function\n        return instance;\n    }\n    __all__.list = list;\n    Array.prototype.__class__ = list;   // All arrays are lists (not only if constructed by the list ctor), unless constructed otherwise\n    list.__name__ = 'list';\n\n    /*\n    Array.from = function (iterator) { // !!! remove\n        result = [];\n        for (item of iterator) {\n            result.push (item);\n        }\n        return result;\n    }\n    */\n\n    Array.prototype.__iter__ = function () {return new __PyIterator__ (this);};\n\n    Array.prototype.__getslice__ = function (start, stop, step) {\n        if (start < 0) {\n            start = this.length + start;\n        }\n\n        if (stop == null) {\n            stop = this.length;\n        }\n        else if (stop < 0) {\n            stop = this.length + stop;\n        }\n        else if (stop > this.length) {\n            stop = this.length;\n        }\n\n        var result = list ([]);\n        for (var index = start; index < stop; index += step) {\n            result.push (this [index]);\n        }\n\n        return result;\n    };\n\n    Array.prototype.__setslice__ = function (start, stop, step, source) {\n        if (start < 0) {\n            start = this.length + start;\n        }\n\n        if (stop == null) {\n            stop = this.length;\n        }\n        else if (stop < 0) {\n            stop = this.length + stop;\n        }\n\n        if (step == null) { // Assign to 'ordinary' slice, replace subsequence\n            Array.prototype.splice.apply (this, [start, stop - start] .concat (source));\n        }\n        else {              // Assign to extended slice, replace designated items one by one\n            var sourceIndex = 0;\n            for (var targetIndex = start; targetIndex < stop; targetIndex += step) {\n                this [targetIndex] = source [sourceIndex++];\n            }\n        }\n    };\n\n    Array.prototype.__repr__ = function () {\n        if (this.__class__ == set && !this.length) {\n            return 'set()';\n        }\n\n        var result = !this.__class__ || this.__class__ == list ? '[' : this.__class__ == tuple ? '(' : '{';\n\n        for (var index = 0; index < this.length; index++) {\n            if (index) {\n                result += ', ';\n            }\n            result += repr (this [index]);\n        }\n\n        if (this.__class__ == tuple && this.length == 1) {\n            result += ',';\n        }\n\n        result += !this.__class__ || this.__class__ == list ? ']' : this.__class__ == tuple ? ')' : '}';;\n        return result;\n    };\n\n    Array.prototype.__str__ = Array.prototype.__repr__;\n\n    Array.prototype.append = function (element) {\n        this.push (element);\n    };\n\n    Array.prototype.py_clear = function () {\n        this.length = 0;\n    };\n\n    Array.prototype.extend = function (aList) {\n        this.push.apply (this, aList);\n    };\n\n    Array.prototype.insert = function (index, element) {\n        this.splice (index, 0, element);\n    };\n\n    Array.prototype.remove = function (element) {\n        var index = this.indexOf (element);\n        if (index == -1) {\n            throw ValueError (\"list.remove(x): x not in list\", new Error ());\n        }\n        this.splice (index, 1);\n    };\n\n    Array.prototype.index = function (element) {\n        return this.indexOf (element);\n    };\n\n    Array.prototype.py_pop = function (index) {\n        if (index == undefined) {\n            return this.pop ();  // Remove last element\n        }\n        else {\n            return this.splice (index, 1) [0];\n        }\n    };\n\n    Array.prototype.py_sort = function () {\n        __sort__.apply  (null, [this].concat ([] .slice.apply (arguments)));    // Can't work directly with arguments\n        // Python params: (iterable, key = None, reverse = False)\n        // py_sort is called with the Transcrypt kwargs mechanism, and just passes the params on to __sort__\n        // __sort__ is def'ed with the Transcrypt kwargs mechanism\n    };\n\n    Array.prototype.__add__ = function (aList) {\n        return list (this.concat (aList));\n    };\n\n    Array.prototype.__mul__ = function (scalar) {\n        var result = this;\n        for (var i = 1; i < scalar; i++) {\n            result = result.concat (this);\n        }\n        return result;\n    };\n\n    Array.prototype.__rmul__ = Array.prototype.__mul__;\n\n    // Tuple extensions to Array\n\n    function tuple (iterable) {\n        var instance = iterable ? [] .slice.apply (iterable) : [];\n        instance.__class__ = tuple; // Not all arrays are tuples\n        return instance;\n    }\n    __all__.tuple = tuple;\n    tuple.__name__ = 'tuple';\n\n    // Set extensions to Array\n    // N.B. Since sets are unordered, set operations will occasionally alter the 'this' array by sorting it\n\n    function set (iterable) {\n        var instance = [];\n        if (iterable) {\n            for (var index = 0; index < iterable.length; index++) {\n                instance.add (iterable [index]);\n            }\n        }\n        instance.__class__ = set;   // Not all arrays are sets\n        return instance;\n    }\n    __all__.set = set;\n    set.__name__ = 'set';\n\n    Array.prototype.__bindexOf__ = function (element) { // Used to turn O (n^2) into O (n log n)\n    // Since sorting is lex, compare has to be lex. This also allows for mixed lists\n\n        element += '';\n\n        var mindex = 0;\n        var maxdex = this.length - 1;\n\n        while (mindex <= maxdex) {\n            var index = (mindex + maxdex) / 2 | 0;\n            var middle = this [index] + '';\n\n            if (middle < element) {\n                mindex = index + 1;\n            }\n            else if (middle > element) {\n                maxdex = index - 1;\n            }\n            else {\n                return index;\n            }\n        }\n\n        return -1;\n    };\n\n    Array.prototype.add = function (element) {\n        if (this.indexOf (element) == -1) { // Avoid duplicates in set\n            this.push (element);\n        }\n    };\n\n    Array.prototype.discard = function (element) {\n        var index = this.indexOf (element);\n        if (index != -1) {\n            this.splice (index, 1);\n        }\n    };\n\n    Array.prototype.isdisjoint = function (other) {\n        this.sort ();\n        for (var i = 0; i < other.length; i++) {\n            if (this.__bindexOf__ (other [i]) != -1) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    Array.prototype.issuperset = function (other) {\n        this.sort ();\n        for (var i = 0; i < other.length; i++) {\n            if (this.__bindexOf__ (other [i]) == -1) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    Array.prototype.issubset = function (other) {\n        return set (other.slice ()) .issuperset (this); // Sort copy of 'other', not 'other' itself, since it may be an ordered sequence\n    };\n\n    Array.prototype.union = function (other) {\n        var result = set (this.slice () .sort ());\n        for (var i = 0; i < other.length; i++) {\n            if (result.__bindexOf__ (other [i]) == -1) {\n                result.push (other [i]);\n            }\n        }\n        return result;\n    };\n\n    Array.prototype.intersection = function (other) {\n        this.sort ();\n        var result = set ();\n        for (var i = 0; i < other.length; i++) {\n            if (this.__bindexOf__ (other [i]) != -1) {\n                result.push (other [i]);\n            }\n        }\n        return result;\n    };\n\n    Array.prototype.difference = function (other) {\n        var sother = set (other.slice () .sort ());\n        var result = set ();\n        for (var i = 0; i < this.length; i++) {\n            if (sother.__bindexOf__ (this [i]) == -1) {\n                result.push (this [i]);\n            }\n        }\n        return result;\n    };\n\n    Array.prototype.symmetric_difference = function (other) {\n        return this.union (other) .difference (this.intersection (other));\n    };\n\n    Array.prototype.py_update = function () {   // O (n)\n        var updated = [] .concat.apply (this.slice (), arguments) .sort ();\n        this.py_clear ();\n        for (var i = 0; i < updated.length; i++) {\n            if (updated [i] != updated [i - 1]) {\n                this.push (updated [i]);\n            }\n        }\n    };\n\n    Array.prototype.__eq__ = function (other) { // Also used for list\n        if (this.length != other.length) {\n            return false;\n        }\n        if (this.__class__ == set) {\n            this.sort ();\n            other.sort ();\n        }\n        for (var i = 0; i < this.length; i++) {\n            if (this [i] != other [i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    Array.prototype.__ne__ = function (other) { // Also used for list\n        return !this.__eq__ (other);\n    };\n\n    Array.prototype.__le__ = function (other) {\n        return this.issubset (other);\n    };\n\n    Array.prototype.__ge__ = function (other) {\n        return this.issuperset (other);\n    };\n\n    Array.prototype.__lt__ = function (other) {\n        return this.issubset (other) && !this.issuperset (other);\n    };\n\n    Array.prototype.__gt__ = function (other) {\n        return this.issuperset (other) && !this.issubset (other);\n    };\n\n    // Byte array extensions\n    \n    function bytearray (bytable, encoding) {\n        if (bytable == undefined) {\n            return new Uint8Array (0);\n        }\n        else {\n            var aType = py_typeof (bytable);\n            if (aType == int) {\n                return new Uint8Array (bytable);\n            }\n            else if (aType == str) {\n                var aBytes = new Uint8Array (len (bytable));\n                for (var i = 0; i < len (bytable); i++) {\n                    aBytes [i] = bytable.charCodeAt (i);\n                }\n                return aBytes;\n            }\n            else if (aType == list || aType == tuple) {\n                return new Uint8Array (bytable);\n            }\n            else {\n                throw py_TypeError;\n            }\n        }\n    }\n\n    var bytes = bytearray;\n    \n    __all__.bytearray = bytearray;\n    __all__.bytes = bytearray;\n   \n    Uint8Array.prototype.__add__ = function (aBytes) {\n        var result = new Uint8Array (this.length + aBytes.length);\n        result.set (this);\n        result.set (aBytes, this.length);\n        return result;\n    };\n\n    Uint8Array.prototype.__mul__ = function (scalar) {\n        var result = new Uint8Array (scalar * this.length);\n        for (var i = 0; i < scalar; i++) {\n            result.set (this, i * this.length);\n        }\n        return result;\n    };\n\n    Uint8Array.prototype.__rmul__ = Uint8Array.prototype.__mul__;\n    \n    // String extensions\n\n    function str (stringable) {\n        try {\n            return stringable.__str__ ();\n        }\n        catch (exception) {\n            try {\n                return repr (stringable);\n            }\n            catch (exception) {\n                return String (stringable); // No new, so no permanent String object but a primitive in a temporary 'just in time' wrapper\n            }\n        }\n    };\n    __all__.str = str;\n\n    String.prototype.__class__ = str;   // All strings are str\n    str.__name__ = 'str';\n\n    String.prototype.__iter__ = function () {new __PyIterator__ (this);};\n\n    String.prototype.__repr__ = function () {\n        return (this.indexOf ('\\'') == -1 ? '\\'' + this + '\\'' : '\"' + this + '\"') .py_replace ('\\t', '\\\\t') .py_replace ('\\n', '\\\\n');\n    };\n\n    String.prototype.__str__ = function () {\n        return this;\n    };\n\n    String.prototype.capitalize = function () {\n        return this.charAt (0).toUpperCase () + this.slice (1);\n    };\n\n    String.prototype.endswith = function (suffix) {\n        return suffix == '' || this.slice (-suffix.length) == suffix;\n    };\n\n    String.prototype.find  = function (sub, start) {\n        return this.indexOf (sub, start);\n    };\n\n    String.prototype.__getslice__ = function (start, stop, step) {\n        if (start < 0) {\n            start = this.length + start;\n        }\n\n        if (stop == null) {\n            stop = this.length;\n        }\n        else if (stop < 0) {\n            stop = this.length + stop;\n        }\n\n        var result = '';\n        if (step == 1) {\n            result = this.substring (start, stop);\n        }\n        else {\n            for (var index = start; index < stop; index += step) {\n                result = result.concat (this.charAt(index));\n            }\n        }\n        return result;\n    }\n\n    // Since it's worthwhile for the 'format' function to be able to deal with *args, it is defined as a property\n    // __get__ will produce a bound function if there's something before the dot\n    // Since a call using *args is compiled to e.g. <object>.<function>.apply (null, args), the function has to be bound already\n    // Otherwise it will never be, because of the null argument\n    // Using 'this' rather than 'null' contradicts the requirement to be able to pass bound functions around\n    // The object 'before the dot' won't be available at call time in that case, unless implicitly via the function bound to it\n    // While for Python methods this mechanism is generated by the compiler, for JavaScript methods it has to be provided manually\n    // Call memoizing is unattractive here, since every string would then have to hold a reference to a bound format method\n    __setProperty__ (String.prototype, 'format', {\n        get: function () {return __get__ (this, function (self) {\n            var args = tuple ([] .slice.apply (arguments).slice (1));\n            var autoIndex = 0;\n            return self.replace (/\\{(\\w*)\\}/g, function (match, key) {\n                if (key == '') {\n                    key = autoIndex++;\n                }\n                if (key == +key) {  // So key is numerical\n                    return args [key] == undefined ? match : str (args [key]);\n                }\n                else {              // Key is a string\n                    for (var index = 0; index < args.length; index++) {\n                        // Find first 'dict' that has that key and the right field\n                        if (typeof args [index] == 'object' && args [index][key] != undefined) {\n                            return str (args [index][key]); // Return that field field\n                        }\n                    }\n                    return match;\n                }\n            });\n        });},\n        enumerable: true\n    });\n\n    String.prototype.isalnum = function () {\n        return /^[0-9a-zA-Z]{1,}$/.test(this)\n    }\n\n    String.prototype.isalpha = function () {\n        return /^[a-zA-Z]{1,}$/.test(this)\n    }\n\n    String.prototype.isdecimal = function () {\n        return /^[0-9]{1,}$/.test(this)\n    }\n\n    String.prototype.isdigit = function () {\n        return this.isdecimal()\n    }\n\n    String.prototype.islower = function () {\n        return /^[a-z]{1,}$/.test(this)\n    }\n\n    String.prototype.isupper = function () {\n        return /^[A-Z]{1,}$/.test(this)\n    }\n\n    String.prototype.isspace = function () {\n        return /^[\\s]{1,}$/.test(this)\n    }\n\n    String.prototype.isnumeric = function () {\n        return !isNaN (parseFloat (this)) && isFinite (this);\n    };\n\n    String.prototype.join = function (strings) {\n__pragma__ ('ifdef', '__esv6__')\n        strings = Array.from (strings); // Much faster than iterating through strings char by char\n__pragma__ ('endif')\n        return strings.join (this);\n    };\n\n    String.prototype.lower = function () {\n        return this.toLowerCase ();\n    };\n\n    String.prototype.py_replace = function (old, aNew, maxreplace) {\n        return this.split (old, maxreplace) .join (aNew);\n    };\n\n    String.prototype.lstrip = function () {\n        return this.replace (/^\\s*/g, '');\n    };\n\n    String.prototype.rfind = function (sub, start) {\n        return this.lastIndexOf (sub, start);\n    };\n\n    String.prototype.rsplit = function (sep, maxsplit) {    // Combination of general whitespace sep and positive maxsplit neither supported nor checked, expensive and rare\n        if (sep == undefined || sep == null) {\n            sep = /\\s+/;\n            var stripped = this.strip ();\n        }\n        else {\n            var stripped = this;\n        }\n\n        if (maxsplit == undefined || maxsplit == -1) {\n            return stripped.split (sep);\n        }\n        else {\n            var result = stripped.split (sep);\n            if (maxsplit < result.length) {\n                var maxrsplit = result.length - maxsplit;\n                return [result.slice (0, maxrsplit) .join (sep)] .concat (result.slice (maxrsplit));\n            }\n            else {\n                return result;\n            }\n        }\n    };\n\n    String.prototype.rstrip = function () {\n        return this.replace (/\\s*$/g, '');\n    };\n\n    String.prototype.py_split = function (sep, maxsplit) {  // Combination of general whitespace sep and positive maxsplit neither supported nor checked, expensive and rare\n        if (sep == undefined || sep == null) {\n            sep = /\\s+/;\n            var stripped = this.strip ();\n        }\n        else {\n            var stripped = this;\n        }\n\n        if (maxsplit == undefined || maxsplit == -1) {\n            return stripped.split (sep);\n        }\n        else {\n            var result = stripped.split (sep);\n            if (maxsplit < result.length) {\n                return result.slice (0, maxsplit).concat ([result.slice (maxsplit).join (sep)]);\n            }\n            else {\n                return result;\n            }\n        }\n    };\n\n    String.prototype.startswith = function (prefix) {\n        return this.indexOf (prefix) == 0;\n    };\n\n    String.prototype.strip = function () {\n        return this.trim ();\n    };\n\n    String.prototype.upper = function () {\n        return this.toUpperCase ();\n    };\n\n    String.prototype.__mul__ = function (scalar) {\n        var result = this;\n        for (var i = 1; i < scalar; i++) {\n            result = result + this;\n        }\n        return result;\n    };\n\n    String.prototype.__rmul__ = String.prototype.__mul__;\n\n    // Dict extensions to object\n\n    function __keys__ () {\n        var keys = [];\n        for (var attrib in this) {\n            if (!__specialattrib__ (attrib)) {\n                keys.push (attrib);\n            }\n        }\n        return keys;\n    }\n\n    function __items__ () {\n        var items = [];\n        for (var attrib in this) {\n            if (!__specialattrib__ (attrib)) {\n                items.push ([attrib, this [attrib]]);\n            }\n        }\n        return items;\n    }\n\n    function __del__ (key) {\n        delete this [key];\n    }\n\n    function __clear__ () {\n        for (var attrib in this) {\n            delete this [attrib];\n        }\n    }\n\n    function __getdefault__ (aKey, aDefault) {  // Each Python object already has a function called __get__, so we call this one __getdefault__\n        var result = this [aKey];\n        if (result == undefined) {\n            result = this ['py_' + aKey]\n        }\n        return result == undefined ? (aDefault == undefined ? null : aDefault) : result;\n    }\n\n    function __setdefault__ (aKey, aDefault) {\n        var result = this [aKey];\n        if (result != undefined) {\n            return result;\n        }\n        var val = aDefault == undefined ? null : aDefault;\n        this [aKey] = val;\n        return val;\n    }\n\n    function __pop__ (aKey, aDefault) {\n        var result = this [aKey];\n        if (result != undefined) {\n            delete this [aKey];\n            return result;\n        } else {\n            // Identify check because user could pass None\n            if ( aDefault === undefined ) {\n                throw KeyError (aKey, new Error());\n            }\n        }\n        return aDefault;\n    }\n    \n    function __popitem__ () {\n        var aKey = Object.keys (this) [0];\n        if (aKey == null) {\n            throw KeyError (\"popitem(): dictionary is empty\", new Error ());\n        }\n        var result = tuple ([aKey, this [aKey]]);\n        delete this [aKey];\n        return result;\n    }\n    \n    function __update__ (aDict) {\n        for (var aKey in aDict) {\n            this [aKey] = aDict [aKey];\n        }\n    }\n    \n    function __values__ () {\n        var values = [];\n        for (var attrib in this) {\n            if (!__specialattrib__ (attrib)) {\n                values.push (this [attrib]);\n            }\n        }\n        return values;\n\n    }\n    \n    function __dgetitem__ (aKey) {\n        return this [aKey];\n    }\n    \n    function __dsetitem__ (aKey, aValue) {\n        this [aKey] = aValue;\n    }\n\n    function dict (objectOrPairs) {\n        var instance = {};\n        if (!objectOrPairs || objectOrPairs instanceof Array) { // It's undefined or an array of pairs\n            if (objectOrPairs) {\n                for (var index = 0; index < objectOrPairs.length; index++) {\n                    var pair = objectOrPairs [index];\n                    if ( !(pair instanceof Array) || pair.length != 2) {\n                        throw ValueError(\n                            \"dict update sequence element #\" + index +\n                            \" has length \" + pair.length +\n                            \"; 2 is required\", new Error());\n                    }\n                    var key = pair [0];\n                    var val = pair [1];\n                    if (!(objectOrPairs instanceof Array) && objectOrPairs instanceof Object) {\n                         // User can potentially pass in an object\n                         // that has a hierarchy of objects. This\n                         // checks to make sure that these objects\n                         // get converted to dict objects instead of\n                         // leaving them as js objects.\n                         \n                         if (!isinstance (objectOrPairs, dict)) {\n                             val = dict (val);\n                         }\n                    }\n                    instance [key] = val;\n                }\n            }\n        }\n        else {\n            if (isinstance (objectOrPairs, dict)) {\n                // Passed object is a dict already so we need to be a little careful\n                // N.B. - this is a shallow copy per python std - so\n                // it is assumed that children have already become\n                // python objects at some point.\n                \n                var aKeys = objectOrPairs.py_keys ();\n                for (var index = 0; index < aKeys.length; index++ ) {\n                    var key = aKeys [index];\n                    instance [key] = objectOrPairs [key];\n                }\n            } else if (objectOrPairs instanceof Object) {\n                // Passed object is a JavaScript object but not yet a dict, don't copy it\n                instance = objectOrPairs;\n            } else {\n                // We have already covered Array so this indicates\n                // that the passed object is not a js object - i.e.\n                // it is an int or a string, which is invalid.\n                \n                throw ValueError (\"Invalid type of object for dict creation\", new Error ());\n            }\n        }\n\n        // Trancrypt interprets e.g. {aKey: 'aValue'} as a Python dict literal rather than a JavaScript object literal\n        // So dict literals rather than bare Object literals will be passed to JavaScript libraries\n        // Some JavaScript libraries call all enumerable callable properties of an object that's passed to them\n        // So the properties of a dict should be non-enumerable\n        __setProperty__ (instance, '__class__', {value: dict, enumerable: false, writable: true});\n        __setProperty__ (instance, 'py_keys', {value: __keys__, enumerable: false});\n        __setProperty__ (instance, '__iter__', {value: function () {new __PyIterator__ (this.py_keys ());}, enumerable: false});\n        __setProperty__ (instance, Symbol.iterator, {value: function () {new __JsIterator__ (this.py_keys ());}, enumerable: false});\n        __setProperty__ (instance, 'py_items', {value: __items__, enumerable: false});\n        __setProperty__ (instance, 'py_del', {value: __del__, enumerable: false});\n        __setProperty__ (instance, 'py_clear', {value: __clear__, enumerable: false});\n        __setProperty__ (instance, 'py_get', {value: __getdefault__, enumerable: false});\n        __setProperty__ (instance, 'py_setdefault', {value: __setdefault__, enumerable: false});\n        __setProperty__ (instance, 'py_pop', {value: __pop__, enumerable: false});\n        __setProperty__ (instance, 'py_popitem', {value: __popitem__, enumerable: false});\n        __setProperty__ (instance, 'py_update', {value: __update__, enumerable: false});\n        __setProperty__ (instance, 'py_values', {value: __values__, enumerable: false});\n        __setProperty__ (instance, '__getitem__', {value: __dgetitem__, enumerable: false});    // Needed since compound keys necessarily\n        __setProperty__ (instance, '__setitem__', {value: __dsetitem__, enumerable: false});    // trigger overloading to deal with slices\n        return instance;\n    }\n\n    __all__.dict = dict;\n    dict.__name__ = 'dict';\n    \n    // Docstring setter\n\n    function __setdoc__ (docString) {\n        this.__doc__ = docString;\n        return this;\n    }\n\n    // Python classes, methods and functions are all translated to JavaScript functions\n    __setProperty__ (Function.prototype, '__setdoc__', {value: __setdoc__, enumerable: false});\n\n    // General operator overloading, only the ones that make most sense in matrix and complex operations\n    \n    var __jsmod__ = function (a, b) {\n        if (typeof a == 'object' && '__mod__' in a) {\n            return a.__mod__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rmod__ (a);\n        }\n        else {\n            return a % b;\n        }\n    };\n    __all__.__jsmod__ = __jsmod__;\n    \n    var __mod__ = function (a, b) {\n        if (typeof a == 'object' && '__mod__' in a) {\n            return a.__mod__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rmod__ (a);\n        }\n        else {\n            return ((a % b) + b) % b;\n        }\n    };\n    __all__.mod = __mod__;\n    \n\n    var __pow__ = function (a, b) {\n        if (typeof a == 'object' && '__pow__' in a) {\n            return a.__pow__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rpow__ (a);\n        }\n        else {\n            return Math.pow (a, b);\n        }\n    };\n    __all__.pow = __pow__;\n    \n    __pragma__ ('ifndef', '__xtiny__')    \n    \n    var __neg__ = function (a) {\n        if (typeof a == 'object' && '__neg__' in a) {\n            return a.__neg__ ();\n        }\n        else {\n            return -a;\n        }\n    };\n    __all__.__neg__ = __neg__;\n\n    var __matmul__ = function (a, b) {\n        return a.__matmul__ (b);\n    };\n    __all__.__matmul__ = __matmul__;\n\n    // Overloaded binary arithmetic\n    \n    var __mul__ = function (a, b) {\n        if (typeof a == 'object' && '__mul__' in a) {\n            return a.__mul__ (b);\n        }\n        else if (typeof b == 'object' && '__rmul__' in b) {\n            return b.__rmul__ (a);\n        }\n        else if (typeof a == 'string') {\n            return a.__mul__ (b);\n        }\n        else if (typeof b == 'string') {\n            return b.__rmul__ (a);\n        }\n        else {\n            return a * b;\n        }\n    };\n    __all__.__mul__ = __mul__;\n\n    var __truediv__ = function (a, b) {\n        if (typeof a == 'object' && '__truediv__' in a) {\n            return a.__truediv__ (b);\n        }\n        else if (typeof b == 'object' && '__rtruediv__' in b) {\n            return b.__rtruediv__ (a);\n        }\n        else if (typeof a == 'object' && '__div__' in a) {\n            return a.__div__ (b);\n        }\n        else if (typeof b == 'object' && '__rdiv__' in b) {\n            return b.__rdiv__ (a);\n        }\n        else {\n            return a / b;\n        }\n    };\n    __all__.__truediv__ = __truediv__;\n\n    var __floordiv__ = function (a, b) {\n        if (typeof a == 'object' && '__floordiv__' in a) {\n            return a.__floordiv__ (b);\n        }\n        else if (typeof b == 'object' && '__rfloordiv__' in b) {\n            return b.__rfloordiv__ (a);\n        }\n        else if (typeof a == 'object' && '__div__' in a) {\n            return a.__div__ (b);\n        }\n        else if (typeof b == 'object' && '__rdiv__' in b) {\n            return b.__rdiv__ (a);\n        }\n        else {\n            return Math.floor (a / b);\n        }\n    };\n    __all__.__floordiv__ = __floordiv__;\n\n    var __add__ = function (a, b) {\n        if (typeof a == 'object' && '__add__' in a) {\n            return a.__add__ (b);\n        }\n        else if (typeof b == 'object' && '__radd__' in b) {\n            return b.__radd__ (a);\n        }\n        else {\n            return a + b;\n        }\n    };\n    __all__.__add__ = __add__;\n\n    var __sub__ = function (a, b) {\n        if (typeof a == 'object' && '__sub__' in a) {\n            return a.__sub__ (b);\n        }\n        else if (typeof b == 'object' && '__rsub__' in b) {\n            return b.__rsub__ (a);\n        }\n        else {\n            return a - b;\n        }\n    };\n    __all__.__sub__ = __sub__;\n\n    // Overloaded binary bitwise\n    \n    var __lshift__ = function (a, b) {\n        if (typeof a == 'object' && '__lshift__' in a) {\n            return a.__lshift__ (b);\n        }\n        else if (typeof b == 'object' && '__rlshift__' in b) {\n            return b.__rlshift__ (a);\n        }\n        else {\n            return a << b;\n        }\n    };\n    __all__.__lshift__ = __lshift__;\n\n    var __rshift__ = function (a, b) {\n        if (typeof a == 'object' && '__rshift__' in a) {\n            return a.__rshift__ (b);\n        }\n        else if (typeof b == 'object' && '__rrshift__' in b) {\n            return b.__rrshift__ (a);\n        }\n        else {\n            return a >> b;\n        }\n    };\n    __all__.__rshift__ = __rshift__;\n\n    var __or__ = function (a, b) {\n        if (typeof a == 'object' && '__or__' in a) {\n            return a.__or__ (b);\n        }\n        else if (typeof b == 'object' && '__ror__' in b) {\n            return b.__ror__ (a);\n        }\n        else {\n            return a | b;\n        }\n    };\n    __all__.__or__ = __or__;\n\n    var __xor__ = function (a, b) {\n        if (typeof a == 'object' && '__xor__' in a) {\n            return a.__xor__ (b);\n        }\n        else if (typeof b == 'object' && '__rxor__' in b) {\n            return b.__rxor__ (a);\n        }\n        else {\n            return a ^ b;\n        }\n    };\n    __all__.__xor__ = __xor__;\n\n    var __and__ = function (a, b) {\n        if (typeof a == 'object' && '__and__' in a) {\n            return a.__and__ (b);\n        }\n        else if (typeof b == 'object' && '__rand__' in b) {\n            return b.__rand__ (a);\n        }\n        else {\n            return a & b;\n        }\n    };\n    __all__.__and__ = __and__;\n\n    // Overloaded binary compare\n    \n    var __eq__ = function (a, b) {\n        if (typeof a == 'object' && '__eq__' in a) {\n            return a.__eq__ (b);\n        }\n        else {\n            return a == b;\n        }\n    };\n    __all__.__eq__ = __eq__;\n\n    var __ne__ = function (a, b) {\n        if (typeof a == 'object' && '__ne__' in a) {\n            return a.__ne__ (b);\n        }\n        else {\n            return a != b\n        }\n    };\n    __all__.__ne__ = __ne__;\n\n    var __lt__ = function (a, b) {\n        if (typeof a == 'object' && '__lt__' in a) {\n            return a.__lt__ (b);\n        }\n        else {\n            return a < b;\n        }\n    };\n    __all__.__lt__ = __lt__;\n\n    var __le__ = function (a, b) {\n        if (typeof a == 'object' && '__le__' in a) {\n            return a.__le__ (b);\n        }\n        else {\n            return a <= b;\n        }\n    };\n    __all__.__le__ = __le__;\n\n    var __gt__ = function (a, b) {\n        if (typeof a == 'object' && '__gt__' in a) {\n            return a.__gt__ (b);\n        }\n        else {\n            return a > b;\n        }\n    };\n    __all__.__gt__ = __gt__;\n\n    var __ge__ = function (a, b) {\n        if (typeof a == 'object' && '__ge__' in a) {\n            return a.__ge__ (b);\n        }\n        else {\n            return a >= b;\n        }\n    };\n    __all__.__ge__ = __ge__;\n    \n    // Overloaded augmented general\n    \n    var __imatmul__ = function (a, b) {\n        if ('__imatmul__' in a) {\n            return a.__imatmul__ (b);\n        }\n        else {\n            return a.__matmul__ (b);\n        }\n    };\n    __all__.__imatmul__ = __imatmul__;\n\n    var __ipow__ = function (a, b) {\n        if (typeof a == 'object' && '__pow__' in a) {\n            return a.__ipow__ (b);\n        }\n        else if (typeof a == 'object' && '__ipow__' in a) {\n            return a.__pow__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rpow__ (a);\n        }\n        else {\n            return Math.pow (a, b);\n        }\n    };\n    __all__.ipow = __ipow__;\n\n    var __ijsmod__ = function (a, b) {\n        if (typeof a == 'object' && '__imod__' in a) {\n            return a.__ismod__ (b);\n        }\n        else if (typeof a == 'object' && '__mod__' in a) {\n            return a.__mod__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rmod__ (a);\n        }\n        else {\n            return a % b;\n        }\n    };\n    __all__.ijsmod__ = __ijsmod__;\n    \n    var __imod__ = function (a, b) {\n        if (typeof a == 'object' && '__imod__' in a) {\n            return a.__imod__ (b);\n        }\n        else if (typeof a == 'object' && '__mod__' in a) {\n            return a.__mod__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rmod__ (a);\n        }\n        else {\n            return ((a % b) + b) % b;\n        }\n    };\n    __all__.imod = __imod__;\n    \n    // Overloaded augmented arithmetic\n    \n    var __imul__ = function (a, b) {\n        if (typeof a == 'object' && '__imul__' in a) {\n            return a.__imul__ (b);\n        }\n        else if (typeof a == 'object' && '__mul__' in a) {\n            return a = a.__mul__ (b);\n        }\n        else if (typeof b == 'object' && '__rmul__' in b) {\n            return a = b.__rmul__ (a);\n        }\n        else if (typeof a == 'string') {\n            return a = a.__mul__ (b);\n        }\n        else if (typeof b == 'string') {\n            return a = b.__rmul__ (a);\n        }\n        else {\n            return a *= b;\n        }\n    };\n    __all__.__imul__ = __imul__;\n\n    var __idiv__ = function (a, b) {\n        if (typeof a == 'object' && '__idiv__' in a) {\n            return a.__idiv__ (b);\n        }\n        else if (typeof a == 'object' && '__div__' in a) {\n            return a = a.__div__ (b);\n        }\n        else if (typeof b == 'object' && '__rdiv__' in b) {\n            return a = b.__rdiv__ (a);\n        }\n        else {\n            return a /= b;\n        }\n    };\n    __all__.__idiv__ = __idiv__;\n\n    var __iadd__ = function (a, b) {\n        if (typeof a == 'object' && '__iadd__' in a) {\n            return a.__iadd__ (b);\n        }\n        else if (typeof a == 'object' && '__add__' in a) {\n            return a = a.__add__ (b);\n        }\n        else if (typeof b == 'object' && '__radd__' in b) {\n            return a = b.__radd__ (a);\n        }\n        else {\n            return a += b;\n        }\n    };\n    __all__.__iadd__ = __iadd__;\n\n    var __isub__ = function (a, b) {\n        if (typeof a == 'object' && '__isub__' in a) {\n            return a.__isub__ (b);\n        }\n        else if (typeof a == 'object' && '__sub__' in a) {\n            return a = a.__sub__ (b);\n        }\n        else if (typeof b == 'object' && '__rsub__' in b) {\n            return a = b.__rsub__ (a);\n        }\n        else {\n            return a -= b;\n        }\n    };\n    __all__.__isub__ = __isub__;\n\n    // Overloaded augmented bitwise\n    \n    var __ilshift__ = function (a, b) {\n        if (typeof a == 'object' && '__ilshift__' in a) {\n            return a.__ilshift__ (b);\n        }\n        else if (typeof a == 'object' && '__lshift__' in a) {\n            return a = a.__lshift__ (b);\n        }\n        else if (typeof b == 'object' && '__rlshift__' in b) {\n            return a = b.__rlshift__ (a);\n        }\n        else {\n            return a <<= b;\n        }\n    };\n    __all__.__ilshift__ = __ilshift__;\n\n    var __irshift__ = function (a, b) {\n        if (typeof a == 'object' && '__irshift__' in a) {\n            return a.__irshift__ (b);\n        }\n        else if (typeof a == 'object' && '__rshift__' in a) {\n            return a = a.__rshift__ (b);\n        }\n        else if (typeof b == 'object' && '__rrshift__' in b) {\n            return a = b.__rrshift__ (a);\n        }\n        else {\n            return a >>= b;\n        }\n    };\n    __all__.__irshift__ = __irshift__;\n\n    var __ior__ = function (a, b) {\n        if (typeof a == 'object' && '__ior__' in a) {\n            return a.__ior__ (b);\n        }\n        else if (typeof a == 'object' && '__or__' in a) {\n            return a = a.__or__ (b);\n        }\n        else if (typeof b == 'object' && '__ror__' in b) {\n            return a = b.__ror__ (a);\n        }\n        else {\n            return a |= b;\n        }\n    };\n    __all__.__ior__ = __ior__;\n\n    var __ixor__ = function (a, b) {\n        if (typeof a == 'object' && '__ixor__' in a) {\n            return a.__ixor__ (b);\n        }\n        else if (typeof a == 'object' && '__xor__' in a) {\n            return a = a.__xor__ (b);\n        }\n        else if (typeof b == 'object' && '__rxor__' in b) {\n            return a = b.__rxor__ (a);\n        }\n        else {\n            return a ^= b;\n        }\n    };\n    __all__.__ixor__ = __ixor__;\n\n    var __iand__ = function (a, b) {\n        if (typeof a == 'object' && '__iand__' in a) {\n            return a.__iand__ (b);\n        }\n        else if (typeof a == 'object' && '__and__' in a) {\n            return a = a.__and__ (b);\n        }\n        else if (typeof b == 'object' && '__rand__' in b) {\n            return a = b.__rand__ (a);\n        }\n        else {\n            return a &= b;\n        }\n    };\n    __all__.__iand__ = __iand__;\n    \n    // Indices and slices\n\n    var __getitem__ = function (container, key) {                           // Slice c.q. index, direct generated call to runtime switch\n        if (typeof container == 'object' && '__getitem__' in container) {\n            return container.__getitem__ (key);                             // Overloaded on container\n        }\n        else {\n            return container [key];                                         // Container must support bare JavaScript brackets\n        }\n    };\n    __all__.__getitem__ = __getitem__;\n\n    var __setitem__ = function (container, key, value) {                    // Slice c.q. index, direct generated call to runtime switch\n        if (typeof container == 'object' && '__setitem__' in container) {\n            container.__setitem__ (key, value);                             // Overloaded on container\n        }\n        else {\n            container [key] = value;                                        // Container must support bare JavaScript brackets\n        }\n    };\n    __all__.__setitem__ = __setitem__;\n\n    var __getslice__ = function (container, lower, upper, step) {           // Slice only, no index, direct generated call to runtime switch\n        if (typeof container == 'object' && '__getitem__' in container) {\n            return container.__getitem__ ([lower, upper, step]);            // Container supports overloaded slicing c.q. indexing\n        }\n        else {\n            return container.__getslice__ (lower, upper, step);             // Container only supports slicing injected natively in prototype\n        }\n    };\n    __all__.__getslice__ = __getslice__;\n\n    var __setslice__ = function (container, lower, upper, step, value) {    // Slice, no index, direct generated call to runtime switch\n        if (typeof container == 'object' && '__setitem__' in container) {\n            container.__setitem__ ([lower, upper, step], value);            // Container supports overloaded slicing c.q. indexing\n        }\n        else {\n            container.__setslice__ (lower, upper, step, value);             // Container only supports slicing injected natively in prototype\n        }\n    };\n    __all__.__setslice__ = __setslice__;\n    \n__pragma__ ('endif') \n",
		"pi = Math.PI\ne = Math.E\n\ndef phase (x):\n    return 0 if __typeof__ (x) is 'number' else Math.atan2 (x.imag, x.real)\n    \ndef polar (x):\n    return (Math.abs (x), 0) if __typeof__ (x) is 'number' else (abs (x), phase (x))\n    \ndef rect (r, phi):\n    __pragma__ ('opov')\n    return r * (Math.cos (phi) + 1.j * Math.sin (phi))\n    __pragma__ ('noopov')\n    \ndef exp (x):\n    return complex (x, 0) .__exp__ () if __typeof__ (x) is 'number' else x.__exp__ ()\n        \ndef log (x, base):\n    return (\n        complex (x, 0) .__log__ () if __typeof__ (x) is 'number' else x.__log__ ()\n    ) if base is js_undefined else (\n        __truediv__ (log (x), log (base))   # Recursive\n    )\n    \ndef log10 (x):\n    return log (x, 10)\n    \ndef sqrt (x):\n    return exp (__mul__ (log (x), 0.5))\n    \n__pragma__ ('opov')\n\ndef sin (x):\n    return -0.5j * (exp (1j * x) - exp (-1j * x))\n\ndef cos (x):\n    return 0.5 * (exp (1j * x) + exp (-1j * x))\n\ndef tan (x):\n    return -1j * (exp (1j * x) - exp (-1j * x)) / (exp (1j * x) + exp (-1j * x))\n\ndef asin (x):\n    return -1j * log (1j * x + sqrt (1 - x * x))\n\ndef acos (x):\n    return -1j * log (x + 1j * sqrt (1 - x * x))\n    \ndef atan (x):\n    return 0.5j * log ((1j + x) / (1j - x))\n\ndef sinh (x):\n    return 0.5 * (exp (x) - exp (-x))\n\ndef cosh (x):\n    return 0.5 * (exp (x) + exp (-x))\n\ndef tanh (x):\n    return (exp (x) - exp (-x)) / (exp (x) + exp (-x))\n\ndef asinh (x):\n    return log (x + sqrt (1 + x * x))\n\ndef acosh (x):\n    return log (x + sqrt (-1 + x * x))\n    \ndef atanh (x):\n    return 0.5 * log ((1 + x) / (1 - x))\n\n__pragma__ ('noopov')\n\ndef isinf (x):\n    return x.real == js_Infinite or x.imag == js.Infinite\n\ndef isfinite (x):\n    return not isinf (x)\n\ndef isnan (x):\n    return js_isNaN (x.real) or js_isNaN (x.imag)\n    ",
		"    __nest__ (\n        __all__,\n        'itertools', {\n            __all__: {\n                __inited__: false,\n                __init__: function (__all__) {\n__pragma__ ('ifdef', '__esv6__')\n                    var count = function* (start, step) {\n                        if (start == undefined) {\n                            start = 0;\n                        }\n                        if (step == undefined) {\n                            step = 1;\n                        }\n                        while (true) {\n                            yield start;\n                            start += step;\n                        }\n                    }\n                    var cycle = function* (iterable) {                      \n                        let buffer = Array.from (iterable); // Can't reset, Chrome can't obtain iter from gener\n                        while (true) {\n                            for (let item of buffer) {\n                                yield item;\n                            }\n                        }\n                    }\n                    var repeat = function* (item, n) {\n                        if (typeof n == 'undefined') {\n                            while (true) {\n                                yield item;\n                            }\n                        }\n                        else {\n                            for (let index = 0; index < n; index++) {\n                                yield item;\n                            }\n                        }\n                    }\n                    var accumulate = function* (iterable, func) {\n                        let sum;\n                        let first = true;\n                        if (func) {\n                            for (let item of iterable) {\n                                if (first) {\n                                    sum = item;\n                                    first = false;\n                                }\n                                else {\n                                    sum = func (sum, item);\n                                }\n                                yield sum;\n                            }\n                        }\n                        else {\n                            for (let item of iterable) {\n                                if (first) {\n                                    sum = item;\n                                    first = false;\n                                }\n                                else {\n                                    sum = sum + item;\n                                }\n                                yield sum;\n                            }\n                        }\n                    }\n                    var chain = function* () {\n                        let args = [] .slice.apply (arguments);                         \n                        for (let arg of args) {\n                            for (let item of arg) {\n                                yield item;\n                            }\n                        }\n                    }\n                    chain.from_iterable = function* (iterable) {                        \n                        for (let item of iterable) {\n                            for (let subItem of item) {\n                                yield subItem;\n                            }\n                        }\n                    }\n                    var compress = function* (data, selectors) {\n                        let dataIterator = data [Symbol.iterator] .call (data);\n                        let selectorsIterator = selectors [Symbol.iterator] ();\n                        while (true) {\n                            let dataItem = dataIterator.next ();\n                            let selectorsItem = selectorsIterator.next ();\n                            if (dataItem.done || selectorsItem.done) {\n                                break;\n                            }\n                            else {\n                                if (selectorsItem.value) {\n                                    yield dataItem.value;\n                                }\n                            }\n                        }\n                    }\n                    var dropwhile = function* (pred, seq) {\n                        let started = false;\n                        for (let item of seq) {\n                            if (started) {\n                                yield item;\n                            }\n                            else if (!pred (item)) {\n                                started = true;\n                                yield item;\n                            }\n                        }\n                    }\n                    var filterfalse = function* (pred, seq) {\n                        for (let item of seq) {\n                            if (!pred (item)) {\n                                yield item;\n                            }\n                        }\n                    }\n                    var groupby = function* (iterable, keyfunc) {\n                        let anIterator = iterable [Symbol.iterator] ();\n                        let item = anIterator.next ();\n                        \n                        if (item.done) {\n                            return;\n                        }\n                        \n                        let groupKey = keyfunc (item.value);\n                        let more = true;\n                        \n                        function* group () {\n                            while (true) {\n                                yield (item.value);\n                                item = anIterator.next ();\n                                \n                                if (item.done) {\n                                    more = false;\n                                    return;\n                                }\n                                \n                                let key = keyfunc (item.value);\n                                \n                                if (key != groupKey) {\n                                    groupKey = key;\n                                    return;\n                                }\n                            }\n                        }\n                        \n                        while (more) {\n                            yield tuple ([groupKey, group ()]);\n                        }\n                    }\n                    \n                    var islice = function* () {\n                        let start;  // Have to be defined at function level, or Closure compiler will loose them after a yield \n                        let stop;   //\n                        let step;   //\n                        \n                        let args = [] .slice.apply (arguments);\n                        let anIterator = args [0][Symbol.iterator] ();\n                        if (args.length == 2) {\n                            stop = args [1];\n                            start = 0;\n                            step = 1;\n                        }\n                        else {\n                            start = args [1];\n                            stop = args [2];\n                            if (args.length == 4) {\n                                step = args [3];\n                            }\n                            else {\n                                step = 1;\n                            }\n                        }\n                        for (let index = 0; index < start; index++) {\n                            if (anIterator.next (). done) {\n                                return;\n                            }\n                        }\n                        for (let index = 0; index < stop - start; index++) {\n                            let next = anIterator.next ();\n                            if (next.done) {\n                                return;\n                            }\n                            if (index % step == 0) {\n                                yield next.value;\n                            }\n                        }\n                    }\n                    var starmap = function* (func, seq) {\n                        let anIterator = seq [Symbol.iterator] ();\n                        while (true) {\n                            let next = anIterator.next ()\n                            if (next.done) {\n                                return;\n                            }\n                            else {\n                                yield func (...next.value); \n                            }\n                        }\n                    }\n                    var takewhile = function* (pred, seq) {\n                        for (let item of seq) {\n                            if (pred (item)) {\n                                yield item;\n                            }\n                            else {\n                                return;\n                            }\n                        }\n                    }\n                    var tee = function (iterable, n) {\n                        if (n == undefined) {\n                            n = 2;\n                        }\n                        let all = [];                               // Don't return iterator since destructuring assignment cannot yet deal with that\n                        let one = list (iterable);\n                        for (let i = 0; i < n; i++) {\n                            all.append (one [Symbol.iterator] ());  // Iterator rather than list, exhaustable for semantic equivalence\n                        }\n                        return list (all);\n                    }\n                    \n                    var product = function () {\n                        let args = [] .slice.apply (arguments);\n                        if (args.length && args [args.length - 1] .hasOwnProperty ('__kwargtrans__')) {\n                            var repeat = args.pop () ['repeat']; \n                        }\n                        else {\n                            var repeat = 1;\n                        }\n                        \n                        let oldMolecules = [tuple ([])];\n                        for (let i = 0; i < repeat; i++) {\n                            for (let arg of args) {\n                                let newMolecules = [];\n                                for (let oldMolecule of oldMolecules) {\n                                    for (let atom of arg) {\n                                        newMolecules.append (tuple (oldMolecule.concat (atom)));\n                                    }\n                                }\n                                oldMolecules = newMolecules;\n                            }\n                        }\n                        return list (oldMolecules); // Also works if args is emptpy\n                    }\n                    var permutations = function (iterable, r) {\n                        if (r == undefined) {\n                            try {\n                                r = len (iterable);\n                            }\n                            catch (exception) {\n                                r = len (list (iterable));\n                            }\n                        }\n                        let aProduct = product (iterable, __kwargtrans__ ({repeat: r}));\n                        let result = [];\n                        for (let molecule of aProduct) {\n                            if (len (set (molecule)) == r) {    // Weed out doubles\n                                result.append (molecule);\n                            }\n                        }\n                        return list (result);\n                    }\n                    var combinations = function (iterable, r) {\n                        let tail = list (iterable);\n                        function recurse (tail, molecule, rNext) {\n                            for (let index = 0; index < len (tail) - rNext; index++) {\n                                let newMolecule = molecule.concat (tail.slice (index, index + 1));\n\n                                if (rNext) {\n                                    recurse (tail.slice (index + 1), newMolecule, rNext - 1);\n                                }\n                                else {\n                                    result.append (tuple (newMolecule));\n                                }\n                            }\n                        }\n                        let result = [];\n                        recurse (tail, tail.slice (0, 0), r - 1);\n                        return list (result);\n                    }\n                    var combinations_with_replacement = function (iterable, r) {\n                        let tail = list (iterable);\n                        function recurse (tail, molecule, rNext) {\n                            for (let index = 0; index < len (tail); index++) {\n                                let newMolecule = molecule.concat (tail.slice (index, index + 1));\n\n                                if (rNext) {\n                                    recurse (tail.slice (index), newMolecule, rNext - 1);\n                                }\n                                else {\n                                    result.append (tuple (newMolecule));\n                                }\n                            }\n                        }\n                        let result = [];\n                        recurse (tail, tail.slice (0, 0), r - 1);\n                        return list (result);\n                    }\n__pragma__ ('else')\n                    var chain = function () {\n                        var args = [] .slice.apply (arguments);\n                        var result = [];\n                        for (var index = 0; index < args.length; index++) {\n                            result = result.concat (args [index]);\n                        }\n                        return list (result);\n                    }\n__pragma__ ('endif')\n                    //<all>\n__pragma__ ('ifdef', '__esv6__')\n                    __all__.count = count;\n                    __all__.cycle = cycle;\n                    __all__.repeat = repeat;\n                    __all__.accumulate = accumulate;\n                    __all__.chain = chain;\n                    __all__.compress = compress;\n                    __all__.dropwhile = dropwhile;\n                    __all__.filterfalse = filterfalse;\n                    __all__.groupby = groupby;\n                    __all__.islice = islice;\n                    __all__.starmap = starmap;\n                    __all__.takewhile = takewhile;\n                    __all__.tee = tee;\n                    __all__.product = product;\n                    __all__.permutations = permutations;\n                    __all__.combinations = combinations;\n                    __all__.combinations_with_replacement = combinations_with_replacement;\n__pragma__ ('else')\n                    __all__.chain = chain;\n__pragma__ ('endif')\n                    //</all>\n                }\n            }\n        }\n    );\n",
		"pi = Math.PI\ne = Math.E\n\nexp = Math.exp\n\ndef expm1 (x):      # IE workaround\n    return Math.exp (x) - 1\n\ndef log (x, base):\n    return Math.log (x) if base is js_undefined else Math.log (x) / Math.log (base)\n\ndef log1p (x):      # IE workaround\n    return Math.log (x + 1)\n\ndef log2 (x):       # IE workaround\n    return Math.log (x) / Math.LN2\n    \ndef log10 (x):      # IE workaround\n    return Math.log (x) / Math.LN10\n\npow = Math.pow\nsqrt = Math.sqrt\n\nsin = Math.sin\ncos = Math.cos\ntan = Math.tan\n\nasin = Math.asin\nacos = Math.acos\natan = Math.atan\natan2 = Math.atan2\n\nhypot = Math.hypot\n    \ndef degrees (x):\n    return x * 180 / Math.PI\n    \ndef radians (x):\n    return x * Math.PI / 180\n    \nsinh = Math.sinh\ncosh = Math.cosh\ntanh = Math.tanh\n\nasinh = Math.asinh\nacosh = Math.acosh\natanh = Math.atanh\n\nfloor = Math.floor\nceil = Math.ceil\ntrunc = Math.trunc\n\nisnan = js_isNaN\n\ninf = js_Infinity\nnan = js_NaN\n",
		"# For performance reasons, real arrays or scalars and complex arrays can only be mixed in a limited way\n# In general real arrays in natural order are fastest\n# Real arrays in non-natural order are slower\n# Complex arrays are slowest\n\nfrom org.transcrypt.stubs.browser import __pragma__\n    \n__pragma__ ('skip')\nInt32Array = Float32Array = Float64Array = Array = 0\n__pragma__ ('noskip')\n    \nimport itertools\n\nns_ctors = {\n    'int32': Int32Array,\n    'float32': Float32Array,\n    'float64': Float64Array,\n}\n\ndef ns_complex (dtype):\n    return dtype in ('complex64', 'complex128')\n\ndef ns_buffertype (dtype):\n    return (\n            'float32'\n        if dtype == 'complex64' else\n            'float64'\n        if dtype == 'complex128' else\n            dtype\n    )\n    \ndef ns_complextype (dtype):\n    return (\n            'complex64'\n        if dtype == 'float32' else\n            'complex128'\n        if dtype == 'float64' else\n            None\n    )\n    \ndef ns_createbuf (imag, dtype, size):\n    # The buffer will truly be created if it is the real part of a matrix or if that matrix is complex\n    # So if the matrix is real and the buffer isn't the real part, it will not be created\n    return (\n            __new__ (ns_ctors [ns_buffertype (dtype)] (size))\n        if not imag or ns_complex (dtype) else\n            None\n    )\n    \nclass ndarray:\n    def __init__ (\n        self,\n        shape,\n        dtype,\n        \n        # Any fully constructed real array instance will have realbuf != None, imagbuf == None\n        # Any fully constructed complex array instance will have realbuf != None, imagbuf != None\n        realbuf = None,\n        imagbuf = None\n    ):\n        self.dtype = dtype\n        self.ns_complex = ns_complex (dtype)\n        \n        self.realbuf = realbuf\n        if self.ns_complex:\n            self.imagbuf = imagbuf\n            \n        self.setshape (shape)\n        \n    def setshape (self, shape):\n        self.shape = shape\n        self.ndim = shape.length\n        self.ns_nrows = shape [0]\n        \n        if self.ndim == 1:\n            self.size = self.ns_nrows\n        else:\n            self.ns_ncols = shape [1]\n            self.size = self.ns_nrows * self.ns_ncols\n        \n    def astype (self, dtype):   # Do not use to convert between real and complex arrays\n        result = empty (self.shape, dtype)\n        \n        result.realbuf.set (self.realbuf)\n        if self.ns_complex:\n            result.imagbuf.set (self.imagbuf)\n            \n        return result\n                        \n    def tolist (self):\n        if self.ns_complex:\n            flat = [complex (real, imag) for real, imag in zip (list (self.realbuf), list (self.imagbuf))]\n        else:\n            flat = self.realbuf\n            \n        if self.ndim == 1:\n            return list (flat)\n        else:\n            return [[flat [self.ns_ncols * irow + icol] for icol in range (self.ns_ncols)] for irow in range (self.ns_nrows)]\n                    \n    def __repr__ (self):\n        return 'array({})'.format (repr (self.tolist ()))\n\n    def __str__ (self):\n        if self.ndim == 1:\n            return str (self.tolist ())\n        else:\n            return '[\\n\\t{}\\n]\\n'.format ('\\n\\t'.join ([str (row) for row in self.tolist ()]))\n        \n    def reshape (self, shape):\n        if self.ndim == 1:\n            return array (self, self.dtype),\n        else:\n            result = array (self, self.dtype)\n            result.setshape (self.ns_ncols, self.ns_nrows)\n            return result\n            \n    def transpose (self):\n        if self.ndim == 1:\n            result = array (self, dtype)\n        else:\n            result = empty ((self.ns_ncols, self.ns_nrows), self.dtype)\n                \n            itarget = 0\n            if self.ns_complex:\n                for icol in range (self.ns_ncols):\n                    isource = icol\n                    for irow in range (self.ns_nrows):\n                        isource = self.ns_ncols * irow + icol\n                        result.imagbuf [itarget] = self.imagbuf [isource]\n                        result.realbuf [__postinc__ (itarget)] = self.realbuf [isource]\n                        isource += self.ns_ncols\n            else:\n                for icol in range (self.ns_ncols):\n                    isource = icol\n                    for irow in range (self.ns_nrows):\n                        result.realbuf [__postinc__ (itarget)] = self.realbuf [isource]\n                        isource += self.ns_ncols\n                    \n        return result\n                \n    def __getitem__ (self, key):\n        if self.ndim == 1:          \n            if type (key) == tuple:\n                # Slice of single dim array\n\n                if key [1] == None:\n                    key [1] = self.size\n                elif key [1] < 0:\n                    key [1] += self.size\n                \n                result = empty ([(key [1] - key [0]) / key [2]], self.dtype)\n                \n                itarget = 0\n                if self.ns_complex:\n                    for isource in range (*self.shape):\n                        result.realbuf [itarget] = self.realbuf [isource]\n                        result.imagbuf [__postinc__ (itarget)] = self.imagbuf [isource]\n                else:\n                    for isource in range (*self.shape):\n                        result.realbuf [__postinc__ (itarget)] = self.realbuf [isource]\n                \n                return result\n            else:\n                # Element of single dim array\n            \n                if self.ns_complex:\n                    return complex (self.realbuf [key], self.imagbuf [key])\n                else:\n                    return self.realbuf [key]\n        else:\n            rowkey = key [0]\n            colkey = key [1]\n            \n            rowistup = type (rowkey) == tuple\n            colistup = type (colkey) == tuple\n            \n            if rowistup:\n                if rowkey [1] == None:\n                    rowkey [1] = self.ns_nrows\n                elif rowkey [1] < 0:\n                    rowkey [1] += self.ns_nrows\n                    \n            if colistup:\n                if colkey [1] == None:\n                    colkey [1] = self.ns_ncols\n                elif colkey [1] < 0:\n                    colkey [1] += self.ns_ncols\n            \n            if rowistup or colistup:\n                # Slice of multidim array\n            \n                if not rowistup:\n                    result = empty (((colkey [1] - colkey [0]) / colkey [2], ), self.dtype)\n                    \n                    itarget = 0\n                    if self.ns_complex:\n                        for isourcecol in range (*colkey):\n                            isource = self.ns_ncols * rowkey + isourcecol\n                            result.realbuf [itarget] = self.realbuf [isource]\n                            result.imagbuf [__postinc__ (itarget)] = self.imagbuf [isource]\n                    else:\n                        for isourcecol in range (*colkey):\n                            result.realbuf [__postinc__ (itarget)] = self.realbuf [self.ns_ncols * rowkey + isourcecol]\n                elif not colistup:\n                    result = empty (((rowkey [1] - rowkey [0]) / rowkey [2], ), self.dtype)\n                    \n                    itarget = 0\n                    if self.ns_complex:\n                        for isourcerow in range (*rowkey):\n                            isource = self.ns_ncols * isourcerow + colkey\n                            result.realbuf [itarget] = self.realbuf [isource]\n                            result.imagbuf [__postinc__ (itarget)] = self.imagbuf [isource]\n                    else:\n                        for isourcerow in range (*rowkey):\n                            result.realbuf [__postinc__ (itarget)] = self.realbuf [self.ns_ncols * isourcerow + colkey]\n                else:\n                    result = empty ((\n                        (key[0][1] - key[0][0]) / key [0][2],\n                        (key[1][1] - key[1][0]) / key [1][2]\n                    ), self.dtype)\n                                \n                    itarget = 0\n                    if self.ns_complex:\n                        for isourcerow in range (*rowkey):\n                            for isourcecol in range (*colkey):\n                                isource = self.ns_ncols * isourcerow + isourcecol\n                                result.realbuf [itarget] = self.realbuf [isource]\n                                result.imagbuf [__postinc__ (itarget)] = self.imagbuf [isource]                         \n\n                    else:\n                        for isourcerow in range (*rowkey):\n                            for isourcecol in range (*colkey):\n                                result.realbuf [__postinc__ (itarget)] = self.realbuf [self.ns_ncols * isourcerow + isourcecol]\n                            \n                return result\n            else:\n                # Element of multi dim array\n            \n                if self.ns_complex:\n                    isource = self.ns_ncols * key [0] + key [1]\n                    return complex (self.realbuf [isource], self.imagbuf [isource])\n                else:\n                    return self.realbuf [self.ns_ncols * key [0] + key [1]]\n                    \n    def __setitem__ (self, key, value):\n        if self.ndim == 1:      \n            if type (key) == tuple:\n                # Slice of single dim array\n                \n                if key [1] == None:\n                    key [1] = self.size\n                elif key [1] < 0:\n                    key [1] += self.size\n                \n                isource = 0\n                if self.ns_complex:\n                    for itarget in range (*self.shape):\n                        self.realbuf [itarget] = value.realbuf [isource]\n                        self.imagbuf [itarget] = value.imagbuf [__postinc__ (isource)]\n                else:\n                    for itarget in range (*self.shape):\n                        self.realbuf [itarget] = value.realbuf [__postinc__ (isource)]\n                \n                return result\n            else:\n                # Element of single dim array\n                \n                if self.ns_complex:\n                    if __typeof__ (value) == 'number':\n                        self.realbuf [key] = value\n                        self.imagbuf [key] = 0\n                    else:                   \n                        self.realbuf [key] = value.real\n                        self.imagbuf [key] = value.imag\n                else:\n                    self.realbuf [key] = value\n        else:\n            rowkey = key [0]\n            colkey = key [1]\n            \n            rowistup = type (rowkey) == tuple\n            colistup = type (colkey) == tuple\n            \n            if rowistup:\n                if rowkey [1] == None:\n                    rowkey [1] = self.ns_nrows\n                elif rowkey [1] < 0:\n                    rowkey [1] += self.ns_nrows\n                    \n            if colistup:\n                if colkey [1] == None:\n                    colkey [1] = self.ns_ncols\n                elif colkey [1] < 0:\n                    colkey [1] += self.ns_ncols\n                    \n            if rowistup or colistup:\n                # Slice of multi dim array\n                \n                if not rowistup:            \n                    isource = 0\n                    if self.ns_complex:\n                        for itargetcol in range (*colkey):\n                            itarget = self.ns_ncols * rowkey + itargetcol\n                            self.realbuf [itarget] = value.realbuf [isource]\n                            self.imagbuf [itarget] = value.imagbuf [__postinc__ (isource)]\n                    else:\n                        for itargetcol in range (*colkey):\n                            result.realbuf [self.ns_ncols * rowkey + itargetcol] = self.realbuf [__postinc__ (isource)]\n                elif not colistup:\n                    isource = 0\n                    if self.ns_complex:\n                        for itargetrow in range (*rowkey):\n                            itarget = self.ns_ncols * itargetrow + colkey\n                            self.realbuf [itarget] = value.realbuf [isource]\n                            self.imagbuf [itarget] = value.imagbuf [__postinc__ (isource)]\n                    else:\n                        for isourcerow in range (*rowkey):\n                            self.realbuf [self.ns_ncols * isourcerow + colkey] = value [__postinc__ (isource)]\n                else:           \n                    isource = 0\n                    if self.ns_complex:\n                        for itargetrow in range (*rowkey):\n                            for itargetcol in range (*colkey):\n                                itarget = self.ns_ncols * itargetrow + itargetcol\n                                self.realbuf [itarget] = value.realbuf [isource]\n                                self.imagbuf [itarget] = value.imagbuf [__postinc__ (isource)]                          \n                    else:\n                        for isourcerow in range (*rowkey):\n                            for isourcecol in range (*colkey):\n                                self.realbuf [self.ns_ncols * itargetrow + itargetcol] = value.realbuf [__postinc__ (isource)]                      \n            else:\n                # Element of multi dim array\n                \n                if self.ns_complex:\n                    itarget = self.ns_ncols * key [0] + key [1]\n                    \n                    if __typeof__ (value) == 'number':\n                        self.realbuf [itarget] = value\n                        self.imagbuf [itarget] = 0\n                    else:\n                        self.realbuf [itarget] = value.real\n                        self.imagbuf [itarget] = value.imag\n                    \n                else:\n                    self.realbuf [self.ns_ncols * key [0] + key [1]] = value\n              \n    def real (self):    # Returns a view, so you can assign to self via it\n        return ndarray (self.shape, ns_buffertype (self.dtype), self.realbuf)\n    \n    def imag (self):    # Returns a view, so you can assign self via it\n        return ndarray (self.shape, ns_buffertype (self.dtype), self.imagbuf)\n        \n    def __conj__ (self):\n        if self.ns_complex:\n            result = empty (self.shape, self.dtype)\n            result.realbuf.set (self.realbuf)\n            result.imagbuf = ns_createbuf (True, self.dtype, self.size)\n            for i in range (self.size):\n                result.imagbuf [i] = -self.imagbuf [i]\n            return result\n        else:\n            return copy (self)\n        \n    def conjugate (self):\n        return self.__conj__ ()\n        \n    def __neg__ (self):\n        result = empty (self.shape, self.dtype)\n        if self.ns_complex:\n            for i in range (self.size):\n                result.realbuf [i] = -self.realbuf [i]\n                result.imagbuf [i] = -self.imagbuf [i]\n        else:\n            for i in range (self.size):\n                result.realbuf [i] = -self.realbuf [i]\n            \n        return result   \n            \n    def __ns_inv__ (self):\n        result = empty (self.shape, self.dtype)\n            \n        if self.ns_complex:\n            for i in range (self.size):\n                real = self.realbuf [i]\n                imag = self.imagbuf [i]\n                denom = real * real + imag * imag\n                \n                result.realbuf [i] = real / denom\n                result.imagbuf [i] = -imag / denom\n        else:\n            for i in range (self.size):\n                result.realbuf [i] = 1 / self.realbuf [i]\n            \n        return result   \n            \n    def __add__ (self, other):\n        result = empty (self.shape, self.dtype)\n        \n        if type (other) == ndarray:\n            if self.ns_complex:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] + other.realbuf [i]\n                    result.imagbuf [i] = self.imagbuf [i] + other.imagbuf [i]\n            else:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] + other.realbuf [i]\n        else:\n            if self.ns_complex:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] + other.real\n                    result.imagbuf [i] = self.imagbuf [i] + other.imag\n            else:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] + other\n                    \n        return result\n        \n    def __radd__ (self, scalar):    # scalar + array -> array.__radd__ (scalar)\n        return self.__add__ (scalar)\n        \n    def __sub__ (self, other):\n        result = empty (self.shape, self.dtype)\n        \n        if type (other) == ndarray:\n            if self.ns_complex:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] - other.realbuf [i]\n                    result.imagbuf [i] = self.imagbuf [i] - other.imagbuf [i]\n            else:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] - other.realbuf [i]\n        else:\n            if self.ns_complex:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] - other.real\n                    result.imagbuf [i] = self.imagbuf [i] - other.imag\n            else:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] - other\n                    \n        return result\n        \n    def __rsub__ (self, scalar):    # scalar - array -> array.__rsub__ (scalar)\n        return self.__neg__ () .__add__ (scalar)\n        \n    def __mul__ (self, other):\n        result = empty (self.shape, self.dtype)\n        \n        if type (other) == ndarray:\n            if self.ns_complex:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] * other.realbuf [i] - self.imagbuf [i] * other.imagbuf [i]\n                    result.imagbuf [i] = self.realbuf [i] * other.imagbuf [i] + self.imagbuf [i] * other.realbuf [i]\n            else:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] * other.realbuf [i]\n        else:\n            if self.ns_complex:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] * other.real - self.imagbuf [i] * other.imag\n                    result.imagbuf [i] = self.realbuf [i] * other.imag + self.imagbuf [i] * other.real\n            else:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] * other\n                    \n        return result\n        \n    def __rmul__ (self, scalar):    # scalar * array -> array.__rmul__ (scalar)\n        return self.__mul__ (scalar)\n        \n    def __div__ (self, other):\n        result = empty (self.shape, self.dtype)\n        \n        if type (other) == ndarray:\n            if self.ns_complex:\n                for i in range (self.size):\n                    real = other.realbuf [i]\n                    imag = other.imagbuf [i]\n                    denom = real * real + imag * imag\n                \n                    result.realbuf [i] = (self.realbuf [i] * real + self.imagbuf [i] * imag) / denom\n                    result.imagbuf [i] = (self.imagbuf [i] * real - self.realbuf [i] * imag) / denom\n            else:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] / other.realbuf [i]\n        else:\n            if self.ns_complex:\n                real = other.real\n                imag = other.imag\n                denom = real * real + imag * imag\n                \n                for i in range (self.size):\n                    result.realbuf [i] = (self.realbuf [i] * real + self.imagbuf [i] * imag) / denom\n                    result.imagbuf [i] = (self.imagbuf [i] * real - self.realbuf [i] * imag) / denom\n            else:\n                for i in range (self.size):\n                    result.realbuf [i] = self.realbuf [i] / other\n                    \n        return result\n        \n    def __rdiv__ (self, scalar):    # scalar / array -> array.__rdiv__ (scalar)\n        return self.__ns_inv__ () .__mul__ (scalar)\n        \n    def __matmul__ (self, other):\n        result = empty ((self.ns_nrows, other.ns_ncols), self.dtype)\n        \n        if self.ns_complex:\n            iresult = 0\n            for irow in range (self.ns_nrows):\n                for icol in range (other.ns_ncols):\n                    result.realbuf [iresult] = 0\n                    result.imagbuf [iresult] = 0\n                    iself = self.ns_ncols * irow\n                    iother = icol\n                    for iterm in range (self.ns_ncols):\n                        result.realbuf [iresult] += self.realbuf [iself] * other.realbuf [iother] - self.imagbuf [iself] * other.imagbuf [iother]\n                        result.imagbuf [iresult] += self.realbuf [iself] * other.imagbuf [iother] + self.imagbuf [__postinc__ (iself)] * other.realbuf [iother]\n                        iother += other.ns_ncols\n                    iresult += 1\n        else:\n            iresult = 0\n            for irow in range (self.ns_nrows):\n                for icol in range (other.ns_ncols):\n                    result.realbuf [iresult] = 0\n                    iself = self.ns_ncols * irow\n                    iother = icol\n                    for iterm in range (self.ns_ncols):\n                        result.realbuf [iresult] += self.realbuf [__postinc__ (iself)] * other.realbuf [iother]\n                        iother += other.ns_ncols\n                    iresult += 1\n            \n        return result\n        \ndef empty (shape, dtype = 'float64'):\n    result = ndarray (\n        shape,\n        dtype\n    )\n    result.realbuf = ns_createbuf (False, dtype, result.size)\n    result.imagbuf = ns_createbuf (True, dtype, result.size)\n    return result\n    \ndef array (obj, dtype = 'float64'): \n    if Array.isArray (obj):\n        if len (obj):\n            if Array.isArray (obj [0]):\n                result = empty ((obj.length, obj [0] .length), dtype)\n                iresult = 0\n                if result.ns_complex:\n                    for irow in range (result.ns_nrows):\n                        for icol in range (result.ns_ncols):\n                            element = complex (obj [irow][icol])\n                            result.realbuf [iresult] = element.real\n                            result.imagbuf [__postinc__ (iresult)] = element.imag\n                else:\n                    for irow in range (result.ns_nrows):\n                        for icol in range (result.ns_ncols):\n                            result.realbuf [__postinc__ (iresult)] = obj [irow][icol]\n            else:\n                result = empty ((obj.length, ), dtype)\n                if result.ns_complex:\n                    for i in range (result.size):\n                        element = complex (obj [i])\n                        result.realbuf [i] = element.real \n                        result.imagbuf [i] = element.imag\n                else:\n                    for i in range (result.size):\n                        result.realbuf [i] = obj [i]\n        else:\n            result = empty ((0, ), dtype)\n    else:   # Assume obj is an ndarray        \n        result = empty (obj.shape, obj.dtype)\n        result.realbuf.set (obj.realbuf)        \n        if obj.ns_complex:\n            result.imagbuf.set (obj.imagbuf)       \n    return result\n        \ndef copy (obj):\n    return array (obj, obj.dtype)\n    \ndef hsplit (ary, nparts):\n    result = [empty ((ary.ns_nrows, ary.ns_ncols / nparts), ary.dtype) for ipart in range (nparts)]\n    \n    isource = 0\n    if ary.ns_complex:\n        for irow in range (ary.ns_nrows):\n            for part in result:\n                itarget = part.ns_ncols * irow\n                for icol in range (part.ns_ncols):\n                    part.realbuf [itarget] = ary.realbuf [isource]\n                    part.imagbuf [__postinc__ (itarget)] = ary.imagbuf [__postinc__ (isource)]\n    else:\n        for irow in range (ary.ns_nrows):\n            for part in result:\n                itarget = part.ns_ncols * irow\n                for icol in range (part.ns_ncols):\n                    part.realbuf [__postinc__ (itarget)] = ary.realbuf [__postinc__ (isource)]\n                    \n    return result\n    \ndef vsplit (ary, nparts):\n    result = [empty ((ary.ns_nrows / nparts, ary.ns_ncols), array.dtype) for ipart in range (nparts)]\n\n    isource = 0\n    if ary.ns_complex:\n        for part in result:\n            for itarget in range (part.size):\n                part.realbuf [itarget] = ary.realbuf [isource]\n                part.imagbuf [itarget] = ary.imagbuf [__postinc__ (isource)]\n    else:\n        for part in result:\n            for itarget in range (part.size):\n                part.realbuf [itarget] = ary.realbuf [__postinc__ (isource)]\n                    \n    return result\n    \ndef hstack (tup):\n    ncols = 0\n    for part in tup:\n        ncols += part.ns_ncols\n                \n    result = empty ((tup [0] .ns_nrows, ncols), tup [0] .dtype)\n    \n    itarget = 0\n    if result.ns_complex:\n        for irow in range (result.ns_nrows):\n            for part in tup:\n                isource = part.ns_ncols * irow\n                for icol in range (part.ns_ncols):\n                    result.realbuf [itarget] = part.realbuf [isource]\n                    result.imagbuf [__postinc__ (itarget)] = part.imagbuf [__postinc__ (isource)]\n    else:\n        for irow in range (result.ns_nrows):\n            for part in tup:\n                isource = part.ns_ncols * irow\n                for icol in range (part.ns_ncols):\n                    result.realbuf [__postinc__ (itarget)] = part.realbuf [__postinc__ (isource)]\n                \n    return result\n    \ndef vstack (tup):\n    nrows = 0\n    for part in tup:\n        nrows += part.ns_nrows\n        \n    result = empty ((nrows, tup [0].ns_ncols), tup [0] .dtype)\n    \n    itarget = 0\n    if result.ns_complex:\n        for part in tup:\n            for isource in range (part.size):\n                result.realbuf [itarget] = part.realbuf [isource]\n                result.imagbuf [__postinc__ (itarget)] = part.imagbuf [isource]\n    else:\n        for part in tup:\n            for isource in range (part.size):\n                result.realbuf [__postinc__ (itarget)] = part.realbuf [isource]\n                \n    return result\n            \ndef round (a, decimals = 0):    # Truncation rather than bankers rounding, for speed\n    result = empty (a.shape, a.dtype)\n\n    if a.ns_complex:\n        for i in range (a.size):\n            result.realbuf [i] = a.realbuf [i] .toFixed (decimals)\n            result.imagbuf [i] = a.imagbuf [i] .toFixed (decimals)\n    else:\n        for i in range (a.size):\n            result.realbuf [i] = a.realbuf [i] .toFixed (decimals)\n        \n    return result\n        \ndef zeros (shape, dtype = 'float64'):\n    result = empty (shape, dtype)\n\n    if result.ns_complex:\n        for i in range (result.size):\n            result.realbuf [i] = 0\n            result.imagbuf [i] = 0\n    else:\n        for i in range (result.size):\n            result.realbuf [i] = 0\n            \n    return result\n    \ndef ones (shape, dtype = 'float64'):\n    result = empty (shape, dtype)\n    \n    if result.ns_complex:\n        for i in range (result.size):\n            result.realbuf [i] = 1\n            result.imagbuf [i] = 0\n    else:\n        for i in range (result.size):\n            result.realbuf [i] = 1\n            \n    return result\n    \ndef identity (n, dtype = 'float64'):\n    result = zeros ((n, n), dtype)\n    \n    i = 0\n    shift = n + 1\n    for j in range (n):\n        result.realbuf [i] = 1\n        i += shift\n    \n    return result\n    \ndef conjugate (x):\n    return x.__conj__ ()\n        \n",
		"import numscrypt as ns\nimport numscrypt.linalg.eigen_mpmath as eigen\n\ndef inv (a):\n\t# Work directly with flat data atoms in natural order speeds up by factor 70 (!)\n\tif a.ns_complex:\n\t\treturn cinv (a)\n\telse:\n\t\treturn rinv (a)\n\ndef rinv (a):\n\t# Leave original matrix intact\n\tb = ns.hstack ((a, ns.identity (a.shape [0], a.dtype)))\t# b will always have natural order\n\treal = b.realbuf\n\tnrows, ncols = b.shape\n\t\n\t# Use each row of the matrix as pivot row\\n\n\tfor ipiv in range (nrows):\n\n\t\t# Swap rows if needed to get a nonzero pivot\n\t\tif not real [ipiv * ncols + ipiv]:\n\t\t\tfor irow in range (ipiv + 1, nrows):\n\t\t\t\tif real [irow * ncols + ipiv]:\n\t\t\t\t\tfor icol in range (ncols):\n\t\t\t\t\t\ttemp = real [irow * ncols + icol]\n\t\t\t\t\t\treal [irow * ncols + icol] = b [ipiv * ncols + icol]\n\t\t\t\t\t\treal [ipiv * ncols + icol] = temp\n\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\n\t\t# Make pivot element 1\n\t\tpiv = real [ipiv * ncols + ipiv]\n\t\tfor icol in range (ipiv, ncols):\n\t\t\treal [ipiv * ncols + icol] /= piv\n\t\t\t\n\t\t# Sweep other rows to get all zeroes in pivot column\n\t\tfor irow in range (nrows):\n\t\t\tif irow != ipiv:\n\t\t\t\tfactor = real [irow * ncols + ipiv]\n\t\t\t\tfor icol in range (ncols):\n\t\t\t\t\treal [irow * ncols + icol] -= factor * real [ipiv * ncols + icol]\n\t\t\t\t\t\n\t# Chop of left matrix, return right matrix\n\treturn ns.hsplit (b, 2)[1]\n\t\ndef cinv (a):\t# for speed, don't use 'complex' or operator overloading\n\t# Leave original matrix intact\n\tb = ns.hstack ((a, ns.identity (a.shape [0], a.dtype)))\t# b will always have natural order\n\t\n\treal = b.realbuf\n\timag = b.imagbuf\n\tnrows, ncols = b.shape\n\t\n\t# Use each row of the matrix as pivot row\\n\n\tfor ipiv in range (nrows):\n\t\tipiv_flat = ipiv * ncols + ipiv\n\t\t\n\t\t# Swap rows if needed to get a nonzero pivot\n\t\tif not (real [ipiv_flat] or imag [ipiv_flat]):\n\t\t\tfor irow in range (ipiv + 1, nrows):\n\t\t\t\tiswap = irow * ncols + ipiv\n\t\t\t\tif real [iswap] or imag [iswap]:\n\t\t\t\t\tfor icol in range (ncols):\n\t\t\t\t\t\tisource = irow * ncols + icol\n\t\t\t\t\t\titarget = ipiv * ncols + icol\n\t\t\t\t\t\t\n\t\t\t\t\t\ttemp = real [isource]\n\t\t\t\t\t\treal [isource] = real [itarget]\n\t\t\t\t\t\treal [itarget] = temp\n\t\t\t\t\t\t\n\t\t\t\t\t\ttemp = imag [isource_flat]\n\t\t\t\t\t\timag [isource] = imag [itarget]\n\t\t\t\t\t\timag [itarget] = temp\n\t\t\t\t\tbreak\n\t\t\n\t\t# Make pivot element 1\n\t\tpivre = real [ipiv_flat]\n\t\tpivim = imag [ipiv_flat]\n\t\t\n\t\tdenom = pivre * pivre + pivim * pivim\n\t\t\n\t\tfor icol in range (ipiv, ncols):\n\t\t\ticur = ipiv * ncols + icol\n\t\t\t\n\t\t\toldre = real [icur]\n\t\t\toldim = imag [icur]\n\n\t\t\treal [icur] = (oldre * pivre + oldim * pivim) / denom\t\t\t\n\t\t\timag [icur] = (oldim * pivre - oldre * pivim) / denom\n\t\t\n\t\t# Sweep other rows to get all zeroes in pivot column\n\t\tfor irow in range (nrows):\n\t\t\tif irow != ipiv: \n\t\t\t\tifac = irow * ncols + ipiv\n\t\t\t\tfacre = real [ifac]\n\t\t\t\tfacim = imag [ifac]\n\t\t\t\tfor icol in range (ncols):\n\t\t\t\t\titarget = irow * ncols + icol\n\t\t\t\t\tisource = ipiv * ncols + icol\n\t\t\t\t\t\n\t\t\t\t\toldre = real [isource]\n\t\t\t\t\toldim = imag [isource]\n\t\t\t\t\t\n\t\t\t\t\treal [itarget] -= (facre * oldre - facim * oldim)\n\t\t\t\t\timag [itarget] -= (facre * oldim + facim * oldre)\n\t\t\t\t\t\n\t# Chop of left matrix, return right matrix\n\treturn ns.hsplit (b, 2)[1]\n                    \ndef norm (a):\n    result = 0\n    \n    if a.ns_complex:\n        for i in range (a.size):\n            result += a.realbuf [i] * a.realbuf [i] + a.imagbuf [i] * a.imagbuf [i]\n    else:\n        for i in range (a.size):\n            result += a.realbuf [i] * a.realbuf [i]\n            \n    return Math.sqrt (result)\n    \ndef eig (a):    # Everything presumed complex for now\n    evals, evecs = eigen.eig (a)\n    \n    nrows, ncols = evecs.shape\n    real = evecs.realbuf\n    imag = evecs.imagbuf\n    \n    for icol in range (ncols):\n        sum = 0\n        \n        for irow in range (nrows):\n            iterm = irow * ncols + icol\n            sum += (real [iterm] * real [iterm] + imag [iterm] * imag [iterm])\n            \n        norm = Math.sqrt (sum)\n            \n        for irow in range (nrows):\n            iterm = irow * ncols + icol\n            real [iterm] /= norm\n            imag [iterm] /= norm\n            \n    return ns.array (evals, 'complex64'), evecs\n    ",
		"##################################################################################################\n#\n# This module is an adaptation for Numscrypt and Transcrypt of mpmath.matrix.eigen.py\n#\n# The whole of mpmath is distributed under the New or Revised BSD 3-clause License:\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#   a. Redistributions of source code must retain the above copyright notice,\n#      this list of conditions and the following disclaimer.\n#   b. Redistributions in binary form must reproduce the above copyright\n#      notice, this list of conditions and the following disclaimer in the\n#      documentation and/or other materials provided with the distribution.\n#   c. Neither the name of mpmath nor the names of its contributors\n#      may be used to endorse or promote products derived from this software\n#      without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR\n# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n# DAMAGE.\n#\n# The following copyrights are relevant:\n#\n# Copyright (C) 2005-2017 Fredrik Johansson and mpmath contributors\n# (w.r.t. the mpmath library as a whole)\n#\n# Copyright (C) 2013 Timo Hartmann, mpmath contributor (thartmann15 at gmail.com)\n# (w.r.t the original module for the eigenvalue problem)\n#\n# Copyright (C) 2017 Jacques de Hooge (jdeh@transcrypt.org)\n# (w.r.t. the adaptation for Numscrypt and Transcrypt)\n#\n##################################################################################################\n\n# __pragma__ ('opov')\n\n# BEGIN compatibility stuff\n\nfrom math import *\nimport cmath\nfrom numscrypt import *\n\ndef isinf (x):  # !!! Todo\n    return False\n    \ndef hypot (x, y):\n    return sqrt (x * x + y * y)\n    \nctx_eps = 1e-15\nctx_dps = 15\n    \nctx_one = 1\nctx_prec = 53\n\ndef ctx_ldexp (x, n):\n    return x * 2**n\n\n# END compatibility stuff\n    \n\"\"\"\nThe eigenvalue problem\n----------------------\n\nThis file contains routines for the eigenvalue problem.\n\nhigh level routines:\n\n  hessenberg : reduction of a real or complex square matrix to upper Hessenberg form\n  schur : reduction of a real or complex square matrix to upper Schur form\n  eig : eigenvalues and eigenvectors of a real or complex square matrix\n\nlow level routines:\n\n  hessenberg_reduce_0 : reduction of a real or complex square matrix to upper Hessenberg form\n  hessenberg_reduce_1 : auxiliary routine to hessenberg_reduce_0\n  qr_step : a single implicitly shifted QR step for an upper Hessenberg matrix\n  hessenberg_qr : Schur decomposition of an upper Hessenberg matrix\n  eig_tr_r : right eigenvectors of an upper triangular matrix\n  eig_tr_l : left  eigenvectors of an upper triangular matrix\n\"\"\"\n\ndef hessenberg_reduce_0(A, T):\n    \"\"\"\n    This routine computes the (upper) Hessenberg decomposition of a square matrix A.\n    Given A, an unitary matrix Q is calculated such that\n\n               Q' A Q = H              and             Q' Q = Q Q' = 1\n\n    where H is an upper Hessenberg matrix, meaning that it only contains zeros\n    below the first subdiagonal. Here ' denotes the hermitian transpose (i.e.\n    transposition and conjugation).\n\n    parameters:\n      A         (input/output) On input, A contains the square matrix A of\n                dimension (n,n). On output, A contains a compressed representation\n                of Q and H.\n      T         (output) An array of length n containing the first elements of\n                the Householder reflectors.\n    \"\"\"\n\n    # internally we work with householder reflections from the right.\n    # let u be a row vector (i.e. u[i]=A[i,:i]). then\n    # Q is build up by reflectors of the type (1-v'v) where v is a suitable\n    # modification of u. these reflectors are applyed to A from the right.\n    # because we work with reflectors from the right we have to start with\n    # the bottom row of A and work then upwards (this corresponds to\n    # some kind of RQ decomposition).\n    # the first part of the vectors v (i.e. A[i,:(i-1)]) are stored as row vectors\n    # in the lower left part of A (excluding the diagonal and subdiagonal).\n    # the last entry of v is stored in T.\n    # the upper right part of A (including diagonal and subdiagonal) becomes H.\n    \n    n = A.shape[0]\n    if n <= 2: return\n\n    for i in range(n-1, 1, -1):\n        \n        # scale the vector\n\n        scale = 0\n        for k in range(i):\n            scale += abs(A[i,k].real) + abs(A[i,k].imag)\n\n        scale_inv = 0\n        if scale != 0:\n            scale_inv = 1 / scale\n            \n        if scale == 0 or isinf(scale_inv):\n            # sadly there are floating point numbers not equal to zero whose reciprocal is infinity\n            T[i] = 0\n            A[i,i-1] = 0\n            continue\n\n        # calculate parameters for housholder transformation\n\n        H = 0\n        for k in range(i):\n            A[i,k] *= scale_inv\n            rr = A[i,k].real\n            ii = A[i,k].imag\n            H += rr * rr + ii * ii\n\n        F = A[i,i-1]\n        f = abs(F)\n        G = cmath.sqrt(H)\n        A[i,i-1] = - G * scale\n        \n        if f == 0:\n            T[i] = G\n        else:\n            ff = F / f\n            T[i] = F + G * ff\n            A[i,i-1] *= ff\n\n        H += G * f\n        H = 1 / cmath.sqrt(H)\n        \n        T[i] *= H\n        for k in range(i - 1):\n            A[i,k] *= H\n        \n        for j in range(i):\n            # apply housholder transformation (from right)\n\n            G = T[i].conjugate() * A[j,i-1]\n\n            \n            for k in range(i-1):\n                G += A[i,k].conjugate() * A[j,k]\n\n                \n            A[j,i-1] -= G * T[i]\n            for k in range(i-1):\n                A[j,k] -= G * A[i,k]\n\n        \n        for j in range(n):\n            # apply housholder transformation (from left)\n\n            G = T[i] * A[i-1,j]\n            for k in range(i-1):\n                G += A[i,k] * A[k,j]\n\n            A[i-1,j] -= G * T[i].conjugate()\n            for k in range(i-1):\n                A[k,j] -= G * A[i,k].conjugate()\n\ndef hessenberg_reduce_1(A, T):\n    \"\"\"\n    This routine forms the unitary matrix Q described in hessenberg_reduce_0.\n\n    parameters:\n      A    (input/output) On input, A is the same matrix as delivered by\n           hessenberg_reduce_0. On output, A is set to Q.\n\n      T    (input) On input, T is the same array as delivered by hessenberg_reduce_0.\n    \"\"\"\n\n    n = A.shape[0]\n\n    if n == 1:\n        A[0,0] = 1\n        return\n\n    A[0,0] = A[1,1] = 1\n    A[0,1] = A[1,0] = 0\n\n    for i in range(2, n):\n        if T[i] != 0:     # !!! Conversion shouldn't be needed\n\n            for j in range(i):\n                G = T[i] * A[i-1,j]\n                for k in range(i-1):\n                    G += A[i,k] * A[k,j]\n\n                A[i-1,j] -= G * T[i].conjugate()\n                for k in range(i-1):\n                    A[k,j] -= G * A[i,k].conjugate()\n\n        A[i,i] = 1\n        for j in range(i):\n            A[j,i] = A[i,j] = 0\n\n            \ndef hessenberg(A, overwrite_a = False):\n    \"\"\"\n    This routine computes the Hessenberg decomposition of a square matrix A.\n    Given A, an unitary matrix Q is determined such that\n\n          Q' A Q = H                and               Q' Q = Q Q' = 1\n\n    where H is an upper right Hessenberg matrix. Here ' denotes the hermitian\n    transpose (i.e. transposition and conjugation).\n\n    input:\n      A            : a real or complex square matrix\n      overwrite_a  : if true, allows modification of A which may improve\n                     performance. if false, A is not modified.\n\n    output:\n      Q : an unitary matrix\n      H : an upper right Hessenberg matrix\n\n    example:\n      >>> from mpmath import mp\n      >>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])\n      >>> Q, H = mp.hessenberg(A)\n      >>> mp.nprint(H, 3) # doctest:+SKIP\n      [  3.15  2.23  4.44]\n      [-0.769  4.85  3.05]\n      [   0.0  3.61   7.0]\n      >>> print(mp.chop(A - Q * H * Q.transpose_conj()))\n      [0.0  0.0  0.0]\n      [0.0  0.0  0.0]\n      [0.0  0.0  0.0]\n\n    return value:   (Q, H)\n    \"\"\"\n\n    n = A.shape[0]\n\n    if n == 1:\n        return (array([[1]], A.dtype), A)\n\n    if not overwrite_a:\n        A = copy (A)\n\n    T = empty((n,), A.dtype) # !!! n, 1 -> n\n\n    hessenberg_reduce_0(A, T)\n    Q = copy (A.copy)\n    hessenberg_reduce_1(Q, T)\n\n    for x in range(n):\n        for y in range(x+2, n):\n            A[y,x] = 0\n\n    return Q, A\n\n\n###########################################################################\n\n\ndef qr_step(n0, n1, A, Q, shift):\n    \"\"\"\n    This subroutine executes a single implicitly shifted QR step applied to an\n    upper Hessenberg matrix A. Given A and shift as input, first an QR\n    decomposition is calculated:\n\n      Q R = A - shift * 1 .\n\n    The output is then following matrix:\n\n      R Q + shift * 1\n\n    parameters:\n      n0, n1    (input) Two integers which specify the submatrix A[n0:n1,n0:n1]\n                on which this subroutine operators. The subdiagonal elements\n                to the left and below this submatrix must be deflated (i.e. zero).\n                following restriction is imposed: n1>=n0+2\n      A         (input/output) On input, A is an upper Hessenberg matrix.\n                On output, A is replaced by \"R Q + shift * 1\"\n      Q         (input/output) The parameter Q is multiplied by the unitary matrix\n                Q arising from the QR decomposition. Q can also be false, in which\n                case the unitary matrix Q is not computed.\n      shift     (input) a complex number specifying the shift. idealy close to an\n                eigenvalue of the bottemmost part of the submatrix A[n0:n1,n0:n1].\n\n    references:\n      Stoer, Bulirsch - Introduction to Numerical Analysis.\n      Kresser : Numerical Methods for General and Structured Eigenvalue Problems\n    \"\"\"\n\n    # implicitly shifted and bulge chasing is explained at p.398/399 in \"Stoer, Bulirsch - Introduction to Numerical Analysis\"\n    # for bulge chasing see also \"Watkins - The Matrix Eigenvalue Problem\" sec.4.5,p.173\n\n    # the Givens rotation we used is determined as follows: let c,s be two complex\n    # numbers. then we have following relation:\n    #\n    #     v = sqrt(|c|^2 + |s|^2)\n    #\n    #     1/v [ c~  s~]  [c] = [v]\n    #         [-s   c ]  [s]   [0]\n    #\n    # the matrix on the left is our Givens rotation.\n    \n    n = A.shape[0]\n\n    # first step\n\n    # calculate givens rotation\n    c = A[n0  ,n0] - shift\n    s = A[n0+1,n0]\n\n    v = hypot(hypot(c.real, c.imag), hypot(s.real, s.imag))\n\n    if v == 0:\n        v = 1\n        c = 1\n        s = 0\n    else:\n        c /= v\n        s /= v\n\n    for k in range(n0, n):\n        # apply givens rotation from the left\n        x = A[n0  ,k]\n        y = A[n0+1,k]\n\n        A[n0  ,k] = c.conjugate() * x + s.conjugate() * y\n        A[n0+1,k] =           -s  * x +            c  * y\n    \n    for k in range(min(n1, n0+3)):\n        # apply givens rotation from the right\n        x = A[k,n0  ]\n        y = A[k,n0+1]\n        A[k,n0  ] =             c  * x +            s  * y\n        A[k,n0+1] = -s.conjugate() * x + c.conjugate() * y\n\n    if not isinstance(Q, bool):\n        for k in range(n):\n            # eigenvectors\n            x = Q[k,n0  ]\n            y = Q[k,n0+1]\n            Q[k,n0  ] =             c  * x +            s  * y\n            Q[k,n0+1] = -s.conjugate() * x + c.conjugate() * y\n\n    # chase the bulge\n    \n    for j in range(n0, n1 - 2):\n        # calculate givens rotation\n\n        c = A[j+1,j]\n        s = A[j+2,j]\n\n        v = hypot(hypot(c.real, c.imag), hypot(s.real, s.imag))\n\n        if v == 0:\n            A[j+1,j] = 0\n            v = 1\n            c = 1\n            s = 0\n        else:\n            A[j+1,j] = v\n            c /= v\n            s /= v\n\n        A[j+2,j] = 0\n    \n        for k in range(j+1, n):\n            # apply givens rotation from the left\n            x = A[j+1,k]\n            y = A[j+2,k]\n            A[j+1,k] = c.conjugate() * x + s.conjugate() * y\n            A[j+2,k] =           -s  * x +            c  * y\n    \n        for k in range(min(n1, j+4)):\n            # apply givens rotation from the right\n            x = A[k,j+1]\n            y = A[k,j+2]\n            A[k,j+1] =             c  * x +            s  * y\n            A[k,j+2] = -s.conjugate() * x + c.conjugate() * y\n    \n        if not isinstance(Q, bool):\n            for k in range(n):\n                # eigenvectors\n                x = Q[k,j+1]\n                y = Q[k,j+2]\n                Q[k,j+1] =             c  * x +            s  * y\n                Q[k,j+2] = -s.conjugate() * x + c.conjugate() * y\n\n\n\ndef hessenberg_qr(A, Q):\n    \"\"\"\n    This routine computes the Schur decomposition of an upper Hessenberg matrix A.\n    Given A, an unitary matrix Q is determined such that\n\n          Q' A Q = R                   and                  Q' Q = Q Q' = 1\n\n    where R is an upper right triangular matrix. Here ' denotes the hermitian\n    transpose (i.e. transposition and conjugation).\n\n    parameters:\n      A         (input/output) On input, A contains an upper Hessenberg matrix.\n                On output, A is replace by the upper right triangluar matrix R.\n\n      Q         (input/output) The parameter Q is multiplied by the unitary\n                matrix Q arising from the Schur decomposition. Q can also be\n                false, in which case the unitary matrix Q is not computated.\n    \"\"\"\n\n    n = A.shape[0]\n\n    norm = 0\n    for x in range(n):\n        for y in range(min(x+2, n)):\n            norm += A[y,x].real * A[y,x].real + A[y,x].imag * A[y,x].imag\n    norm = sqrt(norm) / n\n    \n    if norm == 0:\n        return\n\n    n0 = 0\n    n1 = n\n\n    eps = ctx_eps / (100 * n)\n    \n    maxits = ctx_dps * 4\n\n    its = totalits = 0                           \n\n    while True:\n        # kressner p.32 algo 3\n        # the active submatrix is A[n0:n1,n0:n1]\n\n        k = n0\n        \n        while k + 1 < n1:\n            s = abs(A[k,k].real) + abs(A[k,k].imag) + abs(A[k+1,k+1].real) + abs (A[k+1,k+1].imag)\n\n            if s < eps * norm:\n                s = norm              \n                \n            if abs(A[k+1,k]) < eps * s:\n                break\n            k += 1\n     \n        if k + 1 < n1:\n            # deflation found at position (k+1, k)\n\n            A[k+1,k] = 0  # !!! Make this unneeded, the complex, that is\n            n0 = k + 1\n\n            its = 0\n\n            if n0 + 1 >= n1:\n                # block of size at most two has converged\n                n0 = 0\n                n1 = k + 1\n                if n1 < 2:\n                    # QR algorithm has converged\n                    return\n        else:\n            if (its % 30) == 10:\n                # exceptional shift\n                shift = A[n1-1,n1-2]\n            elif (its % 30) == 20:\n                # exceptional shift\n                shift = abs(A[n1-1,n1-2])\n            elif (its % 30) == 29:\n                # exceptional shift\n                shift = norm\n            else:\n                \n                #    A = [ a b ]       det(x-A)=x*x-x*tr(A)+det(A)\n                #        [ c d ]\n                #\n                # eigenvalues bad:   (tr(A)+sqrt((tr(A))**2-4*det(A)))/2\n                #     bad because of cancellation if |c| is small and |a-d| is small, too.\n                #\n                # eigenvalues good:     (a+d+sqrt((a-d)**2+4*b*c))/2\n\n                t =  A[n1-2,n1-2] + A[n1-1,n1-1]\n                s = (A[n1-1,n1-1] - A[n1-2,n1-2]) ** 2 + 4 * A[n1-1,n1-2] * A[n1-2,n1-1]\n                if s.real > 0:\n                    s = cmath.sqrt(s)\n                else:\n                    s = cmath.sqrt(-s) * 1j\n                a = (t + s) / 2\n                b = (t - s) / 2\n                if abs(A[n1-1,n1-1] - a) > abs(A[n1-1,n1-1] - b):\n                    shift = b\n                else:\n                    shift = a\n\n            its += 1\n            totalits += 1\n\n            qr_step(n0, n1, A, Q, shift)\n            \n            if its > maxits:\n                raise RuntimeError(\"qr: failed to converge after %d steps\" % its)\n\ndef schur(A, overwrite_a = False):\n    \"\"\"\n    This routine computes the Schur decomposition of a square matrix A.\n    Given A, an unitary matrix Q is determined such that\n\n          Q' A Q = R                and               Q' Q = Q Q' = 1\n\n    where R is an upper right triangular matrix. Here ' denotes the\n    hermitian transpose (i.e. transposition and conjugation).\n\n    input:\n      A            : a real or complex square matrix\n      overwrite_a  : if true, allows modification of A which may improve\n                     performance. if false, A is not modified.\n\n    output:\n      Q : an unitary matrix\n      R : an upper right triangular matrix\n\n    return value:   (Q, R)\n\n    example:\n      >>> from mpmath import mp\n      >>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])\n      >>> Q, R = mp.schur(A)\n      >>> mp.nprint(R, 3) # doctest:+SKIP\n      [2.0  0.417  -2.53]\n      [0.0    4.0  -4.74]\n      [0.0    0.0    9.0]\n      >>> print(mp.chop(A - Q * R * Q.transpose_conj()))\n      [0.0  0.0  0.0]\n      [0.0  0.0  0.0]\n      [0.0  0.0  0.0]\n\n    warning: The Schur decomposition is not unique.\n    \"\"\"\n\n    n = A.shape[0]\n\n    if n == 1:\n        return (array([[1]], A.dtype), A)\n\n    if not overwrite_a:\n        A = copy (A)\n\n    T = empty((n,), A.dtype) # !!! n, 1 -> n\n\n    hessenberg_reduce_0(A, T)\n    Q = copy (A)\n    hessenberg_reduce_1(Q, T)\n\n    for x in range(n):\n        for y in range(x + 2, n):\n            A[y,x] = 0\n\n    hessenberg_qr(A, Q)\n\n    return Q, A\n\n\ndef eig_tr_r(A):\n    \"\"\"\n    This routine calculates the right eigenvectors of an upper right triangular matrix.\n\n    input:\n      A      an upper right triangular matrix\n\n    output:\n      ER     a matrix whose columns form the right eigenvectors of A\n\n    return value: ER\n    \"\"\"\n\n    # this subroutine is inspired by the lapack routines ctrevc.f,clatrs.f\n\n    n = A.shape[0] \n    \n    ER = identity(n, A.dtype)\n\n    eps = ctx_eps\n\n    unfl = ctx_ldexp(ctx_one, -ctx_prec * 30)\n    # since mpmath effectively has no limits on the exponent, we simply scale doubles up\n    # original double has prec*20\n\n    smlnum = unfl * (n / eps)\n    simin = 1 / sqrt(eps)\n\n    rmax = 1\n\n    for i in range(1, n):\n        s = A[i,i]\n\n        smin = max(eps * abs(s), smlnum)\n\n        for j in range(i - 1, -1, -1):\n\n            r = 0\n            for k in range(j + 1, i + 1):\n                r += A[j,k] * ER[k,i]\n\n            t = A[j,j] - s\n            if abs(t) < smin:\n                t = smin\n\n            r = -r / t\n            \n            ER[j,i] = r\n\n            rmax = max(rmax, abs(r))\n            if rmax > simin:\n                for k in range(j, i+1):\n                    ER[k,i] /= rmax\n                rmax = 1\n\n        if rmax != 1:\n            for k in range(i + 1):\n                ER[k,i] /= rmax\n\n    return ER\n\ndef eig_tr_l(A):\n    \"\"\"\n    This routine calculates the left eigenvectors of an upper right triangular matrix.\n\n    input:\n      A      an upper right triangular matrix\n\n    output:\n      EL     a matrix whose rows form the left eigenvectors of A\n\n    return value:  EL\n    \"\"\"\n\n    n = A.shape[0]\n\n    EL = identity(n, A.dtype)\n\n    eps = ctx_eps\n\n    unfl = ctx_ldexp(ctx_one, -ctx_prec * 30)\n    # since mpmath effectively has no limits on the exponent, we simply scale doubles up\n    # original double has prec*20\n\n    smlnum = unfl * (n / eps)\n    simin = 1 / cmath.sqrt(eps)\n\n    rmax = 1\n\n    for i in range(n - 1):\n        s = A[i,i]\n\n        smin = max(eps * abs(s), smlnum)\n\n        for j in range(i + 1, n):\n\n            r = 0\n            for k in range(i, j):\n                r += EL[i,k] * A[k,j]\n\n            t = A[j,j] - s\n            if abs(t) < smin:\n                t = smin\n\n            r = -r / t\n            EL[i,j] = r\n\n            rmax = max(rmax, abs(r))\n            if rmax > simin:\n                for k in range(i, j + 1):\n                    EL[i,k] /= rmax\n                rmax = 1\n\n        if rmax != 1:\n            for k in range(i, n):\n                EL[i,k] /= rmax\n\n    return EL\n\ndef eig(A, left = False, right = True, overwrite_a = False):\n    \"\"\"\n    This routine computes the eigenvalues and optionally the left and right\n    eigenvectors of a square matrix A. Given A, a vector E and matrices ER\n    and EL are calculated such that\n\n                        A ER[:,i] =         E[i] ER[:,i]\n                EL[i,:] A         = EL[i,:] E[i]\n\n    E contains the eigenvalues of A. The columns of ER contain the right eigenvectors\n    of A whereas the rows of EL contain the left eigenvectors.\n\n\n    input:\n      A           : a real or complex square matrix of shape (n, n)\n      left        : if true, the left eigenvectors are calulated.\n      right       : if true, the right eigenvectors are calculated.\n      overwrite_a : if true, allows modification of A which may improve\n                    performance. if false, A is not modified.\n\n    output:\n      E    : a list of length n containing the eigenvalues of A.\n      ER   : a matrix whose columns contain the right eigenvectors of A.\n      EL   : a matrix whose rows contain the left eigenvectors of A.\n\n    return values:\n       E            if left and right are both false.\n      (E, ER)       if right is true and left is false.\n      (E, EL)       if left is true and right is false.\n      (E, EL, ER)   if left and right are true.\n\n\n    examples:\n      >>> from mpmath import mp\n      >>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])\n      >>> E, ER = mp.eig(A)\n      >>> print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))\n      [0.0]\n      [0.0]\n      [0.0]\n\n      >>> E, EL, ER = mp.eig(A,left = True, right = True)\n      >>> E, EL, ER = mp.eig_sort(E, EL, ER)\n      >>> mp.nprint(E)\n      [2.0, 4.0, 9.0]\n      >>> print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))\n      [0.0]\n      [0.0]\n      [0.0]\n      >>> print(mp.chop( EL[0,:] * A - EL[0,:] * E[0]))\n      [0.0  0.0  0.0]\n\n    warning:\n     - If there are multiple eigenvalues, the eigenvectors do not necessarily\n       span the whole vectorspace, i.e. ER and EL may have not full rank.\n       Furthermore in that case the eigenvectors are numerical ill-conditioned.\n     - In the general case the eigenvalues have no natural order.\n\n    see also:\n      - eigh (or eigsy, eighe) for the symmetric eigenvalue problem.\n      - eig_sort for sorting of eigenvalues and eigenvectors\n    \"\"\"\n\n    n = A.shape[0]\n\n    if n == 1:\n        if left and (not right):\n            return ([A[0]], array([[1]], A.dtype))\n\n        if right and (not left):\n            return ([A[0]], array([[1]], A.dtype))\n\n        return ([A[0]], array([[1]], A.dtype), array([[1]], A.dtype))\n\n    if not overwrite_a:\n        A = copy (A)\n\n    T = zeros((n,), 'complex64')\n\n    hessenberg_reduce_0(A, T)\n\n    if left or right:\n        Q = copy (A)\n        hessenberg_reduce_1(Q, T) \n    else:\n        Q = False\n        \n            \n    for x in range(n):\n        for y in range(x + 2, n):\n            A[y,x] = 0\n\n    hessenberg_qr(A, Q)\n    \n    E = [A[i,i] for i in range(n)]\n\n    if not (left or right):\n        return E\n\n    if left:\n        EL = eig_tr_l(A)\n        EL = EL @ Q.conjugate().transpose()\n\n    if right:\n        ER = eig_tr_r(A)\n        ER = Q @ ER\n\n    if left and (not right):\n        return (E, EL)\n\n    if right and (not left):\n        return (E, ER)\n\n    return (E, EL, ER)\n\n'''\ndef eig_sort(ctx, E, EL = False, ER = False, f = \"real\"):\n    \"\"\"\n    This routine sorts the eigenvalues and eigenvectors delivered by ``eig``.\n\n    parameters:\n      E  : the eigenvalues as delivered by eig\n      EL : the left  eigenvectors as delivered by eig, or false\n      ER : the right eigenvectors as delivered by eig, or false\n      f  : either a string (\"real\" sort by increasing real part, \"imag\" sort by\n           increasing imag part, \"abs\" sort by absolute value) or a function\n           mapping complexes to the reals, i.e. ``f = lambda x: -mp.re(x) ``\n           would sort the eigenvalues by decreasing real part.\n\n    return values:\n       E            if EL and ER are both false.\n      (E, ER)       if ER is not false and left is false.\n      (E, EL)       if EL is not false and right is false.\n      (E, EL, ER)   if EL and ER are not false.\n\n    example:\n      >>> from mpmath import mp\n      >>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])\n      >>> E, EL, ER = mp.eig(A,left = True, right = True)\n      >>> E, EL, ER = mp.eig_sort(E, EL, ER)\n      >>> mp.nprint(E)\n      [2.0, 4.0, 9.0]\n      >>> E, EL, ER = mp.eig_sort(E, EL, ER,f = lambda x: -mp.re(x))\n      >>> mp.nprint(E)\n      [9.0, 4.0, 2.0]\n      >>> print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))\n      [0.0]\n      [0.0]\n      [0.0]\n      >>> print(mp.chop( EL[0,:] * A - EL[0,:] * E[0]))\n      [0.0  0.0  0.0]\n    \"\"\"\n\n    if isinstance(f, str):  #!!! No idea...\n        if f == \"real\":\n            f = ctx.re\n        elif f == \"imag\":\n            f = ctx.im\n        elif cmp == \"abs\":\n            f = abs\n        else:\n            raise RuntimeError(\"unknown function %s\" % f)\n\n    n = len(E)\n\n    # Sort eigenvalues (bubble-sort)\n\n    for i in range(n):\n        imax = i\n        s = f(E[i])         # s is the current maximal element\n\n        for j in range(i + 1, n):\n            c = f(E[j])\n            if c < s:\n                s = c\n                imax = j\n\n        if imax != i:\n            # swap eigenvalues\n\n            z = E[i]\n            E[i] = E[imax]\n            E[imax] = z\n\n            if not isinstance(EL, bool):\n                for j in range(n):\n                    z = EL[i,j]\n                    EL[i,j] = EL[imax,j]\n                    EL[imax,j] = z\n\n            if not isinstance(ER, bool):\n                for j in range(n):\n                    z = ER[j,i]\n                    ER[j,i] = ER[j,imax]\n                    ER[j,imax] = z\n\n    if isinstance(EL, bool) and isinstance(ER, bool):\n        return E\n\n    if isinstance(EL, bool) and not(isinstance(ER, bool)):\n        return (E, ER)\n\n    if isinstance(ER, bool) and not(isinstance(EL, bool)):\n        return (E, EL)\n\n    return (E, EL, ER)\n'''\n\n",
		"from org.transcrypt.stubs.browser import *\nfrom org.transcrypt.stubs.browser import __main__, __envir__, __pragma__\n\n# Imports for Transcrypt, resolved run time\nif __envir__.executor_name == __envir__.transpiler_name:\n\timport numscrypt as num\n\timport numscrypt.linalg as linalg\n\n# Imports for CPython, resolved compile time\n__pragma__ ('skip')\nimport numpy as num\nimport numpy.linalg as linalg\nnum.set_printoptions (linewidth = 240)\n__pragma__ ('noskip')\n\n__pragma__ ('opov')\n\ndef show (*args):\n    print (*args)\n\nfor a in (   \n    num.array ([\n        [0, 1j],\n        [-1j, 1]\n    ], 'complex128'),\n    num.array ([\n        [1, -2, 3, 1],\n        [5, 8, -1, -5],\n        [2, 1, 1, 100],\n        [2, 1, -1, 0]\n    ], 'complex128'),\n    num.array ([\n        [1, 1, 0, 0],\n        [0, 2, 2, 0],\n        [0, 0, 3, 3],\n        [0, 0, 0, 4]\n    ], 'complex128'),\n) [1:2]:\n    eVals, eVecs = linalg.eig (a)\n    \n    enumSorted = sorted (\n        enumerate (eVals.tolist ()),\n        key = lambda elem: -(elem [1].real + elem [1].imag / 1000)  # Order on primarily on real, secundarily on imag, note conjugate vals\n    )\n    \n    indicesSorted = [elem [0] for elem in enumSorted]\n    eValsSorted = [elem [1] for elem in enumSorted]\n    \n    eValsMat = num.empty (a.shape, a.dtype)\n    for iRow in range (a.shape [0]):\n        for iCol in range (a.shape [1]):\n            eValsMat [iRow, iCol] = eVals [iCol]\n     \n    eVecsNorms = num.empty ((eVecs.shape [1], ), a.dtype)\n    for iNorm in range (eVecsNorms.shape [0]):\n        eVecsNorms [iNorm] = complex (linalg.norm (eVecs [:, iNorm]))\n        \n    eVecsCanon = num.empty (a.shape, a.dtype)\n    for iRow in range (a.shape [0]):\n        for iCol in range (a.shape [1]):\n            eVecsCanon [iRow, iCol] = eVecs [iRow, iCol] / eVecs [0, iCol] \n        \n    eVecsSorted = num.empty (a.shape, a.dtype)\n    for iRow in range (a.shape [0]):\n        for iCol in range (a.shape [1]):\n            eVecsSorted [iRow, iCol] = eVecsCanon [iRow, indicesSorted [iCol]]\n        \n    show (  '=========================================')\n    '''\n    show ('\\n---------------- a ----------------------')\n    show (a)\n    show ('\\n---------------- eigVals ----------------')\n    show (eVals)\n    show ('\\n---------------- eigValsMat--------------')\n    show (eValsMat)\n    show ('\\n---------------- eigVecs ----------------')\n    show (eVecs)\n    show ('\\n---------------- eigValsMat @ eigVecs ---')\n    show (eValsMat * eVecs)\n    show ('\\n---------------- a @ eigVecs-------------')\n    show (a @ eVecs)\n    show ('\\n---------------- eigVecsNorms -----------')\n    show (eVecsNorms)\n    show ('\\n---------------- eigVecsCanon -----------')\n    show (eVecsCanon)\n    '''\n    show ('\\n---------------- eigVecsSorted ----------')\n    show ([[(round (value.real + 1e-10, 3), round (value.imag + 1e-10, 3)) for value in row] for row in eVecsSorted.tolist ()])\n    show ('\\n---------------- eigValsSorted ----------')\n    show ([(round (value.real + 1e-10, 3), round (value.imag + 1e-10, 3)) for value in eValsSorted], '\\n')\n    show (  '=========================================')\n    \n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAMA;AAAA;AAAA;AAKA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0GA;AAAA;AAUA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC/QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzmDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AAIA;AAAA;AAGA;AACA;AAAA;AAEA;AACA;AAAA;AAIA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAIA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACvDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwsBA;AAxsBA;AAWA;AAEA;AAMA;AACA;AAAA;AAEA;AACA;AAAA;AAQA;AACA;AAAA;AAQA;AAIA;AAAA;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAKA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACxsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAGA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC7IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwzBA;AAxzBA;AA8CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AA0BA;AA+BA;AACA;AAAA;AAAA;AAEA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAGA;AAGA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAGA;AAGA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAWA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAmCA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAMA;AA2CA;AAKA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAIA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAmBA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AAEA;AAEA;AAAA;AAAA;AAEA;AAIA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAEA;AAGA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAAA;AACA;AAEA;AAAA;AACA;AAUA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAqCA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AAAA;AAGA;AAeA;AAEA;AAEA;AAEA;AAIA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAaA;AAEA;AAEA;AAEA;AAIA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+DA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACxzBA;AAAA;AAIA;AACA;AACA;AAAA;AAWA;AAAA;AACA;AAAA;AAaA;AAAA;AAMA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAmBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}