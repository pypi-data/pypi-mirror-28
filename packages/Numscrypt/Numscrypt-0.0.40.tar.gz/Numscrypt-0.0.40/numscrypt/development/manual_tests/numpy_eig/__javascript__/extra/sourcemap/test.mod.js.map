{
	"version": 3,
	"file": "D:/activ_tosh/geatec/Numscrypt/numscrypt/development/manual_tests/numpy_eig/__javascript__/test.mod.js",
	"sources": [
		"D:/activ_tosh/geatec/Numscrypt/numscrypt/development/manual_tests/numpy_eig/test.py"
	],
	"sourcesContent": [
		"from org.transcrypt.stubs.browser import *\nfrom org.transcrypt.stubs.browser import __main__, __envir__, __pragma__\n\n# Imports for Transcrypt, resolved run time\nif __envir__.executor_name == __envir__.transpiler_name:\n\timport numscrypt as num\n\timport numscrypt.linalg as linalg\n\n# Imports for CPython, resolved compile time\n__pragma__ ('skip')\nimport numpy as num\nimport numpy.linalg as linalg\nnum.set_printoptions (linewidth = 240)\n__pragma__ ('noskip')\n\n__pragma__ ('opov')\n\ndef show (*args):\n    print (*args)\n\nfor a in (   \n    num.array ([\n        [0, 1j],\n        [-1j, 1]\n    ], 'complex128'),\n    num.array ([\n        [1, -2, 3, 1],\n        [5, 8, -1, -5],\n        [2, 1, 1, 100],\n        [2, 1, -1, 0]\n    ], 'complex128'),\n    num.array ([\n        [1, 1, 0, 0],\n        [0, 2, 2, 0],\n        [0, 0, 3, 3],\n        [0, 0, 0, 4]\n    ], 'complex128'),\n) [1:2]:\n    eVals, eVecs = linalg.eig (a)\n    \n    enumSorted = sorted (\n        enumerate (eVals.tolist ()),\n        key = lambda elem: -(elem [1].real + elem [1].imag / 1000)  # Order on primarily on real, secundarily on imag, note conjugate vals\n    )\n    \n    indicesSorted = [elem [0] for elem in enumSorted]\n    eValsSorted = [elem [1] for elem in enumSorted]\n    \n    eValsMat = num.empty (a.shape, a.dtype)\n    for iRow in range (a.shape [0]):\n        for iCol in range (a.shape [1]):\n            eValsMat [iRow, iCol] = eVals [iCol]\n     \n    eVecsNorms = num.empty ((eVecs.shape [1], ), a.dtype)\n    for iNorm in range (eVecsNorms.shape [0]):\n        eVecsNorms [iNorm] = complex (linalg.norm (eVecs [:, iNorm]))\n        \n    eVecsCanon = num.empty (a.shape, a.dtype)\n    for iRow in range (a.shape [0]):\n        for iCol in range (a.shape [1]):\n            eVecsCanon [iRow, iCol] = eVecs [iRow, iCol] / eVecs [0, iCol] \n        \n    eVecsSorted = num.empty (a.shape, a.dtype)\n    for iRow in range (a.shape [0]):\n        for iCol in range (a.shape [1]):\n            eVecsSorted [iRow, iCol] = eVecsCanon [iRow, indicesSorted [iCol]]\n        \n    show (  '=========================================')\n    '''\n    show ('\\n---------------- a ----------------------')\n    show (a)\n    show ('\\n---------------- eigVals ----------------')\n    show (eVals)\n    show ('\\n---------------- eigValsMat--------------')\n    show (eValsMat)\n    show ('\\n---------------- eigVecs ----------------')\n    show (eVecs)\n    show ('\\n---------------- eigValsMat @ eigVecs ---')\n    show (eValsMat * eVecs)\n    show ('\\n---------------- a @ eigVecs-------------')\n    show (a @ eVecs)\n    show ('\\n---------------- eigVecsNorms -----------')\n    show (eVecsNorms)\n    show ('\\n---------------- eigVecsCanon -----------')\n    show (eVecsCanon)\n    '''\n    show ('\\n---------------- eigVecsSorted ----------')\n    show ([[(round (value.real + 1e-10, 3), round (value.imag + 1e-10, 3)) for value in row] for row in eVecsSorted.tolist ()])\n    show ('\\n---------------- eigValsSorted ----------')\n    show ([(round (value.real + 1e-10, 3), round (value.imag + 1e-10, 3)) for value in eValsSorted], '\\n')\n    show (  '=========================================')\n    \n"
	],
	"mappings": "AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAWA;AAAA;AACA;AAAA;AAaA;AAAA;AAMA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAmBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}