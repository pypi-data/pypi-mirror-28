{
	"version": 3,
	"file": "D:/activ_tosh/geatec/Numscrypt/numscrypt/development/automated_tests/ndarray/module_linalg/__javascript__/module_linalg.mod.js",
	"sources": [
		"D:/activ_tosh/geatec/Numscrypt/numscrypt/development/automated_tests/ndarray/module_linalg/__init__.py"
	],
	"sourcesContent": [
		"from org.transcrypt.stubs.browser import *\nfrom org.transcrypt.stubs.browser import __main__, __envir__, __pragma__\n\n# Imports for Transcrypt, resolved run time\nif __envir__.executor_name == __envir__.transpiler_name:\n    import numscrypt as num\n    import numscrypt.linalg as linalg\n\n# Imports for CPython, resolved compile time\n__pragma__ ('skip')\nimport numpy as num\nimport numpy.linalg as linalg\nnum.set_printoptions (linewidth = 240)\n__pragma__ ('noskip')\n\ndef run (autoTester):\n    autoTester.check ('====== inverse ======')\n\n    # Real\n\n    r = num.array ([\n        [2.12, -2.11, -1.23], \n        [2.31, 1.14, 3.15], \n        [1.13, 1.98, 2.81]\n    ])\n    \n    autoTester.check ('Matrix r', num.round (r, 2) .tolist (), '<br>')\n    \n    ri = linalg.inv (r)\n    \n    autoTester.check ('Matrix ri', num.round (ri, 2) .tolist (), '<br>')\n    \n    __pragma__ ('opov')\n    rid = r @ ri\n    __pragma__ ('noopov')\n    \n    autoTester.check ('r @ ri', [[int (round (elem)) for elem in row] for row in rid.tolist ()], '<br>')\n    \n    __pragma__ ('opov')\n    delta = 0.001\n    autoTester.check ('r * r', num.round (r * r + delta, 3) .tolist (), '<br>')\n    autoTester.check ('r / r', num.round (r / r + delta, 3) .tolist (), '<br>')\n    autoTester.check ('r + r', num.round (r + r + delta, 3) .tolist (), '<br>')\n    autoTester.check ('r - r', num.round (r - r + delta, 3) .tolist (), '<br>')\n    __pragma__ ('noopov')\n\n    # Complex\n    \n    __pragma__ ('opov')\n    c = num.array ([\n        [2.12 - 3.15j, -2.11, -1.23], \n        [2.31, 1.14, 3.15 + 2.75j], \n        [1.13, 1.98 - 4.33j, 2.81]\n    ], 'complex128')\n    __pragma__ ('noopov')\n    \n    autoTester.check ('Matrix c',  num.round (c, 2) .tolist (), '<br>')\n    \n    ci = linalg.inv (c)\n    \n    autoTester.check ('Matrix ci', num.round (ci, 2) .tolist (), '<br>')\n    \n    __pragma__ ('opov')\n    cid = c @ ci\n    __pragma__ ('noopov')\n    \n    # autoTester.check ('c @ ci', [['{} + j{}'.format (int (round (elem.real)), int (round (elem.imag))) for elem in row] for row in cid.tolist ()], '<br>')\n    \n    __pragma__ ('opov')\n    delta = 0.001 + 0.001j\n    autoTester.check ('c * c', num.round (c * c + delta , 3) .tolist (), '<br>')\n    autoTester.check ('c / c', num.round (c / c + delta, 3) .tolist (), '<br>')\n    autoTester.check ('c + c', num.round (c + c + delta, 3) .tolist (), '<br>')\n    autoTester.check ('c - c', num.round (c - c + delta, 3) .tolist (), '<br>')\n    __pragma__ ('noopov')\n    \n    autoTester.check ('====== eigen ======')\n    \n    __pragma__ ('opov')\n\n    for a in (   \n        num.array ([\n            [0, 1j],\n            [-1j, 1]\n        ], 'complex128'),\n        num.array ([\n            [1, -2, 3, 1],\n            [5, 8, -1, -5],\n            [2, 1, 1, 100],\n            [2, 1, -1, 0]\n        ], 'complex128'),\n    ):\n        eVals, eVecs = linalg.eig (a)\n        \n        enumSorted = sorted (\n            enumerate (eVals.tolist ()),\n            key = lambda elem: -(elem [1].real + elem [1].imag / 1000)  # Order on primarily on real, secundarily on imag, note conjugate vals\n        )\n        \n        indicesSorted = [elem [0] for elem in enumSorted]\n        eValsSorted = [elem [1] for elem in enumSorted]\n        \n        eValsMat = num.empty (a.shape, a.dtype)\n        for iRow in range (a.shape [0]):\n            for iCol in range (a.shape [1]):\n                eValsMat [iRow, iCol] = eVals [iCol]\n         \n        eVecsNorms = num.empty ((eVecs.shape [1], ), a.dtype)\n        for iNorm in range (eVecsNorms.shape [0]):\n            eVecsNorms [iNorm] = complex (linalg.norm (eVecs [:, iNorm]))\n            \n        eVecsCanon = num.empty (a.shape, a.dtype)\n        for iRow in range (a.shape [0]):\n            for iCol in range (a.shape [1]):\n                eVecsCanon [iRow, iCol] = eVecs [iRow, iCol] / eVecs [0, iCol] \n            \n        eVecsSorted = num.empty (a.shape, a.dtype)\n        for iRow in range (a.shape [0]):\n            for iCol in range (a.shape [1]):\n                eVecsSorted [iRow, iCol] = eVecsCanon [iRow, indicesSorted [iCol]]\n            \n        '''\n        autoTester.check ('\\n---------------- a ----------------------')\n        autoTester.check (a)\n        autoTester.check ('\\n---------------- eigVals ----------------')\n        autoTester.check (eVals)\n        autoTester.check ('\\n---------------- eigValsMat--------------')\n        autoTester.check (eValsMat)\n        autoTester.check ('\\n---------------- eigVecs ----------------')\n        autoTester.check (eVecs)\n        autoTester.check ('\\n---------------- eigValsMat @ eigVecs ---')\n        autoTester.check (eValsMat * eVecs)\n        autoTester.check ('\\n---------------- a @ eigVecs-------------')\n        autoTester.check (a @ eVecs)\n        autoTester.check ('\\n---------------- eigVecsNorms -----------')\n        autoTester.check (eVecsNorms)\n        autoTester.check ('\\n---------------- eigVecsCanon -----------')\n        autoTester.check (eVecsCanon)\n        '''\n        autoTester.check ('\\n---------------- eigVecsSorted ----------')\n        autoTester.check ([[(round (value.real + 1e-3, 3), round (value.imag + 1e-3, 3)) for value in row] for row in eVecsSorted.tolist ()])\n        autoTester.check ('\\n---------------- eigValsSorted ----------')\n        autoTester.check ([(round (value.real + 1e-3, 3), round (value.imag + 1e-3, 3)) for value in eValsSorted], '\\n')\n        "
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AASA;AACA;AAIA;AAMA;AAEA;AAEA;AAGA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAMA;AAOA;AAEA;AAEA;AAGA;AAMA;AACA;AACA;AACA;AACA;AAGA;AASA;AAAA;AAKA;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAoBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}