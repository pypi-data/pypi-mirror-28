{
	"version": 3,
	"file": "D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/demos/riot_demo/__javascript__/color.mod.js",
	"sources": [
		"D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/demos/riot_demo/color.py"
	],
	"sourcesContent": [
		"# Producing a linear chain of style defs from a nested declaration of\n# color funcs\nmsgs   = []\nstyles = []\n\ndebug = 0\ndef _recurse(col, g, *s):\n    msgs, styles, hsl = g\n    lu = (('color', 0), ('background-color', 1))\n    hsl = hsl[col]\n    hsl = [hsl[:3], [hsl[0], hsl[1], hsl[3]]]\n    css = ';'.join(\n        [str(i) + ': hsl({}, {}%, {}%)'.format(*hsl[j]) for i, j in lu])\n    for i in s:\n        if debug:\n            styles.append(col)\n        else:\n            styles.append(css)\n\n        # empty string which we are replacing with value below, if not color\n        # function follows\n        msgs.append('%c')\n        try:\n            # can be another color function.. (triggering the recursion)\n            i(g)\n        except:\n            # ... or normal output - in the current color\n            msgs.pop() # TODO: msgs[-1] = ... instead pop() + append\n            msgs.append('%c{}'.format(i))\n\n# offering public, maybe of use. turned in _recurse into [fg, bg]\n# like red=[[0, 100, 90],[0, 100, 50]]\nhsl = {'red'     : [  0, 100, 90, 50],\n       'orange'  : [ 39, 100, 85, 50],\n       'yellow'  : [ 60, 100, 35, 50],\n       'green'   : [120, 100, 60, 25],\n       'blue'    : [240, 100, 90, 50],\n       'purple'  : [300, 100, 85, 25],\n       'black'   : [  0,   0, 80,  0],\n       'gray'    : [237,   8, 80, 50],\n       }\n\n# generating the actual color functions, for each color:\n# right now we only now the color, later msgs and styles buffers:\ndef _col(col): return lambda *parts: lambda g: _recurse(col, g, *parts)\n\n# TODO globals() not yet, so will import this in the clients:\ncolors = {}\n# TODO .keys() currently necessary, should be easy to fix:\nfor col in hsl.keys():\n    colors[col] = _col(col)\n\ndef cprint(*s):\n    msgs, styles = [], []\n    for i in s:\n        i((msgs, styles, hsl))\n    if debug:\n        for i in range(len(msgs)):\n            print (msgs[i], '-> ', styles[i])\n    else:\n        msg = ''.join(msgs)\n        # FIXME this *crazy* eval is required since console.apply\n        # is patched in Transcrypt\n        st = '\", \"'.join(styles)\n        st = ''.join((\"console.log(\\\"\", msg, '\", \"' + st + '\")'))\n        __pragma__('js', '{}', 'eval(st)')\n\n# TODO if __name__ == '__main__' not works, could be cool for quicktests on the\n# server\n#     B, R, G = colors['blue'], colors['red'], colors['green']\n#     cprint(B('b1', 'b2', 'b3', R('r1', G('g2'), G('ga', 'gb'), 'r2'), 'b2'))\n\n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AAEA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAIA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}