{
	"version": 3,
	"file": "D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/demos/riot_demo/__javascript__/riot_tag.mod.js",
	"sources": [
		"D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/demos/riot_demo/riot_tag.py"
	],
	"sourcesContent": [
		"# Parent Class for a Transcrypt Riot Tag\n#\n# This binds the namespace of a riot tag at before-mount event 100% to that of\n# the a transcrypt instance, except members which begin with an underscore, those\n# are private to the transcrypt object.\n#\n# The 4 riot lifecycle events are bound to overwritable python functions.\n#\n# Immutables (strings, ints, ...) are bound to property functions within the tag,\n# so the templates work, based on state in the transcrypt tag.\n# State can be changed in the riot tag as well but take care to not create new\n# references - you won't find them in the Transcrypt tag.\n#\n#\n# Best Practices:\n#  - mutate state only in the transcrypt tag.\n#  - declare all variables so they are bound into the riot tag\n#  - IF you declare new variables to be used in templates, run\n#    self.bind_vars(self.riot_tag)\n# TODO: docstring format not accepted by the transpiler, strange.\n\n__author__ = \"Gunther Klessinger, gk@axiros.com, Germany\"\n\n# just a minihack to get some colors, mainly to test lamdas and imports:\nfrom color import colors, cprint as col_print\nc = colors\nM, I, L, R, B = c['purple'], c['orange'], c['gray'], c['red'], c['black']\n\nlifecycle_ev = ['before-mount', 'mount', 'update', 'unmount']\n\ncur_tag_col = 0\nclass RiotTag:\n    \"\"\"\n    taking care for extending the riot tag obj with\n    functions and immutable(!) properties of derivations of us\n    See counter.\n    \"\"\"\n    debug = None\n    # placeholders:\n    template = '<h1>it worx</h1>'\n    style = ''\n    node_name = 'unmounted'\n    opts = None\n    def __init__(self, tag, opts):\n        # opts into the python instance, why not:\n        self.opts = opts\n        self._setup_tag(tag)\n        # giving ourselves a unique color:\n        global cur_tag_col # working (!)\n        cur_tag_col = (cur_tag_col + 1) % len(colors)\n        # TODO values() on a dict\n        self.my_col = colors.items()[cur_tag_col][1]\n\n    def _setup_tag(self, tag):\n        # keeping mutual refs\n        tag.py_obj = self\n        self.riot_tag = tag\n        # making the event system call self's methods:\n        handlers = {}\n        for ev in lifecycle_ev:\n            f = getattr(self, ev.replace('-', '_'))\n            if f:\n                # this.on('mount', function() {...}):\n                # whats nicer?\n                tag.on(ev, f)\n\n    def pp(self, *msg):\n        # color flash in the console. one color per tag instance.\n        col_print(\n            #B(self.riot_tag._riot_id),\n            L('<', self.my_col(self.node_name, self.my_col), '/> '),\n            M(' '.join([s for s in msg])))\n\n    def _lifecycle_ev(self, mode):\n        if self.debug:\n            self.pp(mode + 'ing')\n\n    # overwrite these for your specific one:\n    def update (self): self._lifecycle_ev('update')\n    def mount  (self): self._lifecycle_ev('mount')\n    def unmount(self): self._lifecycle_ev('unmount')\n\n    def before_mount(self):\n        self._lifecycle_ev('before-mount')\n        return self.bind_vars()\n\n    def bind_vars(self):\n        tag = self.riot_tag\n        self.node_name = tag.root.nodeName.lower()\n        self.debug and self.pp('binding vars')\n        # binding self's functions into the tag instance\n        # binding writable properties to everything else (e.g. ints, strs...)\n        tag._immutables = im = []\n        lc = lifecycle_ev\n        for k in dir(self):\n            # private or lifecycle function? don't bind:\n            if k[0] == '_' or k in lifecycle_ev or k == 'before_mount':\n                continue\n            v = getattr(self, k)\n            # these I can't write in python. Lets use JS then.\n            # TODO there should be, maybe some mocking facility for code\n            # testing w/o a js runtime:\n            __pragma__('js', '{}', '''\n                  typeof v === \"function\" || typeof v === \"object\" ?\n                  tag[k] = self[k] : tag._immutables.push(k)''')\n\n        __pragma__('js', '{}', '''\n        var i = tag._immutables, py = self\n        i.forEach(function(k, j, i) {\n            Object.defineProperty(tag, k, {\n                get: function()  { return self[k]},\n                set: function(v) { self[k] = v }\n            })\n        })''')\n\n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAGA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}