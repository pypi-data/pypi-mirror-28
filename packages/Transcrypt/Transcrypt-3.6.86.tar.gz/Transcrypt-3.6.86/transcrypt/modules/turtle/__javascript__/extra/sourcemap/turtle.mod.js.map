{
	"version": 3,
	"file": "D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/modules/turtle/__javascript__/turtle.mod.js",
	"sources": [
		"D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/modules/turtle/__init__.py"
	],
	"sourcesContent": [
		"__pragma__ ('skip')\ndocument = Math = setInterval = clearInterval = 0\n__pragma__ ('noskip')\n\n_debug = False\n\ndef abs (vec2D):\n    return Math.sqrt (vec2D [0] * vec2D [0] + vec2D [1] * vec2D [1])\n\n_ns = 'http://www.w3.org/2000/svg'\n_svg = document.createElementNS (_ns, 'svg')\n\n_defaultElement = document.getElementById ('__turtlegraph__')\nif not _defaultElement:\n    _defaultElement = document.body\n_defaultElement.appendChild (_svg)\n\n_width = None\n_height = None\n_offset = None\n\ndef _rightSize (self):\n    nonlocal _width\n    nonlocal _height\n    nonlocal _offset\n    \n    _width = _defaultElement.offsetWidth\n    _height = _defaultElement.offsetHeight\n    _offset = [_width // 2, _height // 2]\n    \n    _svg.setAttribute ('width', _width)\n    _svg.setAttribute ('height', _height)\n    \nwindow.onresize = _rightSize\n\n_rightSize ()\n\ndef bgcolor (color):\n    nonlocal _defaultElement\n\n    _bgcolor = color\n    _defaultElement.style.backgroundColor = _bgcolor\n\nbgcolor ('white')\n    \ndef setDefaultElement (element):\n    nonlocal _defaultElement\n\n    _defaultElement.removeChild (_svg)\n    _defaultElement = element\n    element.appendChild (_svg)\n    \n    _rightSize ()\n    bgcolor ('white')\n\n_allTurtles = []\n    \nclass Turtle:\n    def __init__ (self):\n        _allTurtles.append (self)\n        self._paths = []\n        self.reset ()\n        \n    def reset (self):\n        self._heading = Math.PI / 2\n        self.pensize (1)\n        self.color ('black', 'black')\n        self.down ()\n        self._track = []    # Need to make track explicitly because:\n        self.home ()        #   Makes a position but needs a track to put in in\n        self.clear ()       #   Makes a track but needs a position to initialize it with\n        \n    def clear (self):\n        for path in self._paths:\n            _svg.removeChild (path)\n        self._paths = []\n        \n        self._track = []\n        self._moveto (self._position)\n        \n    def _flush (self):\n        if _debug:\n            print ('Flush:', self._track)\n    \n        if len (self._track) > 1:\n            path = document.createElementNS (_ns, 'path')\n            path.setAttribute ('d', ' '.join (self._track))\n            path.setAttribute ('stroke', self._pencolor if self._pencolor != None else 'none')\n            path.setAttribute ('stroke-width', self._pensize)\n            path.setAttribute ('fill', self._fillcolor if self._fill and self._fillcolor != None else 'none')           \n            path.setAttribute ('fill-rule', 'evenodd')\n            _svg.appendChild (path)\n            self._paths.append (path)\n                \n            self._track = []\n            self._moveto (self._position)   # _track should start with a move command\n        \n    def done (self):\n        self._flush ()\n        \n    def pensize (self, width):\n        self._flush ()\n        if width == None:\n            return self._pensize\n        else:\n            self._pensize = width\n    \n    def color (self, pencolor, fillcolor = None):\n        self._flush ()\n        self._pencolor = pencolor\n        \n        if fillcolor != None:\n            self._fillcolor = fillcolor\n    \n    def goto (self, x, y = None):\n        if y == None:\n            self._position = x\n        else:\n            self._position = [x, y]\n            \n        self._track.append ('{} {} {}'.format (\n            'L' if self._down else 'M',\n            self._position [0] + _offset [0],\n            self._position [1] + _offset [1])\n        )\n        \n    def _moveto (self, x, y = None):\n        wasdown = self.isdown ()\n        self.up ()\n        self.goto (x, y)\n        if wasdown:\n            self.down ()\n            \n    def home (self):\n        self._moveto (0, 0)\n        \n    def position (self):\n        return self._position [:]\n        \n    def pos (self):\n        return self.position ()\n        \n    def distance (self, x, y = None):\n        if y == None:\n            other = x\n        else:\n            other = [x, y]\n            \n        dX = other [0] - self._position [0]\n        dY = other [1] - self._position [1]\n        \n        return Math.sqrt (dX * dX + dY * dY)\n            \n    def up (self):\n        self._down = False\n        \n    def down (self):\n        self._down = True\n        \n    def isdown (self):\n        return self._down\n        \n    def _predict (self, length):\n        delta = [Math.sin (self._heading), Math.cos (self._heading)]\n        return [self._position [0] + length * delta [0], self._position [1] + length * delta [1]]\n        \n    def forward (self, length):\n        self._position = self._predict (length)\n        \n        self._track.append ('{} {} {}'.format (\n            'L' if self._down else 'M',\n            self._position [0] + _offset [0],\n            self._position [1] + _offset [1])\n        )\n        \n    def back (self, length):\n        self.forward (-length)\n        \n    def circle (self, radius):\n        self.left (90)\n        opposite = self._predict (2 * (radius + 1) + 1)\n        self.right (90)\n    \n        self._track.append ('{} {} {} {} {} {} {} {}'.format (\n            'A',\n            radius,\n            radius,\n            0,\n            1,\n            0,\n            opposite [0] + _offset [0],\n            opposite [1] + _offset [1]\n        ))\n        \n        self._track.append ('{} {} {} {} {} {} {} {}'.format (\n            'A',\n            radius,\n            radius,\n            0,\n            1,\n            0,\n            self._position [0] + _offset [0],\n            self._position [1] + _offset [1]\n        ))\n        \n    def left (self, angle):\n        self._heading = (self._heading + Math.PI * angle / 180) % (2 * Math.PI)\n            \n    def right (self, angle): \n        self.left (-angle)\n        \n    def begin_fill (self):\n        self._flush ()\n        self._fill = True\n    \n    def end_fill (self):\n        self._flush ()\n        self._fill = False\n        \n    def speed (speed = None):\n        pass\n        \n_defaultTurtle = Turtle ()\n_timer = None\n    \ndef reset ():\n    nonlocal _timer, _allTurtles\n    if _timer:\n        clearTimeout (_timer)\n    bgcolor ('white')\n    for turtle in _allTurtles:\n        turtle.reset ()\n        turtle.done ()\n        \ndef clear ():\n    nonlocal _allTurtles\n    for turtle in _allTurtles:\n        turtle.clear ()\n        \ndef ontimer (fun, t = 0):\n    nonlocal _timer\n    _timer = setTimeout (fun, t)\n\ndef done ():                            _defaultTurtle.done ()\ndef pensize (width):                    _defaultTurtle.pensize (width)\ndef color (pencolor, fillcolor = None): _defaultTurtle.color (pencolor, fillcolor)\ndef home ():                            _defaultTurtle.home ()\ndef goto (x, y = None):                 _defaultTurtle.goto (x, y)\ndef position ():                        return _defaultTurtle.position ()\ndef pos ():                             return _defaultTurtle.pos ()\ndef distance (x, y = None):             return _defaultTurtle.distance (x, y)\ndef up ():                              _defaultTurtle.up ()\ndef down ():                            _defaultTurtle.down ()\ndef forward (length):                   _defaultTurtle.forward (length)\ndef back (length):                      _defaultTurtle.back (length)\ndef circle (radius):                    _defaultTurtle.circle (radius)\ndef left (angle):                       _defaultTurtle.left (angle)\ndef right (angle):                      _defaultTurtle.right (angle)\ndef begin_fill ():                      _defaultTurtle.begin_fill ()\ndef end_fill ():                        _defaultTurtle.end_fill ()\ndef speed (speed):                      _defaultTurtle.speed (speed)\n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AAEA;AAGA;AACA;AAAA;AAEA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAMA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AAAA;AAMA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAWA;AAAA;AAWA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}