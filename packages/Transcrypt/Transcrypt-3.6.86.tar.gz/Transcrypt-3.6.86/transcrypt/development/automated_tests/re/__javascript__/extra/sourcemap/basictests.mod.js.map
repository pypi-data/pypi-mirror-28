{
	"version": 3,
	"file": "D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/development/automated_tests/re/__javascript__/basictests.mod.js",
	"sources": [
		"D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/development/automated_tests/re/basictests.py"
	],
	"sourcesContent": [
		"\nfrom org.transcrypt.stubs.browser import __pragma__, __symbols__, __envir__\nimport re\n__pragma__(\"skip\")\nre.J = (1<<19)\nre.JSSTRICT = re.J\n\ndef convertMappingDict(mdict):\n    \"\"\" This method converts a mapping proxy object to\n    a dict object. mapping proxies create read-only dicts\n    but we don't have that concept in transcrypt yet.\n    \"\"\"\n    ret = {}\n    for k in mdict.keys():\n        ret[k] = mdict[k]\n    return(ret)\n\n__pragma__(\"noskip\")\n\ntestStr1 = \"There,is,No,Time\"\ntestStr2 = \"som[23] In[23423] the[34].asd[934].234.\"\ntestStr3 = \"s(43) d(03) asdfasd dsfsd(3) sd\"\ntestStr4 = \"Were an apple like an orange then apple orange no appleorange\"\n\ndef checkMatchProperties(test, flags = 0):\n    \"\"\" This test checks that properties on the match\n    are reported correctly, and that they are read-only\n    \"\"\"\n    result = re.search(\",\", testStr1, flags)\n    if ( result is not None ):\n        test.check( result.pos )\n        test.check( result.endpos )\n        test.check( result.group() )\n        test.check( result.group(0) )\n        test.check( result.string )\n\n        # Check readonly props of match\n        def assignPos():\n            result.pos = 1\n        test.check(test.expectException(assignPos))\n        def assignEndPos():\n            result.endpos = 1\n        test.check(test.expectException(assignEndPos))\n        def assignRe():\n            result.re = \"asdfasdf\"\n        test.check(test.expectException(assignRe))\n        def assignStr():\n            result.string = \"asdf\"\n        test.check(test.expectException(assignStr))\n        def assignLastGroup():\n            result.lastgroup = \"asdfasdf\"\n        test.check(test.expectException(assignLastGroup))\n        def assignLastIndex():\n            result.lastindex = 33\n        test.check(test.expectException(assignLastIndex))\n    else:\n        test.checkPad(\"NULL\", 11)\n\n\ndef checkRegexProperties(test, flags = 0):\n    \"\"\" This test checks that the appropriate properties\n    exist on the Regex object and that these properties\n    are read-only.\n    \"\"\"\n    r = re.compile(\",\", flags)\n    if ( r is not None ):\n        test.check( r.groups )\n        test.check( r.pattern )\n        test.check( r.flags )\n        d = r.groupindex\n        __pragma__('skip')\n        d = convertMappingDict(d)\n        __pragma__('noskip')\n        test.check( d )\n        # Check Read-only props on regex object\n        def assignPattern():\n            r.pattern = \"asdfasdf\"\n        test.check(\n            test.expectException(assignPattern)\n        )\n        def assignFlags():\n            r.flags = \"wer\"\n        test.check(\n            test.expectException(assignFlags)\n        )\n        def assignGroups():\n            r.groups = 1\n        test.check(\n            test.expectException(assignGroups)\n        )\n        def assignGroupIndex():\n            r.groupindex = 34\n        test.check(\n            test.expectException(assignGroupIndex)\n        )\n    else:\n        test.checkPad(\"NULL\", 8)\n        \ndef aValue (flag):   # Workaround for Python 3.6 enums\n    result = flag.value\n    return result if result else flag\n        \ndef checkFlagsExist(test):\n    test.check(aValue(re.T))\n    test.check(aValue(re.I))\n    test.check(aValue(re.IGNORECASE))\n    test.check(aValue(re.M))\n    test.check(aValue(re.MULTILINE))\n    test.check(aValue(re.S))\n    test.check(aValue(re.DOTALL))\n    test.check(aValue(re.U))\n    test.check(aValue(re.UNICODE))\n    test.check(aValue(re.X))\n    test.check(aValue(re.VERBOSE))\n    test.check(aValue(re.A))\n    test.check(aValue(re.ASCII))\n\ndef escapeTests(test):\n    test.check(re.escape(\"buf[34]\"))\n    test.check(re.escape(\"C:\\\\asdf\\\\wewer\\\\\"))\n    test.check(re.escape(\"func(int a) { return(3)};\"))\n\ndef checkIgnoreCase(test, flags = 0):\n    test.check( re.search(\"as\", testStr3, flags|re.I).pos )\n    test.check( re.search(\"as\", testStr3, flags|re.I).endpos )\n    test.check( re.search(\"as\", testStr3, flags|re.I).group() )\n    test.check( re.search(\"as\", testStr3, flags|re.I).group(0) )\n    test.check( re.search(\"AS\", testStr3, flags|re.I).pos )\n    test.check( re.search(\"AS\", testStr3, flags|re.I).endpos )\n    test.check( re.search(\"AS\", testStr3, flags|re.I).group() )\n    test.check( re.search(\"AS\", testStr3, flags|re.I).group(0) )\n\ndef checkSearchWithGroups(test, flags = 0):\n    r = \"\\\\[([\\\\d]+)\\\\]\"\n    test.check( re.compile(r, flags).groups )\n    test.check( re.search(r, testStr2, flags).pos)\n    test.check( re.search(r, testStr2, flags).endpos)\n    test.check( re.search(r, testStr2, flags).groups())\n    test.check( re.search(r, testStr2, flags).group())\n    test.checkEval(lambda: re.search(r, testStr2, flags).group(0))\n    test.checkEval(lambda: re.search(r, testStr2, flags).group(1))\n    test.check( re.search(r, testStr2, flags).start())\n    test.checkEval(lambda: re.search(r, testStr2, flags).start(0))\n    test.checkEval(lambda: re.search(r, testStr2, flags).start(1))\n\n    test.check( re.search(r, testStr2, flags).end())\n    test.checkEval(lambda: re.search(r, testStr2, flags).end(0))\n    test.checkEval(lambda: re.search(r, testStr2, flags).end(1))\n\n    test.check( re.search(r, testStr2, flags).span())\n    test.checkEval(lambda: re.search(r, testStr2, flags).span(0))\n    test.checkEval(lambda: re.search(r, testStr2, flags).span(1))\n\n    test.check( re.search(r, testStr2, flags).lastgroup)\n    test.check( re.search(r, testStr2, flags).lastindex)\n\n    for i in range(2,50):\n        test.check(\n            test.expectException(lambda: re.search(',', testStr1, flags).group(i))\n        )\n\ndef checkMatchOps(test, flags = 0):\n    test.check( re.match(\"asdf\", \"asdf\", flags).pos )\n    test.check( re.match(r\"asdf\", \"asdf\", flags).endpos )\n    test.check( re.match(\"asdf\", \"asdf\", flags).groups() )\n    test.check( re.match(\"a\", \"asdf\", flags).pos )\n    test.check( re.match(\"a\", \"asdf\", flags).endpos )\n    test.check( re.match(\"a\", \"asdf\", flags).groups() )\n    test.check( (re.match(\"s\", \"asdf\", flags) is None) )\n    test.check( (re.match(r\"^s\", \"asdf\", flags) is None) )\n    test.check( (re.compile(\"^s\", flags).match(\"asdf\", 1) is None) )\n\ndef checkMatchWithNamedGroups(test, flags = 0):\n    \"\"\"\n    \"\"\"\n    # Matches with named groups\n    r = None\n    try:\n        r = re.compile(r\"(?P<prefix>[a-zA-Z]+)://(?P<suffix>[^/]*)\", flags)\n    except Exception as exc:\n        test.checkPad(None, 15)\n\n    if ( r is not None ):\n        test.check(r.groups)\n        test.check(r.pattern)\n        d = r.groupindex\n        __pragma__('skip')\n        d = convertMappingDict(d)\n        __pragma__('noskip')\n        test.check( d )\n\n        m = r.match(\"http://asdf\")\n        test.check( m.groups() )\n        test.check( m.group() )\n        test.check( m.group(0) )\n        test.check( m.group(1) )\n        test.check( m.group(\"prefix\") )\n        test.check( m.group(\"suffix\") )\n\n        m = r.match(\"ftp://192.168.1.1\")\n        test.check( m.group() )\n        test.check( m.group(0) )\n        test.check( m.group(1) )\n        test.check( m.group(\"prefix\") )\n        test.check( m.group(\"suffix\") )\n        m = r.match(\"555-5555\")\n        test.check(m)\n\n    try:\n        r = re.compile(r\"(?P<country>\\d{1,3})-(?P<areacode>\\d{3})-(?P<number>\\d{3}-\\d{4})\", flags)\n    except:\n        test.checkPad(None, 13)\n\n    if ( r is not None ):\n        test.check(r.groups)\n        test.check(r.pattern)\n        d = r.groupindex\n        __pragma__('skip')\n        d = convertMappingDict(d)\n        __pragma__('noskip')\n        test.check( d )\n\n        m = r.match(\"1-234-567-9012\")\n        test.check(m.groups())\n        test.check(m.group())\n        test.check(m.group(0))\n        test.check(m.group(1))\n        test.check(m.group(2))\n        test.check(m.group(3))\n\n        test.check( m.group(\"country\") )\n        test.check( m.group(\"areacode\") )\n        test.check( m.group(\"number\") )\n\n        m = r.match(\"adfs;\")\n        test.check(m)\n\ndef checkMatchWithGroups(test, flags = 0):\n    rgx = re.compile(r'(\\w)(\\w)(\\w)?', flags)\n    test.check(rgx.pattern)\n    test.check(rgx.groups)\n    m = rgx.match('abc')\n    if m:\n        test.check(m.group(0))\n        test.check(m.group(1))\n        test.check(m.group(1, 2))\n        test.check(m.group(2, 1))\n    else:\n        test.checkPad(None, 4)\n\n    # groups() with default value\n\n    m = rgx.match('ab')\n    if m:\n        test.check(m.groups(0))\n    else:\n        test.checkPad(None, 1)\n\n    # Match with group that is non-captured\n    rgx = re.compile(r'(?:[\\w\\s]+)\\[(\\d+)\\]', flags)\n    test.check(rgx.pattern)\n    test.check(rgx.groups)\n\n    m = rgx.match(\"asdf[23]\")\n    if m:\n        test.check( m.groups() )\n        test.check( m.group(0) )\n        test.check( m.group(1) )\n        test.check( test.expectException( lambda: m.group(2) ) )\n    else:\n        test.checkPad(None, 4)\n\n\ndef checkCommentGroup(test, flags = 0):\n    \"\"\" Comment Groups are only supported in Python so will\n    likely fail in javascript only mode\n    \"\"\"\n    r = None\n    try:\n        r = re.compile(r'a(?#foobar)b', flags)\n    except:\n        test.checkPad(None,4)\n\n    if ( r is not None ):\n        test.check(r.groups)\n        test.check(r.pattern)\n        test.check(r.search(\"ab\").group())\n        test.check(r.search(\"er\"))\n\n    try:\n        r = re.compile(r'([\\d]+)(?#blarg)\\[\\]', flags)\n    except:\n        test.checkPad(None, 4)\n        return\n\n    test.check( r.groups )\n    test.check( r.pattern )\n    test.check( r.search(\"1234[]\").group())\n    test.check( r.search(\"asdf[]\"))\n\n\ndef checkFullMatchOps(test, flags = 0):\n    test.check( (re.fullmatch(\"asdf\", \"asdf\", flags).pos))\n    test.check( (re.fullmatch(\"asdf\", \"asdf\", flags).endpos))\n    test.check( (re.fullmatch(\"as\", \"asdf\", flags) is None))\n    test.check( (re.fullmatch(\"q\", \"asdf\", flags) is None))\n    test.check( (re.compile(\"o[gh]\", flags).fullmatch(\"dog\") is None))\n    test.check( (re.compile(\"o[gh]\", flags).fullmatch(\"ogre\") is None))\n\n    m = re.compile(\"o[gh]\", flags).fullmatch(\"doggie\",1,3)\n    if m:\n        test.check(m.pos)\n        test.check(m.endpos)\n    else:\n        test.checkPad(None,2)\n\ndef checkFindAllOps(test, flags = 0):\n    test.check(re.findall(\",\", testStr1, flags)) # No Caps\n    test.check(re.findall(\"\\\\[([\\\\d]+)\\\\]\", testStr2, flags)) # 1 Cap\n    r = \"([^\\d\\s]+\\\\(([\\d]+)\\\\))\"\n    test.check(re.compile(r, flags).groups)\n    test.check(re.findall(r, testStr3, flags)) # 2 Caps\n\ndef checkSplitOps(test, flags = 0):\n    test.check(re.split(\",\", testStr1, 0, flags))\n\n    test.check(re.split(\"(apple|orange)\",testStr4, 0, flags))\n    test.check(re.split(\"\\\\[([\\\\d]+)\\\\]\", testStr2, 0, flags))\n    r = re.compile(\",\", flags)\n    test.check(r.split(testStr1, 0))\n    test.check(r.split(testStr1, 1))\n    test.check(r.split(testStr1, 2))\n    test.check(r.split(testStr1, 3))\n    test.check(r.split(testStr1, 4))\n\n    r = re.compile(\"\\\\[([\\\\d]+)\\\\]\", flags)\n    test.check(r.split(testStr2,0))\n    test.check(r.split(testStr2,1))\n    test.check(r.split(testStr2,2))\n    test.check(r.split(testStr2,3))\n    test.check(r.split(testStr2,4))\n\ndef checkSubOps(test, flags = 0):\n    def dashrepl(matchobj):\n        if matchobj.group(0) == '-':\n            return ' '\n        else:\n            return '-'\n    test.check(re.sub('-{1,2}', dashrepl, 'pro----gram-files',0, flags))\n    test.check(re.sub('-{1,2}', '4', 'pro----gram-files',0, flags))\n    test.check(re.subn('-{1,2}', dashrepl, 'pro----gram-files',0,flags))\n    test.check(re.subn('-{1,2}', '4', 'pro----gram-files',0,flags))\n\ndef checkSyntaxErrors(test, flags = 0):\n    test.check(test.expectException( lambda: re.compile(r')', flags)))\n    test.check(test.expectException( lambda: re.compile(\"a\\\\\", flags)))\n    test.check(test.expectException( lambda: re.compile(r'a[b', flags)))\n    test.check(test.expectException( lambda: re.compile(r'(abc', flags)))\n    test.check(test.expectException( lambda: re.compile(r')(', flags)))\n    test.check(test.expectException( lambda: re.compile(r'))', flags)))\n    test.check(test.expectException( lambda: re.compile(r'a[b-a]', flags)))\n    test.check(test.expectException( lambda: re.compile(r'*a', flags)))\n\ndef checkFindIter(test, flags = 0):\n    \"\"\" Test the finditer method\n    \"\"\"\n    __pragma__ ('ifdef', '__esv5__')\n    if ( '__esv5__' in __symbols__ ):\n        test.check(\"Skip finditer tests in esv5\")\n        return\n    __pragma__('else')\n    p = \"\\\\[([\\\\d]+)\\\\]\"\n    r = re.compile(p, flags)\n    test.check( r.groups )\n\n    iret = r.finditer(testStr2)\n    for m in iret:\n        test.check(m.pos)\n        test.check(m.endpos)\n        test.check(m.string)\n        test.check(m.lastindex)\n        test.check(m.groups())\n        test.check(m.group(0))\n        test.check(m.group(1))\n        test.check(test.expectException( lambda: m.group(2) ))\n        test.check(test.expectException( lambda: m.group(2342)))\n        test.check(test.expectException( lambda: m.group(\"asdf\")))\n        test.check(m.start(0))\n        test.check(m.start(1))\n        test.check(test.expectException( lambda: m.start(\"asdf\")))\n        test.check(m.end(0))\n        test.check(m.end(1))\n        test.check(test.expectException( lambda: m.end(\"asdf\")))\n    __pragma__('endif')\n\ndef checkWithFlags(test, flags = 0):\n    \"\"\" This checks the regex with flags called out in the\n    string, for example (?i) for ignore case.\n    This is a python only feature.\n    \"\"\"\n    try:\n        r = re.compile(r'(?i)aba', flags)\n    except:\n        test.checkPad(None, 5)\n        return\n\n    test.check(r.groups)\n    test.check(r.pattern)\n\n    m = r.search(\"aBA\")\n    test.check(m.group() )\n    test.check(m.groups())\n\n    m = r.match(\"aAa\")\n    test.check(m)\n\n    m = r.match(\"ABA\")\n    test.check(m.group())\n\n    m = r.match(\"abA\")\n    test.check(m.group())\n\n\ndef checkConditionalGroups(test, flags = 0):\n    \"\"\" Check conditional groups - this is a python only\n    feature - will likely faily in the js strict mode\n    \"\"\"\n    rgx = None\n    try:\n        rgx = re.compile(r'(a)?(b)?(?(1)a|c)(?(2)b)', flags)\n    except:\n        test.checkPad(None, 12)\n\n    if ( rgx is not None ):\n#        test.check(rgx.groups)                                             # !!! @JdeH temporarily disabled this\n        test.check(rgx.pattern)\n        test.checkEval(lambda: rgx.match('abab').group())\n        test.checkEval(lambda: rgx.match('aa').group())\n        test.checkEval(lambda: rgx.match('bcb').group())\n        test.checkEval(lambda: rgx.match('c').group())\n        test.checkEval(lambda: rgx.match('abcb'))\n        # PyRegex needs to use n_splits from `translate` for this to work\n        # test.checkEval(lambda: rgx.match('c').groups())                   # !!! @JdeH temporarily disabled this\n        # test.checkEval(lambda: rgx.split(\"ababbababcdjsabbabdbab\"))       # !!! @JdeH temporarily disabled this\n        test.checkEval(lambda: rgx.sub(\"jumbo\", \"ababsdf rexababwer\"))\n        test.checkEval(lambda: rgx.sub(\"shrimp\", \"shipbcb shootc aardvark\"))\n        # test.checkEval(lambda: rgx.findall(\"ababxaaxcebbcxababeded\"))     # !!! @JdeH temporarily disabled this\n\n    try:\n        rgx = re.compile(r'(a)?(b)?(?(1)a|c)(?(2)b|d)', flags)\n    except:\n        test.checkPad(None, 6)\n        return\n\n    # test.check(rgx.groups)                                                # !!! @JdeH temporarily disabled this\n    test.check(rgx.pattern)\n    test.checkEval(lambda: rgx.match('abab').group())\n    test.checkEval(lambda: rgx.match('aad').group())\n    test.checkEval(lambda: rgx.match('bcb').group())\n    test.checkEval(lambda: rgx.match('bcb').group())\n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2cA;AA3cA;AAEA;AAiBA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAKA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}