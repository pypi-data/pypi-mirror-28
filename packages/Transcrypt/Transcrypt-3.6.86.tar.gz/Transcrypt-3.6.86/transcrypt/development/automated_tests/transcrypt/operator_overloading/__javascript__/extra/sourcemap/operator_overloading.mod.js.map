{
	"version": 3,
	"file": "D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/development/automated_tests/transcrypt/operator_overloading/__javascript__/operator_overloading.mod.js",
	"sources": [
		"D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/development/automated_tests/transcrypt/operator_overloading/__init__.py"
	],
	"sourcesContent": [
		"from org.transcrypt.stubs.browser import __pragma__\n\nclass Matrix:\n    def __init__ (self, nRows, nCols, elements = []):\n        self.nRows = nRows\n        self.nCols = nCols\n        \n        if len (elements):\n            self._ = elements\n        else:\n            self._ = [[0 for col in range (nCols)] for row in range (nRows)]\n        \n    def __matmul__ (self, other):\n        result = Matrix (self.nRows, other.nCols)\n        for iTargetRow in range (result.nRows):\n            for iTargetCol in range (result.nCols):\n                for iTerm in range (self.nCols):\n                    result._ [iTargetRow][iTargetCol] += self._ [iTargetRow][iTerm] * other._ [iTerm][iTargetCol]\n        return result\n                \n    def __imatmul__ (self, other):\n        # True in-place multiplication not yet implemented in compiler\n        # It currently translates m1 @= m2 to m1 = m1 @ ms and uses __matmul__ instead\n        # This fake __imatmul__ is just for CPython , allowing back to back testing\n        return self.__matmul__ (other)\n        \n    def __mul__ (self, other):\n        if type (other) == Matrix:\n            result = Matrix (self.nRows, self.nCols)\n            for iRow in range (self.nRows):\n                for iCol in range (self.nCols):\n                    result._ [iRow][iCol] = self._ [iRow][iCol] * other._ [iRow][iCol]   \n            return result\n        else:  # other is a scalar\n            return self.__rmul__ (other)\n                \n    def __rmul__ (self, scalar):    # Only called if left operand is scalar, all other cases will call __mul__\n        result = Matrix (self.nRows, self.nCols)\n        for iRow in range (self.nRows):\n            for iCol in range (self.nCols): \n                result._ [iRow][iCol] = scalar * self._ [iRow][iCol]\n        return result\n    \n    def __imul__ (self, other):\n        return self.__mul__ (other)\n                \n    def __add__ (self, other):\n        result = Matrix (self.nRows, self.nCols)\n        for iRow in range (self.nRows):\n            for iCol in range (self.nCols):\n                result._ [iRow][iCol] = self._ [iRow][iCol] + other._ [iRow][iCol]\n        return result\n        \n    # No __iadd__, to test fallback to __add__\n    \n    def __getitem__ (self, index):\n        return self._ [index]\n\n    def __setitem__ (self, index, value):\n        self._ [index] = value\n        \n    def __repr__ (self):\n        return repr (self._)\n        \n    def __floordiv__ (self, other):\n        return 'Overloading __floordiv__ has no meaning for matrices'\n        \n    def __truediv__ (self, other):\n        return 'Overloading __truediv__ has no meaning for matrices'\n        \nclass Functor:\n    def __init__ (self, factor):\n        self.factor = factor\n        \n    __pragma__ ('kwargs')\n    def __call__ (self, x, y = -1, *args, m = -2, n, **kwargs):\n        return (\n            self.factor * x,\n            self.factor * y,\n            [self.factor * arg for arg in args],\n            self.factor * m,\n            self.factor * n,\n            # !!! [self.factor * kwargs [key] for key in sorted (kwargs.keys ())] Add supoprt for keys () on kwargs\n        )\n    __pragma__ ('nokwargs')\n    \nf = Functor (10)\n\n__pragma__ ('kwargs')\ndef g (x, y = -1, *args, m = -2, n, **kwargs):\n    return (x, y, args, m, n) # !!! , [kwargs [key] for key in sorted (kwargs.keys ())]) Add support for keys () on kwargs\n__pragma__ ('nokwargs')\n        \ndef run (autoTester):\n    m0 = Matrix (3, 3, [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 10]\n    ])\n    \n    m1 = Matrix (3, 3, [\n        [10, 20, 30],\n        [40, 50, 60],\n        [70, 80, 90]\n    ])\n    \n    m4 = Matrix (3, 3, [\n        [1, 1,  2],\n        [2, 2,  3],\n        [3, 3, -5]\n    ])\n    \n    m5 = Matrix (3, 3, [\n        [1, 1,  2],\n        [2, 2,  3],\n        [3, 3, -5]\n    ])\n        \n    x = 3\n    y = x * 4 * x\n    fast = 2 * 3\n    fast += 1\n    \n    __pragma__ ('opov')\n    \n    m1 [1][2] = m0 [1][2]\n    slow = 2 + 3\n    m2 = m0 * m1  + m1 * (m0 + m1)\n    m3 = 2 * (2 * m0 * 3 * m1 + m2 * 4) * 2\n\n    autoTester.check (m0 [1][1], m0 [1][2], m1 [1][1], m1 [1][2])\n\n    m1 += m0\n    m2 *= m1\n    \n    m5 @= m4\n    m6 = m0 @ m1\n    \n    autoTester.check (m0 / m1)\n    autoTester.check (m0 // m1)\n    \n    __pragma__ ('noopov')\n    \n    fast2 = 16 * y + 1\n    fast *= 2\n    \n    autoTester.check (m0, m1)\n    autoTester.check (x, y)\n    autoTester.check (m2)\n    autoTester.check (m3)\n    autoTester.check (m5)\n    autoTester.check (m6)\n    autoTester.check (fast, slow, fast2)\n    \n    x = 'marker'\n    \n    __pragma__ ('opov')\n    autoTester.check (f (3, 4, 30, 40, m = 300, n = 400, p = 3000, q = 4000))\n    autoTester.check (g (3, 4, 30, 40, m = 300, n = 400, p = 3000, q = 4000))\n    \n    autoTester.check (set ((1, 2, 3)) == set ((3, 2, 1)))\n    autoTester.check (set ((1, 2, 3)) != set ((3, 2, 1)))\n    autoTester.check (set ((1, 3)) == set ((3, 2, 1)))\n    autoTester.check (set ((1, 3)) != set ((3, 2, 1)))\n    autoTester.check (set ((1, 2)) < set ((3, 2, 1)))\n    autoTester.check (set ((1, 2, 3)) <= set ((3, 2, 1)))\n    autoTester.check (set ((1, 2, 3)) > set ((2, 1)))\n    autoTester.check (set ((1, 2, 3)) >= set ((3, 2, 1)))\n    \n    autoTester.check ((1, 2, 3) == (1, 2, 3))\n    autoTester.check ([1, 2, 3] == [1, 2, 3])\n    autoTester.check ((1, 2, 3) != (1, 2, 3))\n    autoTester.check ([1, 2, 3] != [1, 2, 3])\n    autoTester.check ((2, 1, 3) == (1, 2, 3))\n    autoTester.check ([2, 1, 3] == [1, 2, 3])\n    autoTester.check ((2, 1, 3) != (1, 2, 3))\n    autoTester.check ([2, 1, 3] != [1, 2, 3])\n    __pragma__ ('noopov')\n    \n    class Bitwise:\n        def __lshift__ (self, other):\n            autoTester.check ('lshift')\n            \n        def __rlshift__ (self, other):\n            autoTester.check ('rlshift')\n            \n        def __rshift__ (self, other):\n            autoTester.check ('rshift')\n            \n        def __rrshift__ (self, other):\n            autoTester.check ('rrshift')\n            \n        def __or__ (self, other):\n            autoTester.check ('or') \n            \n        def __ror__ (self, other):\n            autoTester.check ('ror')\n            \n        def __xor__ (self, other):\n            autoTester.check ('xor')\n            \n        def __rxor__ (self, other):\n            autoTester.check ('rxor')\n            \n        def __and__ (self, other):\n            autoTester.check ('and')\n            \n        def __rand__ (self, other):\n            autoTester.check ('rand') \n\n    bitwise = Bitwise ()\n    \n    __pragma__ ('opov')\n    \n    bitwise << []\n    [] << bitwise\n    autoTester.check (32 << 2)\n    \n    bitwise >> []\n    [] >> bitwise\n    autoTester.check (32 >> 2)\n    \n    bitwise | []\n    [] | bitwise\n    autoTester.check (1 | 4)\n    \n    bitwise ^ []\n    [] ^ bitwise\n    autoTester.check (11 ^ 13)\n    \n    bitwise & []\n    [] & bitwise\n    autoTester.check (12 & 20)\n    \n    a = 32\n    a <<=2\n    autoTester.check (a)\n    \n    __pragma__ ('noopov')\n    \n    autoTester.check (32 << 2)\n    autoTester.check (32 >> 2)\n    autoTester.check (1 | 4)\n    autoTester.check (11 ^ 13)\n    autoTester.check (12 & 20)\n    \n    a = 32\n    a <<= 2\n    autoTester.check (a)\n    \n    class A:\n        def __init__ (self):\n            self.b = {}\n            \n    a = A ()\n    a.b ['c'] = 'd'\n        \n    __pragma__('opov')\n    a.b ['c'] += 'e'\n    __pragma__('noopov')\n    \n    autoTester.check (a.b ['c'])"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAIA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AAMA;AAMA;AAMA;AAMA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAEA;AAAA;AAIA;AAAA;AAAA;AAIA;AAAA;AAAA;AAIA;AAAA;AAAA;AAIA;AAAA;AAAA;AAIA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAGA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}