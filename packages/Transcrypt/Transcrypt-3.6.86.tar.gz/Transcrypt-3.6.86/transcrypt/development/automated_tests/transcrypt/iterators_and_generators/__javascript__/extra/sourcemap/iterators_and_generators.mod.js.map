{
	"version": 3,
	"file": "D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/development/automated_tests/transcrypt/iterators_and_generators/__javascript__/iterators_and_generators.mod.js",
	"sources": [
		"D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/development/automated_tests/transcrypt/iterators_and_generators/__init__.py"
	],
	"sourcesContent": [
		"from org.transcrypt.stubs.browser import __pragma__\n\nclass Iterable:\n    def __init__ (self, i):\n        self.aList = range (0, 50, i)\n\n    def __iter__ (self):\n        return Iterator (self) \n        \nclass Iterator:\n    def __init__ (self, iterable):\n        self.iterable = iterable\n        self.index = -1\n        \n    def __next__ (self):    # Should be auto-wrapped in a next (self) by the compiler \n        self.index += 1\n        \n        if self.index > 5:\n            raise StopIteration ()\n            \n        return self.iterable.aList [self.index]\n            \n    def __iter__ (self):\n        return self\n        \ndef exhaustableGenerator (i):\n    for i in range (5):\n        yield 2 * i\n\ndef run (autoTester):\n    exhaustableGenExp = (a * a * a for a in [10, 20, 30])   # Currently still converted to iterator on list comprehension, must also be iterable\n    # So becomes py_iter (aList).\n    # List already has an __iter__ which it will return, it's a __PyIterator__\n    # To that __PyIterator__, that will already have a __next__, py_iter first adds a next\n    # So exhaustableGenExp is an iterator with a next and a __next__\n    # If we call iter on that, py_iter is calle again py_iter, on an object with a next and a next __next__\n    # For this reason py_iter needs a recursion prevention check\n\n    iterables = [Iterable (7), exhaustableGenerator (5), [i * 3 for i in range (5)], exhaustableGenExp]\n\n    for iterable in iterables:  \n        autoTester.check ('[1]')\n        iterator = iter (iterable)\n        try:\n            while True:\n                autoTester.check (next (iterator))\n        except Exception as exception:\n            autoTester.check (exception.__class__.__name__)\n\n        autoTester.check ('[2]')\n        iterator = iter (iterable)\n        try:\n            while True:\n                autoTester.check (next (iterator))\n        except Exception as exception:\n            autoTester.check (exception.__class__.__name__)\n            \n    for iterable in iterables:\n        autoTester.check ('[3]')\n        for n in iterable:\n            autoTester.check (n)\n            \n        autoTester.check ('[4]')\n        for n in iterable:\n            autoTester.check (n)\n            \n    # BEGIN issue 196: for loop over iter (), runs OK but needs JavaScript 6. This should be clearly in the docs.\n            \n    a = 0\n    vals = [1,2,3]\n    ret = iter (vals)\n    for m in ret:\n        a += m\n    autoTester.check (a)\n     \n    # END issue 196\n                \n    # BEGIN 1st example with 'send'\n        \n    __pragma__ ('gsend')\n\n    def test0 ():\n        r = 0\n        while True:\n            r = r + (yield r)\n\n    gen0 = test0()\n    next (gen0)\n    autoTester.check (gen0.send (1))\n    autoTester.check (gen0.send (2))\n\n    def test1 ():\n        r = 0\n        while True:\n            r = (yield r) + r\n\n    gen1 = test1()\n    next (gen1)\n    autoTester.check (gen1.send (3))\n    autoTester.check (gen1.send (4))\n    \n    # END 1st example with 'send'\n    \n    def subGenerator ():\n        yield 27\n        yield 37\n        yield 47\n    \n    \n    def mainGenerator ():\n        yield 17\n        yield from subGenerator ()\n        yield 57\n        \n    autoTester.check (* [i for i in mainGenerator ()])\n    \n    def subCoroutine ():\n        autoTester.check (38)\n        yield\n        autoTester.check (48)\n        yield\n        autoTester.check (58)\n        yield\n        autoTester.check (68)\n    \n    \n    def mainCoroutine ():\n        autoTester.check (18)\n        yield\n        autoTester.check (28)\n        yield from subCoroutine ()\n        autoTester.check (78)\n        yield\n        autoTester.check (88)\n        \n    m = mainCoroutine ()\n    for i in range (5):\n        m.send (None)\n        "
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAQA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAIA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAGA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}