<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>challenges.challenge</title>
    <link rel="stylesheet" href="../../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" /> 
  </head>
  <body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <h1>Source code for challenges.challenge</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Core module of challenges</span>

<span class="sd">This module holds the base class of all challenges.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>


<div class="viewcode-block" id="Challenge"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge">[docs]</a><span class="k">class</span> <span class="nc">Challenge</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Base class of all challenges</span>

<span class="sd">    Design concept is the Template Method Design Pattern (GOF).</span>

<span class="sd">    Attributes:</span>

<span class="sd">    :sample:    The input of the challenge.</span>
<span class="sd">    :output:    The output of the challenge</span>

<span class="sd">    Workflow:</span>

<span class="sd">    The `main` method controls the overall workflow by calling the worker</span>
<span class="sd">    methods. This is the common character of all challenges.</span>
<span class="sd">    The base class controls the workflow of the derived workers.</span>

<span class="sd">    Workers:</span>

<span class="sd">    The worker methods need to be implemented by the inheriting class.</span>

<span class="sd">    :read:     Read the input into a list of lines.</span>
<span class="sd">    :build:    Build the data model from the lines.</span>
<span class="sd">    :calc:     Run the main algorithm of the challenge.</span>
<span class="sd">    :format:   Create the output string required by the grader.</span>

<span class="sd">    Library:</span>

<span class="sd">    The other methods support the implementation of the workers. They address</span>
<span class="sd">    the extraction of data from the input lines or the formatting of the</span>
<span class="sd">    output.</span>

<span class="sd">    Sample:</span>

<span class="sd">    The attribute `sample` is both used as class and as instance attribute.</span>
<span class="sd">    When the instance attribute is injected it shadows the class attribute. By</span>
<span class="sd">    this the class attribute sets a tiny but useful default.</span>

<span class="sd">    When the challenge runner is executed with the option `--klass` no</span>
<span class="sd">    instance variable is injected and the sample from the class is used::</span>

<span class="sd">        prompt&gt; challenge MyChallenge --klass</span>

<span class="sd">    When the runner is executed with the option `--file` the files content is</span>
<span class="sd">    injected::</span>

<span class="sd">        prompt&gt; challenge MyChallenge --file ~/Downloads/data.txt</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sample</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        sample</span>
<span class="s1">        sample</span>
<span class="s1">    &#39;&#39;&#39;</span>
    <span class="sd">&quot;&quot;&quot;Holds a minimal example of the input with additional whitespace.</span>

<span class="sd">    This class variable should always be preset with a tiny sample of input.</span>
<span class="sd">    Whitespace surrounding lines is for readability. It typically needs to be </span>
<span class="sd">    stripped to get the actual sample.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">expect</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        expected result</span>
<span class="s1">        expected result</span>
<span class="s1">    &#39;&#39;&#39;</span>
    <span class="sd">&quot;&quot;&quot;Holds the expected result with additional leading whitespace.</span>
<span class="sd">    </span>
<span class="sd">    Whitespace surrounding lines is for readability. It typically needs to be </span>
<span class="sd">    stripped to get the actual expactation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">br</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="sd">&quot;&quot;&quot;Line breaks as expected by the most graders.&quot;&quot;&quot;</span>

    <span class="n">split_pattern</span> <span class="o">=</span> <span class="s1">&#39;\s+|\s?,\s?&#39;</span>
    <span class="sd">&quot;&quot;&quot;Reg expression to split input lines.</span>

<span class="sd">    Used by some of the input parsing functions. The default splits by</span>
<span class="sd">    whitespace and/or comma. If the input is separated differently like colons</span>
<span class="sd">    or semicolons it needs adjustment in the inheriting class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">edge_pattern</span> <span class="o">=</span> <span class="s1">&#39;^(\d+)-&gt;(\d+)(:(\d+))?$&#39;</span>
    <span class="sd">&quot;&quot;&quot;Reg expression to extract edges of a graph.</span>
<span class="sd">    </span>
<span class="sd">    With or without weight.</span>
<span class="sd">    </span>
<span class="sd">        2-&gt;3</span>
<span class="sd">        2-&gt;3:22</span>

<span class="sd">    A default setting used by methods that extract edges from input lines.</span>
<span class="sd">    May need adjustment for different kind of edge input formats.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">multi_edge_pattern</span> <span class="o">=</span> <span class="s1">&#39;^(\d+)-&gt;(\d+(,?\s*\d+)*)$&#39;</span>
    <span class="sd">&quot;&quot;&quot;Reg expressen to extrct edges of a graph. </span>
<span class="sd">    </span>
<span class="sd">    Multiple edges on one line.</span>
<span class="sd">    </span>
<span class="sd">        2-&gt;3, 4, 5</span>
<span class="sd">    </span>
<span class="sd">    A default setting used by methods that extract edges from input lines.</span>
<span class="sd">    May need adjustment for different kind of edge input formats.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fasta_pattern</span> <span class="o">=</span> <span class="s1">&#39;^[\-\*A-Z]+$&#39;</span>
    <span class="sd">&quot;&quot;&quot;Reg expression for FASTA sequences.</span>

<span class="sd">    Matches lines holding FASTA sequences.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="sd">&quot;&quot;&quot;A list of lines that will be filled by the method read().&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">SimpleNamespace</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;The imported data model.</span>

<span class="sd">        A flexible namespace object to take up any kind of data. In simple</span>
<span class="sd">        cases this may be completely overwritten, i.e by a list or dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">SimpleNamespace</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;The resulting data model.</span>

<span class="sd">        A flexible namespace object to take up any kind of data. In simple</span>
<span class="sd">        cases this may be completely overwritten, i.e by a list or dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="sd">&quot;&quot;&quot;The output string.</span>

<span class="sd">        The string representation of the resulting model as expected by the</span>
<span class="sd">        grader.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Challenge.main"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.main">[docs]</a>    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Control the workflow of the challenge.</span>

<span class="sd">        Usually this method doesn&#39;t need to be overwritten.</span>

<span class="sd">        The workers share data via instance variables.</span>
<span class="sd">        The overall input is injected into self.sample.</span>
<span class="sd">        The overall output is read from self.result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">()</span></div>

    <span class="c1"># --------------------------------------------------</span>
    <span class="c1"># Default and abstract workers</span>
    <span class="c1"># --------------------------------------------------</span>

<div class="viewcode-block" id="Challenge.read"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract the input string self.sample into self.lines.</span>

<span class="sd">        Typically this method can be used as is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">example</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span></div>

<div class="viewcode-block" id="Challenge.build"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.build">[docs]</a>    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set up the model from the input lines.</span>

<span class="sd">        This method must be implemented.</span>
<span class="sd">        Reads from self.lines.</span>
<span class="sd">        Fills self.model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Challenge.calc"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.calc">[docs]</a>    <span class="k">def</span> <span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Main algorithm of the challenge.</span>

<span class="sd">        This method must be implemented. Here the interesting stuff happens.</span>
<span class="sd">        Best practice is to delegate to functions, that are named by the</span>
<span class="sd">        algorithms used or even to other classes that implement the algorithm.</span>

<span class="sd">        Reads from self.model.</span>
<span class="sd">        Fills self.result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Challenge.format"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.format">[docs]</a>    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Format the output string.</span>

<span class="sd">        In simple cases this method can be used as is. In other cases it</span>
<span class="sd">        needs to be reimplemented.</span>

<span class="sd">        Reads from self.result.</span>
<span class="sd">        Fills self.output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span></div>

    <span class="c1"># --------------------------------------------------</span>
    <span class="c1"># Accessing example and expectation</span>
    <span class="c1"># --------------------------------------------------</span>

<div class="viewcode-block" id="Challenge.example"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.example">[docs]</a>    <span class="k">def</span> <span class="nf">example</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the sample, with heading whitespace trimmed&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="Challenge.expectation"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.expectation">[docs]</a>    <span class="k">def</span> <span class="nf">expectation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the expecation, with heading whitespace trimmed&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expect</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">)</span></div>

    <span class="c1"># --------------------------------------------------</span>
    <span class="c1"># Accessing input lines</span>
    <span class="c1"># --------------------------------------------------</span>

<div class="viewcode-block" id="Challenge.line"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.line">[docs]</a>    <span class="k">def</span> <span class="nf">line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nr</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return one line by the given number.</span>

<span class="sd">        :param nr: line number</span>
<span class="sd">        :return: line as string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span></div>

<div class="viewcode-block" id="Challenge.lines_to_list"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.lines_to_list">[docs]</a>    <span class="k">def</span> <span class="nf">lines_to_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of lines.</span>

<span class="sd">        If stop is not given all remaining lines are used.</span>

<span class="sd">        :param start: index of first line</span>
<span class="sd">        :param stop: index of line after last line</span>
<span class="sd">        :return: list of lines</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stop</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="n">start</span><span class="p">:]</span></div>

    <span class="k">def</span> <span class="nf">_to_words</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Split line into words</span>

<span class="sd">        The split behaviour can be adjusted by changing self.split_pattern.</span>

<span class="sd">        :param line: the string to split</span>
<span class="sd">        :return: list of words</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_pattern</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>

<div class="viewcode-block" id="Challenge.line_to_words"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.line_to_words">[docs]</a>    <span class="k">def</span> <span class="nf">line_to_words</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nr</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Split one line into a list of words.</span>

<span class="sd">        :param nr: line number</span>
<span class="sd">        :return: list of words</span>
<span class="sd">        :see: self._to_words()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_words</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">nr</span><span class="p">))</span></div>

<div class="viewcode-block" id="Challenge.lines_to_words"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.lines_to_words">[docs]</a>    <span class="k">def</span> <span class="nf">lines_to_words</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">flatten</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split a range of lines into words.</span>

<span class="sd">        If stop is not given all remaining lines are used.</span>

<span class="sd">        :param start: index of first line</span>
<span class="sd">        :param stop: index of line after last line</span>
<span class="sd">        :param flatten: flatten to one dimensional list</span>
<span class="sd">        :return: one or two dimensional list of words</span>
<span class="sd">        :see: self._to_words()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">words</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines_to_list</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">flatten</span><span class="p">:</span>
                <span class="n">words</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_words</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">words</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_words</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">words</span></div>

    <span class="k">def</span> <span class="nf">_to_integers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Split line into integers</span>

<span class="sd">        The split behaviour can be adjusted by changing self.split_pattern.</span>

<span class="sd">        :param line: the string to split</span>
<span class="sd">        :return: list of integers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_pattern</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">line</span><span class="p">)]</span>

<div class="viewcode-block" id="Challenge.line_to_integer"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.line_to_integer">[docs]</a>    <span class="k">def</span> <span class="nf">line_to_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nr</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return line as integer.</span>

<span class="sd">        :param nr: line number</span>
<span class="sd">        :return: integer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">nr</span><span class="p">))</span></div>

<div class="viewcode-block" id="Challenge.line_to_integers"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.line_to_integers">[docs]</a>    <span class="k">def</span> <span class="nf">line_to_integers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nr</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Split one line into  a list of integers.</span>

<span class="sd">        :param nr: line number</span>
<span class="sd">        :return: list of integers</span>
<span class="sd">        :see: self._to_integers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_integers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">nr</span><span class="p">))</span></div>

<div class="viewcode-block" id="Challenge.lines_to_integers"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.lines_to_integers">[docs]</a>    <span class="k">def</span> <span class="nf">lines_to_integers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split a range of lines into integers</span>

<span class="sd">        If stop is not given all remaining lines are used.</span>

<span class="sd">        :param start: index of first line</span>
<span class="sd">        :param stop: index of line after last line</span>
<span class="sd">        :param flatten: flatten to one dimensional list</span>
<span class="sd">        :return: one or two dimensional list of integers</span>
<span class="sd">        :see: self._to_integers()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">integers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines_to_list</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">flatten</span><span class="p">:</span>
                <span class="n">integers</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_integers</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">integers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_integers</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">integers</span></div>

    <span class="k">def</span> <span class="nf">_to_floats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Split line into floats</span>

<span class="sd">        The split behaviour can be adjusted by changing self.split_pattern.</span>

<span class="sd">        :param line: the string to split</span>
<span class="sd">        :return: list of floats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_pattern</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">line</span><span class="p">)]</span>

<div class="viewcode-block" id="Challenge.line_to_float"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.line_to_float">[docs]</a>    <span class="k">def</span> <span class="nf">line_to_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nr</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return line as float.</span>

<span class="sd">        :param nr: line number</span>
<span class="sd">        :return: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">nr</span><span class="p">))</span></div>

<div class="viewcode-block" id="Challenge.line_to_floats"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.line_to_floats">[docs]</a>    <span class="k">def</span> <span class="nf">line_to_floats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nr</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Split one line into  a list of floats.</span>

<span class="sd">        :param nr: line number</span>
<span class="sd">        :return: list of floats</span>
<span class="sd">        :see: self._to_floats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_floats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">nr</span><span class="p">))</span></div>

<div class="viewcode-block" id="Challenge.lines_to_floats"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.lines_to_floats">[docs]</a>    <span class="k">def</span> <span class="nf">lines_to_floats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split a range of lines into floats</span>

<span class="sd">        If stop is not given all remaining lines are used.</span>

<span class="sd">        :param start: index of first line</span>
<span class="sd">        :param stop: index of line after last line</span>
<span class="sd">        :param flatten: flatten to one dimensional list</span>
<span class="sd">        :return: one or two dimensional list of floats</span>
<span class="sd">        :see: self._to_floats()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">floats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines_to_list</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">flatten</span><span class="p">:</span>
                <span class="n">floats</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_floats</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">floats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_floats</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">floats</span></div>

<div class="viewcode-block" id="Challenge.line_to_permutation"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.line_to_permutation">[docs]</a>    <span class="k">def</span> <span class="nf">line_to_permutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nr</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">terminals</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert one line to a permutation</span>

<span class="sd">        optionally surrounded by terminals</span>

<span class="sd">        Example: (+1 -3, -2)</span>
<span class="sd">        Result: (1, -3, 2)</span>
<span class="sd">        If terminals is True: (0, 1, -3, 2, 4)</span>

<span class="sd">        The number of the line is selected by nr.</span>
<span class="sd">        Input may be surrounded by a pair of round parenthesis.</span>

<span class="sd">        :param nr: line number</span>
<span class="sd">        :param terminals: if True surrounded by 0 and n + 1</span>
<span class="sd">        :return: permutation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">nr</span><span class="p">)</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^\((.*)\)$&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">digits</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">digits</span> <span class="o">=</span> <span class="n">line</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_pattern</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">digits</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">terminals</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">perm</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span></div>

<div class="viewcode-block" id="Challenge.line_to_permutations"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.line_to_permutations">[docs]</a>    <span class="k">def</span> <span class="nf">line_to_permutations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nr</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert one line to multiple permutations</span>

<span class="sd">        Example: (+1 -3, -2)(+4 +5)</span>
<span class="sd">        Result: [(1, -3, 2), (4, 5)]</span>

<span class="sd">        The number of the line is selected by line_nr.</span>

<span class="sd">        :param nr: line number</span>
<span class="sd">        :return: list of permutations (tuples)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;\(([^)]*)\)&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">nr</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">digits</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_pattern</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">digits</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="c1"># noinspection PyMethodMayBeStatic</span>
    <span class="k">def</span> <span class="nf">_to_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert input string to edges.</span>

<span class="sd">        Detects if the line in single edge or multi edge format.</span>

<span class="sd">        Single edge formats:</span>

<span class="sd">            tail-&gt;head</span>
<span class="sd">            tail-&gt;head:weight</span>

<span class="sd">        Multi edge formats:</span>

<span class="sd">            tail-&gt;head, head, head</span>

<span class="sd">        Edge is of type namespace:</span>

<span class="sd">            edge.tail</span>
<span class="sd">            edge.head</span>
<span class="sd">            edge.weight if given</span>

<span class="sd">        :param line: input string</span>
<span class="sd">        :return: list of edge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_pattern</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">SimpleNamespace</span><span class="p">()</span>
            <span class="n">edge</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">edge</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multi_edge_pattern</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">rest</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">heads</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                         <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_pattern</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">rest</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">heads</span><span class="p">:</span>
                    <span class="n">edge</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">SimpleNamespace</span><span class="p">()</span>
                    <span class="n">edge</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span>
                    <span class="n">edge</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">edges</span>

<div class="viewcode-block" id="Challenge.line_to_edge"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.line_to_edge">[docs]</a>    <span class="k">def</span> <span class="nf">line_to_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nr</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert one line to an edge.</span>

<span class="sd">        :param nr: line number</span>
<span class="sd">        :return: edge (namespace: tail, head, weight)</span>
<span class="sd">        :see: self._to_edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">nr</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Challenge.line_to_edges"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.line_to_edges">[docs]</a>    <span class="k">def</span> <span class="nf">line_to_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nr</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert one line to multiple edges.</span>

<span class="sd">        1-&gt;2,3,4</span>

<span class="sd">        :param nr: line number</span>
<span class="sd">        :return: edge (namespace: tail, head, weight)</span>
<span class="sd">        :see: self._to_edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">nr</span><span class="p">))</span></div>

<div class="viewcode-block" id="Challenge.lines_to_edges"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.lines_to_edges">[docs]</a>    <span class="k">def</span> <span class="nf">lines_to_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrun a list of edges for range of lines.</span>

<span class="sd">        1-&gt;2       # simple edge</span>
<span class="sd">        1-&gt;2:22    # weighted edge</span>
<span class="sd">        1-&gt;2,3,4   # muliple edges per line</span>

<span class="sd">        If stop is not given all remaining lines are used.</span>

<span class="sd">        :param start:</span>
<span class="sd">        :param stop:</span>
<span class="sd">        :return: list of edges (namespace: tail, head, weight)</span>
<span class="sd">        :see: self._to_edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines_to_list</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
                <span class="n">edges</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_edges</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">edges</span></div>

<div class="viewcode-block" id="Challenge.lines_to_graph"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.lines_to_graph">[docs]</a>    <span class="k">def</span> <span class="nf">lines_to_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrun a graph for range of lines</span>

<span class="sd">        If stop is not given all remaining lines are usee.</span>

<span class="sd">        Formats:</span>

<span class="sd">            1-&gt;2       # simple edge</span>
<span class="sd">            1-&gt;2:22    # weighted edge</span>
<span class="sd">            1-&gt;2,3,4   # muliple edges per line</span>

<span class="sd">        Properties:</span>

<span class="sd">            graph.edges:</span>
<span class="sd">                dict, tails as keys and list of heads as values</span>

<span class="sd">            graph.weights:</span>
<span class="sd">                dict, pairs of tail, head as keys and weight as value</span>

<span class="sd">        :param start:</span>
<span class="sd">        :param stop:</span>
<span class="sd">        :return: graph, namespace with graphs properties</span>
<span class="sd">        :see: self._to_edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">SimpleNamespace</span><span class="p">()</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines_to_list</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
            <span class="n">edges</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_edges</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">head</span><span class="p">)</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">tail</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">head</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">weights</span><span class="p">[(</span><span class="n">edge</span><span class="o">.</span><span class="n">tail</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">head</span><span class="p">)]</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">weight</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">edge_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">node_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">graph</span></div>

<div class="viewcode-block" id="Challenge.edges"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.edges">[docs]</a>    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator to read edges from lines.</span>

<span class="sd">        !!! DEPRECATED !!! use lines_to_edges()</span>

<span class="sd">        Reads a range of lines, one edge per line, and yields the edges.</span>

<span class="sd">        By the start and stop parameters a range can be given.</span>
<span class="sd">        The stop parameter is the index behind the last line to use.</span>

<span class="sd">        The line to start is set by the parameter start. It defaults to zero.</span>
<span class="sd">        The line to stop is set by the parameter stop. When it is not provided</span>
<span class="sd">        lines are used as long as they match the edge_pattern reg expression.</span>
<span class="sd">        The match behaviour can be adjusted by the self.edge_pattern.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_to_edge</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">SimpleNamespace</span><span class="p">()</span>
            <span class="n">edge</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">edge</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">edge</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="n">start</span>
        <span class="k">while</span> <span class="n">nr</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">nr</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_pattern</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">_to_edge</span><span class="p">(</span><span class="n">match</span><span class="p">))</span>
                <span class="n">nr</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>  <span class="c1"># If edges end before stop, which may be infinity</span></div>

<div class="viewcode-block" id="Challenge.fasta"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.fasta">[docs]</a>    <span class="k">def</span> <span class="nf">fasta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator to read FASTA formatted samples.</span>

<span class="sd">        Reads multiple fasta sequences and yields them.</span>

<span class="sd">        By the start and stop parameters a range can be given.</span>
<span class="sd">        The stop parameter is the index behind the last line to use.</span>

<span class="sd">        The line to start is set by the parameter start. It defaults to zero.</span>
<span class="sd">        The line to stop is set by the parameter stop. When it is not provided</span>
<span class="sd">        lines are used as long as they match the FASTA format.</span>
<span class="sd">        The match behaviour can be adjusted by the self.fasta_pattern.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">sequence</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="n">start</span>
        <span class="k">while</span> <span class="n">nr</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">nr</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">sequence</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="c1"># Yield previous sequence if any</span>
                    <span class="k">yield</span> <span class="n">name</span><span class="p">,</span> <span class="n">sequence</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">sequence</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s1">&#39;&#39;</span>  <span class="c1"># Reset</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fasta_pattern</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                    <span class="n">sequence</span> <span class="o">+=</span> <span class="n">line</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>  <span class="c1"># If edges end before stop, which may be infinity</span>
            <span class="n">nr</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Yield final sequence</span>
        <span class="k">yield</span> <span class="n">name</span><span class="p">,</span> <span class="n">sequence</span></div>

<div class="viewcode-block" id="Challenge.fasta_strands"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.fasta_strands">[docs]</a>    <span class="k">def</span> <span class="nf">fasta_strands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the strands of a fasta read as list.</span>

<span class="sd">        Takes the same arguments as self.fasta() and delegates to it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fasta</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>

    <span class="c1"># --------------------------------------------------</span>
    <span class="c1"># Formatting</span>
    <span class="c1"># --------------------------------------------------</span>

    <span class="c1"># noinspection PyMethodMayBeStatic</span>
<div class="viewcode-block" id="Challenge.format_list_of_integers"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.format_list_of_integers">[docs]</a>    <span class="k">def</span> <span class="nf">format_list_of_integers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">integers</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">joint</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Join a list of integers to a string</span>

<span class="sd">        Use the given joint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">joint</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">integers</span><span class="p">)</span></div>

<div class="viewcode-block" id="Challenge.format_path"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.format_path">[docs]</a>    <span class="k">def</span> <span class="nf">format_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">integers</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">backwards</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Join a list of integers to path of nodes.</span>

<span class="sd">        The joint is -&gt; by default. If the parameter</span>
<span class="sd">        backwards is True the joint is &lt;-.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">backwards</span><span class="p">:</span>
            <span class="n">joint</span> <span class="o">=</span> <span class="s1">&#39;&lt;-&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">joint</span> <span class="o">=</span> <span class="s1">&#39;-&gt;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_list_of_integers</span><span class="p">(</span><span class="n">integers</span><span class="p">,</span> <span class="n">joint</span><span class="p">)</span></div>

<div class="viewcode-block" id="Challenge.format_permutations"><a class="viewcode-back" href="../../challenges.xhtml#challenges.challenge.Challenge.format_permutations">[docs]</a>    <span class="k">def</span> <span class="nf">format_permutations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">permutations</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">separator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                            <span class="n">element_separator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="p">):</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="s1">&#39;(&#39;</span>
            <span class="n">entry</span> <span class="o">+=</span> <span class="n">element_separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">(</span><span class="s1">&#39;+&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">)</span>
            <span class="n">entry</span> <span class="o">+=</span> <span class="s1">&#39;)&#39;</span>
            <span class="n">entries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span></div></div>
</pre></div>

          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>