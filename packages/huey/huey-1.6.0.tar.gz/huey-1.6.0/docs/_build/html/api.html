<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Huey’s API &#8212; huey 1.3.0 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Huey Extensions" href="contrib.html" />
    <link rel="prev" title="Troubleshooting and Common Pitfalls" href="troubleshooting.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="contrib.html" title="Huey Extensions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="troubleshooting.html" title="Troubleshooting and Common Pitfalls"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">huey 1.3.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="huey-s-api">
<span id="api"></span><h1>Huey&#8217;s API<a class="headerlink" href="#huey-s-api" title="Permalink to this headline">¶</a></h1>
<p>Most end-users will interact with the API using the two decorators:</p>
<ul class="simple">
<li><a class="reference internal" href="#Huey.task" title="Huey.task"><code class="xref py py-meth docutils literal"><span class="pre">Huey.task()</span></code></a></li>
<li><a class="reference internal" href="#Huey.periodic_task" title="Huey.periodic_task"><code class="xref py py-meth docutils literal"><span class="pre">Huey.periodic_task()</span></code></a></li>
</ul>
<p>The API documentation will follow the structure of the huey API, starting with
the highest-level interfaces (the decorators) and eventually discussing the
lowest-level interfaces, the <code class="xref py py-class docutils literal"><span class="pre">BaseQueue</span></code> and <code class="xref py py-class docutils literal"><span class="pre">BaseDataStore</span></code> objects.</p>
<div class="section" id="function-decorators-and-helpers">
<span id="function-decorators"></span><h2>Function decorators and helpers<a class="headerlink" href="#function-decorators-and-helpers" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Huey">
<em class="property">class </em><code class="descname">Huey</code><span class="sig-paren">(</span><em>name</em><span class="optional">[</span>, <em>result_store=True</em><span class="optional">[</span>, <em>events=True</em><span class="optional">[</span>, <em>store_none=False</em><span class="optional">[</span>, <em>always_eager=False</em><span class="optional">[</span>, <em>store_errors=True</em><span class="optional">[</span>, <em>blocking=False</em><span class="optional">[</span>, <em>**storage_kwargs</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Huey" title="Permalink to this definition">¶</a></dt>
<dd><p>Huey executes tasks by exposing function decorators that cause the function
call to be enqueued for execution by the consumer.</p>
<p>Typically your application will only need one Huey instance, but you can
have as many as you like &#8211; the only caveat is that one consumer process
must be executed for each Huey instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; the name of the huey instance or application.</li>
<li><strong>result_store</strong> (<em>bool</em>) &#8211; whether the results of tasks should be stored.</li>
<li><strong>events</strong> (<em>bool</em>) &#8211; whether events should be emitted by the consumer.</li>
<li><strong>store_none</strong> (<em>bool</em>) &#8211; Flag to indicate whether tasks that return <code class="docutils literal"><span class="pre">None</span></code>
should store their results in the result store.</li>
<li><strong>always_eager</strong> (<em>bool</em>) &#8211; Useful for testing, this will execute all tasks
immediately, without enqueueing them.</li>
<li><strong>store_errors</strong> (<em>bool</em>) &#8211; whether task errors should be stored.</li>
<li><strong>blocking</strong> (<em>bool</em>) &#8211; whether the queue will block (if False, then the queue will poll).</li>
<li><strong>storage_kwargs</strong> &#8211; arbitrary kwargs to pass to the storage implementation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">RedisHuey</span><span class="p">,</span> <span class="n">crontab</span>

<span class="n">huey</span> <span class="o">=</span> <span class="n">RedisHuey</span><span class="p">(</span><span class="s1">&#39;my-app&#39;</span><span class="p">)</span>

<span class="nd">@huey.task</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">slow_function</span><span class="p">(</span><span class="n">some_arg</span><span class="p">):</span>
    <span class="c1"># ... do something ...</span>
    <span class="k">return</span> <span class="n">some_arg</span>

<span class="nd">@huey.periodic_task</span><span class="p">(</span><span class="n">crontab</span><span class="p">(</span><span class="n">minute</span><span class="o">=</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">hour</span><span class="o">=</span><span class="s1">&#39;3&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">backup</span><span class="p">():</span>
    <span class="c1"># do a backup every day at 3am</span>
    <span class="k">return</span>
</pre></div>
</div>
<dl class="method">
<dt id="Huey.task">
<code class="descname">task</code><span class="sig-paren">(</span><span class="optional">[</span><em>retries=0</em><span class="optional">[</span>, <em>retry_delay=0</em><span class="optional">[</span>, <em>retries_as_argument=False</em><span class="optional">[</span>, <em>include_task=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Huey.task" title="Permalink to this definition">¶</a></dt>
<dd><p>Function decorator that marks the decorated function for processing by the
consumer. Calls to the decorated function will do the following:</p>
<ol class="arabic simple">
<li>Serialize the function call into a message suitable for storing in the queue</li>
<li>Enqueue the message for execution by the consumer</li>
<li>If a <code class="docutils literal"><span class="pre">result_store</span></code> has been configured, return an <a class="reference internal" href="#TaskResultWrapper" title="TaskResultWrapper"><code class="xref py py-class docutils literal"><span class="pre">TaskResultWrapper</span></code></a>
instance which can retrieve the result of the function, or <code class="docutils literal"><span class="pre">None</span></code> if not
using a result store.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Huey can be configured to execute the function immediately by
instantiating it with <code class="docutils literal"><span class="pre">always_eager</span> <span class="pre">=</span> <span class="pre">True</span></code> &#8211; this is useful for
running in debug mode or when you do not wish to run the consumer.</p>
</div>
<p>Here is how you might use the <code class="docutils literal"><span class="pre">task</span></code> decorator:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># assume that we&#39;ve created a huey object</span>
<span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">RedisHuey</span>

<span class="n">huey</span> <span class="o">=</span> <span class="n">RedisHuey</span><span class="p">()</span>

<span class="nd">@huey.task</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">count_some_beans</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="c1"># do some counting!</span>
    <span class="k">return</span> <span class="s1">&#39;Counted </span><span class="si">%s</span><span class="s1"> beans&#39;</span> <span class="o">%</span> <span class="n">num</span>
</pre></div>
</div>
<p>Now, whenever you call this function in your application, the actual processing
will occur when the consumer dequeues the message and your application will
continue along on its way.</p>
<p>Without a result store:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">count_some_beans</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>With a result store:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">count_some_beans</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span>
<span class="go">&lt;huey.api.TaskResultWrapper object at 0xb7471a4c&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="p">()</span>
<span class="go">&#39;Counted 1000000 beans&#39;</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>retries</strong> (<em>int</em>) &#8211; number of times to retry the task if an exception occurs</li>
<li><strong>retry_delay</strong> (<em>int</em>) &#8211; number of seconds to wait between retries</li>
<li><strong>retries_as_argument</strong> (<em>boolean</em>) &#8211; whether the number of retries should
be passed in to the decorated function as an argument.</li>
<li><strong>include_task</strong> (<em>boolean</em>) &#8211; whether the task instance itself should be
passed in to the decorated function as the <code class="docutils literal"><span class="pre">task</span></code> argument.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">decorated function</p>
</td>
</tr>
</tbody>
</table>
<p>The return value of any calls to the decorated function depends on whether
the <a class="reference internal" href="#Huey" title="Huey"><code class="xref py py-class docutils literal"><span class="pre">Huey</span></code></a> instance is configured with a <code class="docutils literal"><span class="pre">result_store</span></code>.  If a
result store is configured, the decorated function will return
an <a class="reference internal" href="#TaskResultWrapper" title="TaskResultWrapper"><code class="xref py py-class docutils literal"><span class="pre">TaskResultWrapper</span></code></a> object which can fetch the result of the call from
the result store &#8211; otherwise it will simply return <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">task</span></code> decorator also does one other important thing &#8211; it adds
a special function <strong>onto</strong> the decorated function, which makes it possible
to <em>schedule</em> the execution for a certain time in the future:</p>
<dl class="function">
<dt>
<code class="descname">{decorated func}.schedule(args=None, kwargs=None, eta=None, delay=None, convert_utc=True)</code></dt>
<dd><p>Use the special <code class="docutils literal"><span class="pre">schedule</span></code> function to schedule the execution of a
queue task for a given time in the future:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">datetime</span>

<span class="c1"># get a datetime object representing one hour in the future</span>
<span class="n">in_an_hour</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">3600</span><span class="p">)</span>

<span class="c1"># schedule &quot;count_some_beans&quot; to run in an hour</span>
<span class="n">count_some_beans</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">100000</span><span class="p">,),</span> <span class="n">eta</span><span class="o">=</span><span class="n">in_an_hour</span><span class="p">)</span>

<span class="c1"># another way of doing the same thing...</span>
<span class="n">count_some_beans</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">100000</span><span class="p">,),</span> <span class="n">delay</span><span class="o">=</span><span class="p">(</span><span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> &#8211; arguments to call the decorated function with</li>
<li><strong>kwargs</strong> &#8211; keyword arguments to call the decorated function with</li>
<li><strong>eta</strong> (<em>datetime</em>) &#8211; the time at which the function should be executed</li>
<li><strong>delay</strong> (<em>int</em>) &#8211; number of seconds to wait before executing function</li>
<li><strong>convert_utc</strong> &#8211; whether the <code class="docutils literal"><span class="pre">eta</span></code> or <code class="docutils literal"><span class="pre">delay</span></code> should be converted from local time to UTC, defaults to <code class="docutils literal"><span class="pre">True</span></code>. If you are running your consumer in <code class="docutils literal"><span class="pre">localtime</span></code> mode, you should probably specify <code class="docutils literal"><span class="pre">False</span></code> here.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">like calls to the decorated function, will return an <a class="reference internal" href="#TaskResultWrapper" title="TaskResultWrapper"><code class="xref py py-class docutils literal"><span class="pre">TaskResultWrapper</span></code></a>
object if a result store is configured, otherwise returns <code class="docutils literal"><span class="pre">None</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">{decorated func}.call_local</code></dt>
<dd><p>Call the <code class="docutils literal"><span class="pre">&#64;task</span></code>-decorated function without enqueueing the call. Or, in other words, <code class="docutils literal"><span class="pre">call_local()</span></code> provides access to the actual function.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">count_some_beans</span><span class="o">.</span><span class="n">call_local</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>
<span class="go">&#39;Counted 1337 beans&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">{decorated func}.task_class</code></dt>
<dd><p>Store a reference to the task class for the decorated function.</p>
<div class="highlight-pycon"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">count_some_beans</span><span class="o">.</span><span class="n">task_class</span>
<span class="go">tasks.queuecmd_count_beans</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="Huey.periodic_task">
<code class="descname">periodic_task</code><span class="sig-paren">(</span><em>validate_datetime</em><span class="sig-paren">)</span><a class="headerlink" href="#Huey.periodic_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Function decorator that marks the decorated function for processing by the
consumer <em>at a specific interval</em>.  Calls to functions decorated with <code class="docutils literal"><span class="pre">periodic_task</span></code>
will execute normally, unlike <a class="reference internal" href="#Huey.task" title="Huey.task"><code class="xref py py-meth docutils literal"><span class="pre">task()</span></code></a>, which enqueues tasks
for execution by the consumer.  Rather, the <code class="docutils literal"><span class="pre">periodic_task</span></code> decorator
serves to <strong>mark a function as needing to be executed periodically</strong> by the
consumer.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">By default, the consumer will execute <code class="docutils literal"><span class="pre">periodic_task</span></code> functions. To
disable this, run the consumer with <code class="docutils literal"><span class="pre">-n</span></code> or <code class="docutils literal"><span class="pre">--no-periodic</span></code>.</p>
</div>
<p>The <code class="docutils literal"><span class="pre">validate_datetime</span></code> parameter is a function which accepts a datetime
object and returns a boolean value whether or not the decorated function
should execute at that time or not.  The consumer will send a datetime to
the function every minute, giving it the same granularity as the linux
crontab, which it was designed to mimic.</p>
<p>For simplicity, there is a special function <a class="reference internal" href="#crontab" title="crontab"><code class="xref py py-func docutils literal"><span class="pre">crontab()</span></code></a>, which can
be used to quickly specify intervals at which a function should execute.  It
is described below.</p>
<p>Here is an example of how you might use the <code class="docutils literal"><span class="pre">periodic_task</span></code> decorator
and the <code class="docutils literal"><span class="pre">crontab</span></code> helper:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">crontab</span>
<span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">RedisHuey</span>

<span class="n">huey</span> <span class="o">=</span> <span class="n">RedisHuey</span><span class="p">()</span>

<span class="nd">@huey.periodic_task</span><span class="p">(</span><span class="n">crontab</span><span class="p">(</span><span class="n">minute</span><span class="o">=</span><span class="s1">&#39;*/5&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">every_five_minutes</span><span class="p">():</span>
    <span class="c1"># this function gets executed every 5 minutes by the consumer</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s been five minutes&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because functions decorated with <code class="docutils literal"><span class="pre">periodic_task</span></code> are meant to be
executed at intervals in isolation, they should not take any required
parameters nor should they be expected to return a meaningful value.
This is the same regardless of whether or not you are using a result store.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>validate_datetime</strong> &#8211; a callable which takes a <code class="docutils literal"><span class="pre">datetime</span></code> and returns
a boolean whether the decorated function should execute at that time or not</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">decorated function</td>
</tr>
</tbody>
</table>
<p>Like <a class="reference internal" href="#Huey.task" title="Huey.task"><code class="xref py py-meth docutils literal"><span class="pre">task()</span></code></a>, the periodic task decorator adds several helpers
to the decorated function.  These helpers allow you to &#8220;revoke&#8221; and &#8220;restore&#8221; the
periodic task, effectively enabling you to pause it or prevent its execution.</p>
<dl class="function">
<dt>
<code class="descname">{decorated_func}.revoke([revoke_until=None[, revoke_once=False]])</code></dt>
<dd><p>Prevent the given periodic task from executing.  When no parameters are
provided the function will not execute again.</p>
<p>This function can be called multiple times, but each call will overwrite
the limitations of the previous.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>revoke_until</strong> (<em>datetime</em>) &#8211; Prevent the execution of the task until the
given datetime.  If <code class="docutils literal"><span class="pre">None</span></code> it will prevent execution indefinitely.</li>
<li><strong>revoke_once</strong> (<em>bool</em>) &#8211; If <code class="docutils literal"><span class="pre">True</span></code> will only prevent execution the next
time it would normally execute.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># skip the next execution</span>
<span class="n">every_five_minutes</span><span class="o">.</span><span class="n">revoke</span><span class="p">(</span><span class="n">revoke_once</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># pause the command indefinitely</span>
<span class="n">every_five_minutes</span><span class="o">.</span><span class="n">revoke</span><span class="p">()</span>

<span class="c1"># pause the command for 24 hours</span>
<span class="n">every_five_minutes</span><span class="o">.</span><span class="n">revoke</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">{decorated_func}.is_revoked([dt=None])</code></dt>
<dd><p>Check whether the given periodic task is revoked.  If <code class="docutils literal"><span class="pre">dt</span></code> is specified,
it will check if the task is revoked for the given datetime.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dt</strong> (<em>datetime</em>) &#8211; If provided, checks whether task is revoked at the
given datetime</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">{decorated_func}.restore()</code></dt>
<dd><p>Clears any revoked status and run the task normally</p>
</dd></dl>

<p>If you want access to the underlying task class, it is stored as an attribute
on the decorated function:</p>
<dl class="attribute">
<dt>
<code class="descname">{decorated_func}.task_class</code></dt>
<dd><p>Store a reference to the task class for the decorated function.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="Huey.revoke">
<code class="descname">revoke</code><span class="sig-paren">(</span><em>task</em><span class="optional">[</span>, <em>revoke_until=None</em><span class="optional">[</span>, <em>revoke_once=False</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Huey.revoke" title="Permalink to this definition">¶</a></dt>
<dd><p>Prevent the given task from being executed by the consumer after it has
been enqueued. To understand this method, you need to know a bit about
how the consumer works. When you call a function decorated by the
<a class="reference internal" href="#Huey.task" title="Huey.task"><code class="xref py py-meth docutils literal"><span class="pre">Huey.task()</span></code></a> method, calls to that function will enqueue a
message to the consumer indicating which task to execute, what the
parameters are, etc. If the task is not scheduled to execute in the
future, and there is a free worker available, the task starts executing
immediately. Otherwise if workers are busy, it will wait in line for
the next free worker.</p>
<p>When you revoke a task, when the worker picks up the revoked task to
start executing it, it will instead just throw it away and get the next
available task. So, revoking a task only has affect between the time
you call the task and the time the worker actually starts executing the
task.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When the revoked task is a periodic task, this affects the task as
a whole. When the task is a normal task, the revocation action only
applies to the given task instance.</p>
</div>
<p>This function can be called multiple times, but each call will overwrite
any previous revoke settings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>revoke_until</strong> (<em>datetime</em>) &#8211; Prevent the execution of the task until the
given datetime.  If <code class="docutils literal"><span class="pre">None</span></code> it will prevent execution indefinitely.</li>
<li><strong>revoke_once</strong> (<em>bool</em>) &#8211; If <code class="docutils literal"><span class="pre">True</span></code> will only prevent execution the
next time it would normally execute.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Huey.restore">
<code class="descname">restore</code><span class="sig-paren">(</span><em>task</em><span class="sig-paren">)</span><a class="headerlink" href="#Huey.restore" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a previously revoked task and un-revokes it.</p>
</dd></dl>

<dl class="method">
<dt id="Huey.revoke_by_id">
<code class="descname">revoke_by_id</code><span class="sig-paren">(</span><em>task_id</em><span class="optional">[</span>, <em>revoke_until=None</em><span class="optional">[</span>, <em>revoke_once=False</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Huey.revoke_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Exactly the same as <a class="reference internal" href="#Huey.revoke" title="Huey.revoke"><code class="xref py py-meth docutils literal"><span class="pre">Huey.revoke()</span></code></a>, except it accepts a task ID
instead of the task instance itself.</p>
</dd></dl>

<dl class="method">
<dt id="Huey.restore_by_id">
<code class="descname">restore_by_id</code><span class="sig-paren">(</span><em>task_id</em><span class="sig-paren">)</span><a class="headerlink" href="#Huey.restore_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Exactly the same as <a class="reference internal" href="#Huey.restore" title="Huey.restore"><code class="xref py py-meth docutils literal"><span class="pre">Huey.restore()</span></code></a>, except it accepts a task ID
instead of the task instance itself.</p>
</dd></dl>

<dl class="method">
<dt id="Huey.is_revoked">
<code class="descname">is_revoked</code><span class="sig-paren">(</span><em>task</em><span class="optional">[</span>, <em>dt=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Huey.is_revoked" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean indicating whether the given task is revoked. If the
<code class="docutils literal"><span class="pre">dt</span></code> parameter is specified, then the result will indicate whether
the task is revoked at that particular datetime.</p>
</dd></dl>

<dl class="method">
<dt id="Huey.result">
<code class="descname">result</code><span class="sig-paren">(</span><em>task_id</em><span class="optional">[</span>, <em>blocking=False</em><span class="optional">[</span>, <em>timeout=None</em><span class="optional">[</span>, <em>backoff=1.15</em><span class="optional">[</span>, <em>max_delay=1.0</em><span class="optional">[</span>, <em>revoke_on_timeout=False</em><span class="optional">[</span>, <em>preserve=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Huey.result" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to retrieve the return value of a task.  By default, <a class="reference internal" href="#Huey.result" title="Huey.result"><code class="xref py py-meth docutils literal"><span class="pre">result()</span></code></a>
will simply check for the value, returning <code class="docutils literal"><span class="pre">None</span></code> if it is not ready yet.
If you want to wait for a value, you can specify <code class="docutils literal"><span class="pre">blocking=True</span></code>.
This will loop, backing off up to the provided <code class="docutils literal"><span class="pre">max_delay</span></code>, until the
value is ready or the <code class="docutils literal"><span class="pre">timeout</span></code> is reached. If the <code class="docutils literal"><span class="pre">timeout</span></code>
is reached before the result is ready, a <code class="xref py py-class docutils literal"><span class="pre">DataStoreTimeout</span></code>
exception will be raised.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">By default the result store will delete a task&#8217;s return
value after the value has been successfully read (by a successful
call to the <a class="reference internal" href="#Huey.result" title="Huey.result"><code class="xref py py-meth docutils literal"><span class="pre">result()</span></code></a> or <a class="reference internal" href="#TaskResultWrapper.get" title="TaskResultWrapper.get"><code class="xref py py-meth docutils literal"><span class="pre">TaskResultWrapper.get()</span></code></a>
methods). If you need to use the task result multiple times, you
must specify <code class="docutils literal"><span class="pre">preserve=True</span></code> when calling these methods.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>task_id</strong> &#8211; the task&#8217;s unique identifier.</li>
<li><strong>blocking</strong> (<em>bool</em>) &#8211; whether to block while waiting for task result</li>
<li><strong>timeout</strong> &#8211; number of seconds to block (if <code class="docutils literal"><span class="pre">blocking=True</span></code>)</li>
<li><strong>backoff</strong> &#8211; amount to backoff delay each iteration of loop</li>
<li><strong>max_delay</strong> &#8211; maximum amount of time to wait between iterations when
attempting to fetch result.</li>
<li><strong>revoke_on_timeout</strong> (<em>bool</em>) &#8211; if a timeout occurs, revoke the task,
thereby preventing it from running if it is has not started yet.</li>
<li><strong>preserve</strong> (<em>bool</em>) &#8211; see the above warning. When set to <code class="docutils literal"><span class="pre">True</span></code>, this
parameter ensures that the task result should be preserved after
having been successfully retrieved.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Huey.pending">
<code class="descname">pending</code><span class="sig-paren">(</span><span class="optional">[</span><em>limit=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Huey.pending" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all unexecuted tasks currently in the queue.</p>
</dd></dl>

<dl class="method">
<dt id="Huey.scheduled">
<code class="descname">scheduled</code><span class="sig-paren">(</span><span class="optional">[</span><em>limit=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Huey.scheduled" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all unexecuted tasks currently in the schedule.</p>
</dd></dl>

<dl class="method">
<dt id="Huey.all_results">
<code class="descname">all_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Huey.all_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a mapping of task-id to pickled result data for all executed tasks whose return values have not been automatically removed.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="crontab">
<code class="descname">crontab</code><span class="sig-paren">(</span><em>month='*'</em>, <em>day='*'</em>, <em>day_of_week='*'</em>, <em>hour='*'</em>, <em>minute='*'</em><span class="sig-paren">)</span><a class="headerlink" href="#crontab" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a &#8220;crontab&#8221;-style set of parameters into a test function that will
return <code class="docutils literal"><span class="pre">True</span></code> when a given <code class="docutils literal"><span class="pre">datetime</span></code> matches the parameters set forth in
the crontab.</p>
<p>Acceptable inputs:</p>
<ul class="simple">
<li>&#8220;*&#8221; = every distinct value</li>
<li>&#8220;*/n&#8221; = run every &#8220;n&#8221; times, i.e. hours=&#8217;*/4&#8217; == 0, 4, 8, 12, 16, 20</li>
<li>&#8220;m-n&#8221; = run every time m..n</li>
<li>&#8220;m,n&#8221; = run on m and n</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">a test function that takes a <code class="docutils literal"><span class="pre">datetime</span></code> and returns a boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="taskresultwrapper">
<h2>TaskResultWrapper<a class="headerlink" href="#taskresultwrapper" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="TaskResultWrapper">
<em class="property">class </em><code class="descname">TaskResultWrapper</code><span class="sig-paren">(</span><em>huey</em>, <em>task</em><span class="sig-paren">)</span><a class="headerlink" href="#TaskResultWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Although you will probably never instantiate an <code class="docutils literal"><span class="pre">TaskResultWrapper</span></code> object yourself,
they are returned by any calls to <a class="reference internal" href="#Huey.task" title="Huey.task"><code class="xref py py-meth docutils literal"><span class="pre">task()</span></code></a> decorated functions
(provided that <em>huey</em> is configured with a result store).  The <code class="docutils literal"><span class="pre">TaskResultWrapper</span></code>
talks to the result store and is responsible for fetching results from tasks.</p>
<p>Once the consumer finishes executing a task, the return value is placed in the
result store, allowing the producer to retrieve it.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">By default, the data is removed from the result store after
being read, but this behavior can be disabled.</p>
</div>
<p>Getting results from tasks is very simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">main</span> <span class="kn">import</span> <span class="n">count_some_beans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">count_some_beans</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span>  <span class="c1"># what is &quot;res&quot; ?</span>
<span class="go">&lt;huey.queue.TaskResultWrapper object at 0xb7471a4c&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="p">()</span>  <span class="c1"># Fetch the result of this task.</span>
<span class="go">&#39;Counted 100 beans&#39;</span>
</pre></div>
</div>
<p>What happens when data isn&#8217;t available yet?  Let&#8217;s assume the next call takes
about a minute to calculate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&gt;&gt;&gt; res = count_some_beans(10000000) # let&#39;s pretend this is slow
&gt;&gt;&gt; res.get()  # Data is not ready, so None is returned.

&gt;&gt;&gt; res() is None  # We can omit &quot;.get&quot;, it works the same way.
True

&gt;&gt;&gt; res(blocking=True, timeout=5)  # Block for up to 5 seconds
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;/home/charles/tmp/huey/src/huey/huey/queue.py&quot;, line 46, in get
    raise DataStoreTimeout
huey.exceptions.DataStoreTimeout

&gt;&gt;&gt; res(blocking=True)  # No timeout, will block until it gets data.
&#39;Counted 10000000 beans&#39;
</pre></div>
</div>
<dl class="method">
<dt id="TaskResultWrapper.get">
<code class="descname">get</code><span class="sig-paren">(</span><span class="optional">[</span><em>blocking=False</em><span class="optional">[</span>, <em>timeout=None</em><span class="optional">[</span>, <em>backoff=1.15</em><span class="optional">[</span>, <em>max_delay=1.0</em><span class="optional">[</span>, <em>revoke_on_timeout=False</em><span class="optional">[</span>, <em>preserve=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#TaskResultWrapper.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to retrieve the return value of a task.  By default, <a class="reference internal" href="#TaskResultWrapper.get" title="TaskResultWrapper.get"><code class="xref py py-meth docutils literal"><span class="pre">get()</span></code></a>
will simply check for the value, returning <code class="docutils literal"><span class="pre">None</span></code> if it is not ready yet.
If you want to wait for a value, you can specify <code class="docutils literal"><span class="pre">blocking=True</span></code>.
This will loop, backing off up to the provided <code class="docutils literal"><span class="pre">max_delay</span></code>, until the
value is ready or the <code class="docutils literal"><span class="pre">timeout</span></code> is reached. If the <code class="docutils literal"><span class="pre">timeout</span></code>
is reached before the result is ready, a <code class="xref py py-class docutils literal"><span class="pre">DataStoreTimeout</span></code>
exception will be raised.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">By default the result store will delete a task&#8217;s return
value after the value has been successfully read (by a successful
call to the <a class="reference internal" href="#Huey.result" title="Huey.result"><code class="xref py py-meth docutils literal"><span class="pre">result()</span></code></a> or <a class="reference internal" href="#TaskResultWrapper.get" title="TaskResultWrapper.get"><code class="xref py py-meth docutils literal"><span class="pre">TaskResultWrapper.get()</span></code></a>
methods). If you need to use the task result multiple times, you
must specify <code class="docutils literal"><span class="pre">preserve=True</span></code> when calling these methods.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Instead of calling <code class="docutils literal"><span class="pre">.get()</span></code>, you can simply call the
<a class="reference internal" href="#TaskResultWrapper" title="TaskResultWrapper"><code class="xref py py-class docutils literal"><span class="pre">TaskResultWrapper</span></code></a> object directly. Both methods accept the
same parameters.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>blocking</strong> (<em>bool</em>) &#8211; whether to block while waiting for task result</li>
<li><strong>timeout</strong> &#8211; number of seconds to block (if <code class="docutils literal"><span class="pre">blocking=True</span></code>)</li>
<li><strong>backoff</strong> &#8211; amount to backoff delay each iteration of loop</li>
<li><strong>max_delay</strong> &#8211; maximum amount of time to wait between iterations when
attempting to fetch result.</li>
<li><strong>revoke_on_timeout</strong> (<em>bool</em>) &#8211; if a timeout occurs, revoke the task,
thereby preventing it from running if it is has not started yet.</li>
<li><strong>preserve</strong> (<em>bool</em>) &#8211; see the above warning. When set to <code class="docutils literal"><span class="pre">True</span></code>, this
parameter ensures that the task result should be preserved after
having been successfully retrieved.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TaskResultWrapper.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#TaskResultWrapper.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to the <a class="reference internal" href="#TaskResultWrapper.get" title="TaskResultWrapper.get"><code class="xref py py-meth docutils literal"><span class="pre">get()</span></code></a> method, provided as a
shortcut.</p>
</dd></dl>

<dl class="method">
<dt id="TaskResultWrapper.revoke">
<code class="descname">revoke</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TaskResultWrapper.revoke" title="Permalink to this definition">¶</a></dt>
<dd><p>Revoke the given task.  Unless it is in the process of executing, it will
be revoked and the task will not run.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">in_an_hour</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">3600</span><span class="p">)</span>

<span class="c1"># run this command in an hour</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">count_some_beans</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">100000</span><span class="p">,),</span> <span class="n">eta</span><span class="o">=</span><span class="n">in_an_hour</span><span class="p">)</span>

<span class="c1"># oh shoot, I changed my mind, do not run it after all</span>
<span class="n">res</span><span class="o">.</span><span class="n">revoke</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="TaskResultWrapper.restore">
<code class="descname">restore</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TaskResultWrapper.restore" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore the given task.  Unless it has already been skipped over, it
will be restored and run as scheduled.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Huey&#8217;s API</a><ul>
<li><a class="reference internal" href="#function-decorators-and-helpers">Function decorators and helpers</a></li>
<li><a class="reference internal" href="#taskresultwrapper">TaskResultWrapper</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="troubleshooting.html"
                        title="previous chapter">Troubleshooting and Common Pitfalls</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="contrib.html"
                        title="next chapter">Huey Extensions</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/api.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="contrib.html" title="Huey Extensions"
             >next</a> |</li>
        <li class="right" >
          <a href="troubleshooting.html" title="Troubleshooting and Common Pitfalls"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">huey 1.3.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013, charles leifer.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.5.
    </div>
  </body>
</html>