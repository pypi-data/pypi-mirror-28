# -*- coding: utf-8 -*-

"""
.. module:: amsaf
   :synopsis: A functional(ish) implementation of AMSAF

AMSAF is comprised of several utility functions which wrap SimpleITK and Elastix
to facilitate easy registration, transformation, and segmentation
of .nii images. It's core functionality, amsaf_eval,
allows for quicker development of Elastix parameter maps by generating and
ranking the results of parameter map instances in a caller-defined search space.
"""

import os

import SimpleITK as sitk
from sklearn.model_selection import ParameterGrid


###########################
# Public module functions #
###########################


def amsaf_eval(unsegmented_image,
               ground_truth,
               segmented_image,
               segmentation,
               parameter_priors=None,
               verbose=False):
    """Main AMSAF functionality

    Generate and score new segmentations and corresponding Elastix parameter
    maps.

    :param unsegmented_image: The target for segmentation and scoring.
    :param ground_truth: The segmentation slice of unsegmented_image used as a
                         ground truth to score images generated by AMSAF.
    :param segmented_image: The image we want to map a segmentation from.
    :param segmentation: The segmentation corresponding to segmented_image.
    :param parameter_priors: An optional vector of 3 ParameterGrid-style dicts
                             mapping Elastix parameter map keys to lists of
                             values. Each value list will be substituted
                             in for the corresponding key in a default dict
                             so that the caller can specify specific
                             combinations of values for some keys, usually to
                             constrain the search space for testing or time
                             consideration.
    :param verbose: Optional boolean flag to toggle verbose stdout printing from
                    Elastix.
    :type unsegmented_image: SimpleITK.Image
    :type ground_truth: SimpleITK.Image
    :type segmented_image: SimpleITK.Image
    :type segmentation: SimpleITK.Image
    :type parameter_priors: dict
    :type verbose: bool
    :returns: A lazy stream of result
              (parameter map, result segmentation, segmentation score) lists.
    :rtype: generator
    """

    def eval_pm(parameter_map):
        seg = segment(
            unsegmented_image,
            segmented_image,
            segmentation,
            parameter_map,
            verbose=verbose)
        score = _sim_score(seg, ground_truth)
        return [parameter_map, seg, score]

    def param_combinations(option_dict, transform_type):
        return (_to_elastix(pm, transform_type)
                for pm in ParameterGrid(option_dict))

    if not parameter_priors:
        parameter_priors = _get_default_vector()

    for rpm in param_combinations(parameter_priors[0], 'rigid'):
        for apm in param_combinations(parameter_priors[1], 'affine'):
            for bpm in param_combinations(parameter_priors[2], 'bspline'):
                yield eval_pm([rpm, apm, bpm])


def read_image(path):
    """Load image from filepath as SimpleITK.Image

    :param path: Path to .nii file containing image.
    :type path: str
    :returns: Image object from path
    :rtype: SimpleITK.Image
    """
    return sitk.ReadImage(path)


def write_image(image, path):
    """Write an image to file

    :param image: Image to be written
    :param path: Destination where image will be written to
    :type image: SimpleITK.Image
    :type path: str
    :rtype: None
    """
    sitk.WriteImage(image, path)


def top_k(k, amsaf_results):
    """Get top k results of amsaf_eval

    :param k: Number of results to return
    :param amsaf_results: Results in the format of amsaf_eval return value
    :type k: int
    :type amsaf_result: [[SimpleITK.ParameterMap, SimpleITK.Image, float]]
    :returns: Top k result groups ordered by score
    :rtype: [[SimpleITK.ParameterMap, SimpleITK.Image, float]]
    """
    return sorted(amsaf_results, key=lambda x: x[-1], reverse=True)[:k]


def write_top_k(k, amsaf_results, path):
    """Write top k results to filepath

    Results are written as subdirectories "result-i" for 0 < i <= k.
    Each subdirectory contains the result's corresponding parameter maps,
    segmentation, and score.

    :param k: Number of results to write
    :param amsaf_results: Results in the format of amsaf_eval return value
    :param path: Filepath to write results at
    :type: k: int
    :type amsaf_result: [[SimpleITK.ParameterMap, SimpleITK.Image, float]]
    :type path: str
    :rtype: None
    """
    if not os.path.isdir(path):
        os.makedirs(path)
    for i, result in enumerate(top_k(k, amsaf_results)):
        write_result(result, os.path.join(path, 'result-{}'.format(i)))


def write_result(amsaf_result, path):
    """Write single amsaf_eval result to path

    Writes parameter maps, segmentation, and score of AMSAF result as individual
    files at path.

    :param amsaf_results: Results in the format of amsaf_eval return value
    :param path: Filepath to write results at
    :type amsaf_result: [SimpleITK.ParameterMap, SimpleITK.Image, float]
    :type path: str
    :rtype: None
    """
    if not os.path.isdir(path):
        os.makedirs(path)
    for i, pf in enumerate(amsaf_result[0]):
        sitk.WriteParameterFile(pf,
                                os.path.join(
                                    path, 'parameter-file-{}.txt'.format(i)))

    sitk.WriteImage(amsaf_result[1], os.path.join(path, 'seg.nii'))

    with open(os.path.join(path, 'score.txt'), 'w') as f:
        f.write(str(amsaf_result[2]))


def register(fixed_image,
             moving_image,
             parameter_maps=None,
             auto_init=True,
             verbose=False):
    """Register images using Elastix.

    :param parameter_maps: Optional vector of 3 parameter maps to be used for
                           registration. If none are provided, a default vector
                           of [rigid, affine, bspline] parameter maps is used.
    :param auto_init: Auto-initialize images. This helps with flexibility when
                      using images with little overlap.
    :param verbose: Flag to toggle stdout printing from Elastix
    :type fixed_image: SimpleITK.Image
    :type moving_image: SimpleITK.Image
    :type parameter_maps: [SimpleITK.ParameterMap]
    :type auto_init: bool
    :type verbose: bool
    :returns: Tuple of (result_image, transform_parameter_maps)
    :rtype: (SimpleITK.Image, [SimpleITK.ParameterMap])
    """
    registration_filter = sitk.ElastixImageFilter()
    if not verbose:
        registration_filter.LogToConsoleOff()
    registration_filter.SetFixedImage(fixed_image)
    registration_filter.SetMovingImage(moving_image)

    if not parameter_maps:
        parameter_maps = [
            sitk.GetDefaultParameterMap(t)
            for t in ['translation', 'affine', 'bspline']
        ]
    if auto_init:
        parameter_maps = _auto_init_assoc(parameter_maps)
    registration_filter.SetParameterMap(parameter_maps[0])
    for m in parameter_maps[1:]:
        registration_filter.AddParameterMap(m)

    registration_filter.Execute()
    result_image = registration_filter.GetResultImage()
    transform_parameter_maps = registration_filter.GetTransformParameterMap()

    return result_image, transform_parameter_maps


def segment(unsegmented_image,
            segmented_image,
            segmentation,
            parameter_maps=None,
            verbose=False):
    """Segment image using Elastix

    :param segmented_image: Image with corresponding segmentation passed as
                            the next argument
    :param segmentation: Segmentation to be mapped from segmented_image to
                         unsegmented_image
    :param parameter_maps: Optional vector of 3 parameter maps to be used for
                           registration. If none are provided, a default vector
                           of [rigid, affine, bspline] parameter maps is used.
    :param verbose: Flag to toggle stdout printing from Elastix
    :type unsegmented_image: SimpleITK.Image
    :type segmented_image: SimpleITK.Image
    :type segmentation: SimpleITK.Image
    :type parameter_maps: [SimpleITK.ParameterMap]
    :type verbose: bool
    :returns: Segmentation mapped from segmented_image to unsegmented_image
    :rtype: SimpleITK.Image
    """
    _, transform_parameter_maps = register(
        unsegmented_image, segmented_image, parameter_maps, verbose=verbose)

    return transform(
        segmentation, _nn_assoc(transform_parameter_maps), verbose=verbose)


def transform(image, parameter_maps, verbose=False):
    """Transform an image according to some vector of parameter maps

    :param image: Image to be transformed
    :param parameter_maps: Vector of 3 parameter maps used to dictate the
                           image transformation
    :type image: SimpleITK.Image
    :type parameter_maps: [SimpleITK.ParameterMap]
    :returns: Transformed image
    :rtype: SimpleITK.Image
    """
    transform_filter = sitk.TransformixImageFilter()
    if not verbose:
        transform_filter.LogToConsoleOff()
    transform_filter.SetTransformParameterMap(parameter_maps)
    transform_filter.SetMovingImage(image)
    transform_filter.Execute()
    result_image = transform_filter.GetResultImage()

    return result_image


##########################
# Private module helpers #
##########################


def _to_elastix(pm, ttype):
    elastix_pm = sitk.GetDefaultParameterMap(ttype)
    for k, v in pm.iteritems():
        elastix_pm[k] = [v]
    return elastix_pm


def _sim_score(candidate, ground_truth):
    candidate = sitk.Cast(candidate, ground_truth.GetPixelID())
    candidate.CopyInformation(ground_truth)

    overlap_filter = sitk.LabelOverlapMeasuresImageFilter()
    overlap_filter.Execute(ground_truth, candidate)
    return overlap_filter.GetDiceCoefficient()


def _nn_assoc(pms):
    return _pm_vec_assoc('ResampleInterpolator',
                         'FinalNearestNeighborInterpolator', pms)


def _auto_init_assoc(pms):
    return _pm_vec_assoc('AutomaticTransformInitialization', 'true', pms)


def _pm_assoc(k, v, pm):
    result = {}
    for key, val in pm.iteritems():
        if key == k:
            result[key] = [v]
        else:
            result[key] = val
    return result


def _pm_vec_assoc(k, v, pms):
    return [_pm_assoc(k, v, pm) for pm in pms]


def _get_default_vector():
    return default_vector
