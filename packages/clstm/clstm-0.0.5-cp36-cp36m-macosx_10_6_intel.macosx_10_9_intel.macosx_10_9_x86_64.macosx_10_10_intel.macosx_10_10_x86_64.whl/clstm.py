# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""C-version of the ocropy LSTM implementation"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_clstm')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_clstm')
    _clstm = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_clstm', [dirname(__file__)])
        except ImportError:
            import _clstm
            return _clstm
        try:
            _mod = imp.load_module('_clstm', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _clstm = swig_import_helper()
    del swig_import_helper
else:
    import _clstm
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

SHARED_PTR_DISOWN = _clstm.SHARED_PTR_DISOWN
class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _clstm.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _clstm.SwigPyIterator_value(self)


    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _clstm.SwigPyIterator_incr(self, n)


    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _clstm.SwigPyIterator_decr(self, n)


    def distance(self, x):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _clstm.SwigPyIterator_distance(self, x)


    def equal(self, x):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _clstm.SwigPyIterator_equal(self, x)


    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _clstm.SwigPyIterator_copy(self)


    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _clstm.SwigPyIterator_next(self)


    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _clstm.SwigPyIterator___next__(self)


    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _clstm.SwigPyIterator_previous(self)


    def advance(self, n):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _clstm.SwigPyIterator_advance(self, n)


    def __eq__(self, x):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _clstm.SwigPyIterator___eq__(self, x)


    def __ne__(self, x):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _clstm.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _clstm.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _clstm.SwigPyIterator___isub__(self, n)


    def __add__(self, n):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _clstm.SwigPyIterator___add__(self, n)


    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _clstm.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _clstm.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class Classes(_object):
    """Proxy of C++ Classes class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Classes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Classes, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(Classes self) -> Classes"""
        this = _clstm.new_Classes()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clstm.delete_Classes
    __del__ = lambda self: None

    def __getitem__(self, i):
        """__getitem__(Classes self, int i) -> int"""
        return _clstm.Classes___getitem__(self, i)


    def size(self):
        """size(Classes self) -> int"""
        return _clstm.Classes_size(self)


    def resize(self, arg2):
        """resize(Classes self, int arg2)"""
        return _clstm.Classes_resize(self, arg2)


    def __setitem__(self, i, value):
        """__setitem__(Classes self, int i, int value)"""
        return _clstm.Classes___setitem__(self, i, value)

Classes_swigregister = _clstm.Classes_swigregister
Classes_swigregister(Classes)
cvar = _clstm.cvar

class Vec(_object):
    """Proxy of C++ Vec class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vec, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Vec self) -> Vec
        __init__(Vec self, int arg2) -> Vec
        """
        this = _clstm.new_Vec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getitem__(self, i):
        """__getitem__(Vec self, int i) -> float"""
        return _clstm.Vec___getitem__(self, i)


    def size(self):
        """size(Vec self) -> int"""
        return _clstm.Vec_size(self)


    def __setitem__(self, i, value):
        """__setitem__(Vec self, int i, float value)"""
        return _clstm.Vec___setitem__(self, i, value)

    __swig_destroy__ = _clstm.delete_Vec
    __del__ = lambda self: None
Vec_swigregister = _clstm.Vec_swigregister
Vec_swigregister(Vec)

class Mat(_object):
    """Proxy of C++ Mat class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Mat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Mat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Mat self) -> Mat
        __init__(Mat self, int arg2, int arg3) -> Mat
        """
        this = _clstm.new_Mat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getitem__(self, i, j):
        """__getitem__(Mat self, int i, int j) -> float"""
        return _clstm.Mat___getitem__(self, i, j)


    def rows(self):
        """rows(Mat self) -> int"""
        return _clstm.Mat_rows(self)


    def cols(self):
        """cols(Mat self) -> int"""
        return _clstm.Mat_cols(self)


    def setValue(self, i, j, value):
        """setValue(Mat self, int i, int j, float value)"""
        return _clstm.Mat_setValue(self, i, j, value)

    __swig_destroy__ = _clstm.delete_Mat
    __del__ = lambda self: None
Mat_swigregister = _clstm.Mat_swigregister
Mat_swigregister(Mat)

class Sequence(_object):
    """Proxy of C++ Sequence class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sequence, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Sequence, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(Sequence self) -> Sequence"""
        this = _clstm.new_Sequence()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _clstm.delete_Sequence
    __del__ = lambda self: None

    def size(self):
        """size(Sequence self) -> int"""
        return _clstm.Sequence_size(self)


    def __getitem__(self, i):
        """__getitem__(Sequence self, int i) -> Mat"""
        return _clstm.Sequence___getitem__(self, i)


    def length(self):
        """length(Sequence self) -> int"""
        return _clstm.Sequence_length(self)


    def depth(self):
        """depth(Sequence self) -> int"""
        return _clstm.Sequence_depth(self)


    def batchsize(self):
        """batchsize(Sequence self) -> int"""
        return _clstm.Sequence_batchsize(self)


    def assign(self, other):
        """assign(Sequence self, Sequence other)"""
        return _clstm.Sequence_assign(self, other)


    def resize(self, len, depth, batchsize):
        """resize(Sequence self, int len, int depth, int batchsize)"""
        return _clstm.Sequence_resize(self, len, depth, batchsize)

Sequence_swigregister = _clstm.Sequence_swigregister
Sequence_swigregister(Sequence)

class ITrainable(_object):
    """Proxy of C++ ITrainable class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ITrainable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ITrainable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _clstm.delete_ITrainable
    __del__ = lambda self: None
    __swig_setmethods__["name"] = _clstm.ITrainable_name_set
    __swig_getmethods__["name"] = _clstm.ITrainable_name_get
    if _newclass:
        name = _swig_property(_clstm.ITrainable_name_get, _clstm.ITrainable_name_set)
    __swig_setmethods__["learning_rate"] = _clstm.ITrainable_learning_rate_set
    __swig_getmethods__["learning_rate"] = _clstm.ITrainable_learning_rate_get
    if _newclass:
        learning_rate = _swig_property(_clstm.ITrainable_learning_rate_get, _clstm.ITrainable_learning_rate_set)
    __swig_setmethods__["momentum"] = _clstm.ITrainable_momentum_set
    __swig_getmethods__["momentum"] = _clstm.ITrainable_momentum_get
    if _newclass:
        momentum = _swig_property(_clstm.ITrainable_momentum_get, _clstm.ITrainable_momentum_set)
    NORM_NONE = _clstm.ITrainable_NORM_NONE
    NORM_LEN = _clstm.ITrainable_NORM_LEN
    NORM_BATCH = _clstm.ITrainable_NORM_BATCH
    NORM_DFLT = _clstm.ITrainable_NORM_DFLT
    __swig_setmethods__["normalization"] = _clstm.ITrainable_normalization_set
    __swig_getmethods__["normalization"] = _clstm.ITrainable_normalization_get
    if _newclass:
        normalization = _swig_property(_clstm.ITrainable_normalization_get, _clstm.ITrainable_normalization_set)
    __swig_setmethods__["attributes"] = _clstm.ITrainable_attributes_set
    __swig_getmethods__["attributes"] = _clstm.ITrainable_attributes_get
    if _newclass:
        attributes = _swig_property(_clstm.ITrainable_attributes_get, _clstm.ITrainable_attributes_set)

    def attr(self, *args):
        """
        attr(ITrainable self, string key, string dflt) -> string
        attr(ITrainable self, string key) -> string
        """
        return _clstm.ITrainable_attr(self, *args)


    def iattr(self, key, dflt=-1):
        """
        iattr(ITrainable self, string key, int dflt=-1) -> int
        iattr(ITrainable self, string key) -> int
        """
        return _clstm.ITrainable_iattr(self, key, dflt)


    def irequire(self, key):
        """irequire(ITrainable self, string key) -> int"""
        return _clstm.ITrainable_irequire(self, key)


    def set(self, *args):
        """
        set(ITrainable self, string key, string value)
        set(ITrainable self, string key, int value)
        set(ITrainable self, string key, double value)
        """
        return _clstm.ITrainable_set(self, *args)


    def setLearningRate(self, lr, momentum):
        """setLearningRate(ITrainable self, Float lr, Float momentum)"""
        return _clstm.ITrainable_setLearningRate(self, lr, momentum)


    def forward(self):
        """forward(ITrainable self)"""
        return _clstm.ITrainable_forward(self)


    def backward(self):
        """backward(ITrainable self)"""
        return _clstm.ITrainable_backward(self)


    def update(self):
        """update(ITrainable self)"""
        return _clstm.ITrainable_update(self)


    def idepth(self):
        """idepth(ITrainable self) -> int"""
        return _clstm.ITrainable_idepth(self)


    def odepth(self):
        """odepth(ITrainable self) -> int"""
        return _clstm.ITrainable_odepth(self)


    def initialize(self):
        """initialize(ITrainable self)"""
        return _clstm.ITrainable_initialize(self)


    def init(self, *args):
        """
        init(ITrainable self, int no, int ni)
        init(ITrainable self, int no, int nh, int ni)
        init(ITrainable self, int no, int nh2, int nh, int ni)
        """
        return _clstm.ITrainable_init(self, *args)

ITrainable_swigregister = _clstm.ITrainable_swigregister
ITrainable_swigregister(ITrainable)

class vectornet(_object):
    """Proxy of C++ std::vector<(std::shared_ptr<(INetwork)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectornet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectornet, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vectornet self) -> SwigPyIterator"""
        return _clstm.vectornet_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vectornet self) -> bool"""
        return _clstm.vectornet___nonzero__(self)


    def __bool__(self):
        """__bool__(vectornet self) -> bool"""
        return _clstm.vectornet___bool__(self)


    def __len__(self):
        """__len__(vectornet self) -> std::vector< std::shared_ptr< INetwork > >::size_type"""
        return _clstm.vectornet___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vectornet self, std::vector< std::shared_ptr< INetwork > >::difference_type i, std::vector< std::shared_ptr< INetwork > >::difference_type j) -> vectornet"""
        return _clstm.vectornet___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vectornet self, std::vector< std::shared_ptr< INetwork > >::difference_type i, std::vector< std::shared_ptr< INetwork > >::difference_type j)
        __setslice__(vectornet self, std::vector< std::shared_ptr< INetwork > >::difference_type i, std::vector< std::shared_ptr< INetwork > >::difference_type j, vectornet v)
        """
        return _clstm.vectornet___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vectornet self, std::vector< std::shared_ptr< INetwork > >::difference_type i, std::vector< std::shared_ptr< INetwork > >::difference_type j)"""
        return _clstm.vectornet___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vectornet self, std::vector< std::shared_ptr< INetwork > >::difference_type i)
        __delitem__(vectornet self, PySliceObject * slice)
        """
        return _clstm.vectornet___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vectornet self, PySliceObject * slice) -> vectornet
        __getitem__(vectornet self, std::vector< std::shared_ptr< INetwork > >::difference_type i) -> std::vector< std::shared_ptr< INetwork > >::value_type const &
        """
        return _clstm.vectornet___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vectornet self, PySliceObject * slice, vectornet v)
        __setitem__(vectornet self, PySliceObject * slice)
        __setitem__(vectornet self, std::vector< std::shared_ptr< INetwork > >::difference_type i, std::vector< std::shared_ptr< INetwork > >::value_type const & x)
        """
        return _clstm.vectornet___setitem__(self, *args)


    def pop(self):
        """pop(vectornet self) -> std::vector< std::shared_ptr< INetwork > >::value_type"""
        return _clstm.vectornet_pop(self)


    def append(self, x):
        """append(vectornet self, std::vector< std::shared_ptr< INetwork > >::value_type const & x)"""
        return _clstm.vectornet_append(self, x)


    def empty(self):
        """empty(vectornet self) -> bool"""
        return _clstm.vectornet_empty(self)


    def size(self):
        """size(vectornet self) -> std::vector< std::shared_ptr< INetwork > >::size_type"""
        return _clstm.vectornet_size(self)


    def swap(self, v):
        """swap(vectornet self, vectornet v)"""
        return _clstm.vectornet_swap(self, v)


    def begin(self):
        """begin(vectornet self) -> std::vector< std::shared_ptr< INetwork > >::iterator"""
        return _clstm.vectornet_begin(self)


    def end(self):
        """end(vectornet self) -> std::vector< std::shared_ptr< INetwork > >::iterator"""
        return _clstm.vectornet_end(self)


    def rbegin(self):
        """rbegin(vectornet self) -> std::vector< std::shared_ptr< INetwork > >::reverse_iterator"""
        return _clstm.vectornet_rbegin(self)


    def rend(self):
        """rend(vectornet self) -> std::vector< std::shared_ptr< INetwork > >::reverse_iterator"""
        return _clstm.vectornet_rend(self)


    def clear(self):
        """clear(vectornet self)"""
        return _clstm.vectornet_clear(self)


    def get_allocator(self):
        """get_allocator(vectornet self) -> std::vector< std::shared_ptr< INetwork > >::allocator_type"""
        return _clstm.vectornet_get_allocator(self)


    def pop_back(self):
        """pop_back(vectornet self)"""
        return _clstm.vectornet_pop_back(self)


    def erase(self, *args):
        """
        erase(vectornet self, std::vector< std::shared_ptr< INetwork > >::iterator pos) -> std::vector< std::shared_ptr< INetwork > >::iterator
        erase(vectornet self, std::vector< std::shared_ptr< INetwork > >::iterator first, std::vector< std::shared_ptr< INetwork > >::iterator last) -> std::vector< std::shared_ptr< INetwork > >::iterator
        """
        return _clstm.vectornet_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::shared_ptr<(INetwork)>)> self) -> vectornet
        __init__(std::vector<(std::shared_ptr<(INetwork)>)> self, vectornet arg2) -> vectornet
        __init__(std::vector<(std::shared_ptr<(INetwork)>)> self, std::vector< std::shared_ptr< INetwork > >::size_type size) -> vectornet
        __init__(std::vector<(std::shared_ptr<(INetwork)>)> self, std::vector< std::shared_ptr< INetwork > >::size_type size, std::vector< std::shared_ptr< INetwork > >::value_type const & value) -> vectornet
        """
        this = _clstm.new_vectornet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vectornet self, std::vector< std::shared_ptr< INetwork > >::value_type const & x)"""
        return _clstm.vectornet_push_back(self, x)


    def front(self):
        """front(vectornet self) -> std::vector< std::shared_ptr< INetwork > >::value_type const &"""
        return _clstm.vectornet_front(self)


    def back(self):
        """back(vectornet self) -> std::vector< std::shared_ptr< INetwork > >::value_type const &"""
        return _clstm.vectornet_back(self)


    def assign(self, n, x):
        """assign(vectornet self, std::vector< std::shared_ptr< INetwork > >::size_type n, std::vector< std::shared_ptr< INetwork > >::value_type const & x)"""
        return _clstm.vectornet_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vectornet self, std::vector< std::shared_ptr< INetwork > >::size_type new_size)
        resize(vectornet self, std::vector< std::shared_ptr< INetwork > >::size_type new_size, std::vector< std::shared_ptr< INetwork > >::value_type const & x)
        """
        return _clstm.vectornet_resize(self, *args)


    def insert(self, *args):
        """
        insert(vectornet self, std::vector< std::shared_ptr< INetwork > >::iterator pos, std::vector< std::shared_ptr< INetwork > >::value_type const & x) -> std::vector< std::shared_ptr< INetwork > >::iterator
        insert(vectornet self, std::vector< std::shared_ptr< INetwork > >::iterator pos, std::vector< std::shared_ptr< INetwork > >::size_type n, std::vector< std::shared_ptr< INetwork > >::value_type const & x)
        """
        return _clstm.vectornet_insert(self, *args)


    def reserve(self, n):
        """reserve(vectornet self, std::vector< std::shared_ptr< INetwork > >::size_type n)"""
        return _clstm.vectornet_reserve(self, n)


    def capacity(self):
        """capacity(vectornet self) -> std::vector< std::shared_ptr< INetwork > >::size_type"""
        return _clstm.vectornet_capacity(self)

    __swig_destroy__ = _clstm.delete_vectornet
    __del__ = lambda self: None
vectornet_swigregister = _clstm.vectornet_swigregister
vectornet_swigregister(vectornet)

class INetwork(ITrainable):
    """Proxy of C++ INetwork class."""

    __swig_setmethods__ = {}
    for _s in [ITrainable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, INetwork, name, value)
    __swig_getmethods__ = {}
    for _s in [ITrainable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, INetwork, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _clstm.delete_INetwork
    __del__ = lambda self: None
    __swig_setmethods__["inputs"] = _clstm.INetwork_inputs_set
    __swig_getmethods__["inputs"] = _clstm.INetwork_inputs_get
    if _newclass:
        inputs = _swig_property(_clstm.INetwork_inputs_get, _clstm.INetwork_inputs_set)
    __swig_setmethods__["d_inputs"] = _clstm.INetwork_d_inputs_set
    __swig_getmethods__["d_inputs"] = _clstm.INetwork_d_inputs_get
    if _newclass:
        d_inputs = _swig_property(_clstm.INetwork_d_inputs_get, _clstm.INetwork_d_inputs_set)
    __swig_setmethods__["outputs"] = _clstm.INetwork_outputs_set
    __swig_getmethods__["outputs"] = _clstm.INetwork_outputs_get
    if _newclass:
        outputs = _swig_property(_clstm.INetwork_outputs_get, _clstm.INetwork_outputs_set)
    __swig_setmethods__["d_outputs"] = _clstm.INetwork_d_outputs_set
    __swig_getmethods__["d_outputs"] = _clstm.INetwork_d_outputs_get
    if _newclass:
        d_outputs = _swig_property(_clstm.INetwork_d_outputs_get, _clstm.INetwork_d_outputs_set)
    __swig_setmethods__["sub"] = _clstm.INetwork_sub_set
    __swig_getmethods__["sub"] = _clstm.INetwork_sub_get
    if _newclass:
        sub = _swig_property(_clstm.INetwork_sub_get, _clstm.INetwork_sub_set)
    __swig_setmethods__["codec"] = _clstm.INetwork_codec_set
    __swig_getmethods__["codec"] = _clstm.INetwork_codec_get
    if _newclass:
        codec = _swig_property(_clstm.INetwork_codec_get, _clstm.INetwork_codec_set)
    __swig_setmethods__["icodec"] = _clstm.INetwork_icodec_set
    __swig_getmethods__["icodec"] = _clstm.INetwork_icodec_get
    if _newclass:
        icodec = _swig_property(_clstm.INetwork_icodec_get, _clstm.INetwork_icodec_set)

    def decode(self, cs):
        """decode(INetwork self, Classes cs) -> std::wstring"""
        return _clstm.INetwork_decode(self, cs)


    def idecode(self, cs):
        """idecode(INetwork self, Classes cs) -> std::wstring"""
        return _clstm.INetwork_idecode(self, cs)


    def encode(self, cs, s):
        """encode(INetwork self, Classes cs, std::wstring & s)"""
        return _clstm.INetwork_encode(self, cs, s)


    def iencode(self, cs, s):
        """iencode(INetwork self, Classes cs, std::wstring & s)"""
        return _clstm.INetwork_iencode(self, cs, s)

    __swig_setmethods__["softmax_floor"] = _clstm.INetwork_softmax_floor_set
    __swig_getmethods__["softmax_floor"] = _clstm.INetwork_softmax_floor_get
    if _newclass:
        softmax_floor = _swig_property(_clstm.INetwork_softmax_floor_get, _clstm.INetwork_softmax_floor_set)
    __swig_setmethods__["softmax_accel"] = _clstm.INetwork_softmax_accel_set
    __swig_getmethods__["softmax_accel"] = _clstm.INetwork_softmax_accel_get
    if _newclass:
        softmax_accel = _swig_property(_clstm.INetwork_softmax_accel_get, _clstm.INetwork_softmax_accel_set)

    def ninput(self):
        """ninput(INetwork self) -> int"""
        return _clstm.INetwork_ninput(self)


    def noutput(self):
        """noutput(INetwork self) -> int"""
        return _clstm.INetwork_noutput(self)


    def add(self, net):
        """add(INetwork self, std::shared_ptr< INetwork > net)"""
        return _clstm.INetwork_add(self, net)


    def setLearningRate(self, lr, momentum):
        """setLearningRate(INetwork self, Float lr, Float momentum)"""
        return _clstm.INetwork_setLearningRate(self, lr, momentum)


    def info(self, prefix):
        """info(INetwork self, string prefix)"""
        return _clstm.INetwork_info(self, prefix)


    def getState(self, name):
        """getState(INetwork self, string name) -> Sequence"""
        return _clstm.INetwork_getState(self, name)

INetwork_swigregister = _clstm.INetwork_swigregister
INetwork_swigregister(INetwork)


def set_inputs(net, inputs):
    """set_inputs(INetwork net, Sequence inputs)"""
    return _clstm.set_inputs(net, inputs)

def set_targets(net, targets):
    """set_targets(INetwork net, Sequence targets)"""
    return _clstm.set_targets(net, targets)

def set_targets_accelerated(net, targets):
    """set_targets_accelerated(INetwork net, Sequence targets)"""
    return _clstm.set_targets_accelerated(net, targets)

def set_classes(net, classes):
    """set_classes(INetwork net, Classes classes)"""
    return _clstm.set_classes(net, classes)

def train(net, xs, targets):
    """train(INetwork net, Sequence xs, Sequence targets)"""
    return _clstm.train(net, xs, targets)

def ctrain(net, xs, cs):
    """ctrain(INetwork net, Sequence xs, Classes cs)"""
    return _clstm.ctrain(net, xs, cs)

def ctrain_accelerated(net, xs, cs, lo=1e-5):
    """
    ctrain_accelerated(INetwork net, Sequence xs, Classes cs, Float lo=1e-5)
    ctrain_accelerated(INetwork net, Sequence xs, Classes cs)
    """
    return _clstm.ctrain_accelerated(net, xs, cs, lo)

def cpred(net, preds, xs):
    """cpred(INetwork net, Classes preds, Sequence xs)"""
    return _clstm.cpred(net, preds, xs)

def mktargets(seq, targets, ndim):
    """mktargets(Sequence seq, Classes targets, int ndim)"""
    return _clstm.mktargets(seq, targets, ndim)

def make_layer(arg1):
    """make_layer(string arg1) -> std::shared_ptr< INetwork >"""
    return _clstm.make_layer(arg1)

def make_net_init(arg1, arg2):
    """make_net_init(string arg1, string arg2) -> std::shared_ptr< INetwork >"""
    return _clstm.make_net_init(arg1, arg2)

def seq_forward(lr, lmatch, skip=-5.0):
    """
    seq_forward(Mat lr, Mat lmatch, double skip=-5.0)
    seq_forward(Mat lr, Mat lmatch)
    """
    return _clstm.seq_forward(lr, lmatch, skip)

def seq_forwardbackward(both, lmatch):
    """seq_forwardbackward(Mat both, Mat lmatch)"""
    return _clstm.seq_forwardbackward(both, lmatch)

def seq_ctc_align(posteriors, outputs, targets):
    """seq_ctc_align(Sequence posteriors, Sequence outputs, Sequence targets)"""
    return _clstm.seq_ctc_align(posteriors, outputs, targets)

def save_net(file, net):
    """save_net(string const & file, Network net)"""
    return _clstm.save_net(file, net)

def load_net(file):
    """load_net(string const & file) -> Network"""
    return _clstm.load_net(file)

def getdebugmat():
    """getdebugmat() -> Mat"""
    return _clstm.getdebugmat()

def string_edit_distance(a, b):
    """string_edit_distance(string a, string b) -> int"""
    return _clstm.string_edit_distance(a, b)

def network_info(net):
    """network_info(Network net) -> string"""
    return _clstm.network_info(net)

def sequence_info(seq):
    """sequence_info(Sequence seq) -> string"""
    return _clstm.sequence_info(seq)

def mat_of_array(a, object_):
    """mat_of_array(Mat a, PyObject * object_)"""
    return _clstm.mat_of_array(a, object_)

def array_of_mat(object_, a):
    """array_of_mat(PyObject * object_, Mat a)"""
    return _clstm.array_of_mat(object_, a)

def sequence_of_array(a, object_):
    """sequence_of_array(Sequence a, PyObject * object_)"""
    return _clstm.sequence_of_array(a, object_)

def array_of_sequence(object_, a):
    """array_of_sequence(PyObject * object_, Sequence a)"""
    return _clstm.array_of_sequence(object_, a)

import numpy

def Sequence_array(self):
    a = numpy.zeros(1,'f')
    array_of_sequence(a, self)
    return a
Sequence.array = Sequence_array

def Sequence_aset(self, a):
    sequence_of_array(self, a)
Sequence.aset = Sequence_aset

def ctcalign(outputs_,targets_):
    outputs = Sequence()
    targets = Sequence()
    outputs.aset(outputs_)
    targets.aset(targets_)
    posteriors = Sequence()
    seq_ctc_align(posteriors,outputs,targets)
    return posteriors.array()

# This file is compatible with both classic and new-style classes.


